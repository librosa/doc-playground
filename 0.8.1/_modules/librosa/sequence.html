<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.sequence &mdash; librosa 0.8.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../index.html">
            <img src="../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>librosa.sequence</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             

<div class="admonition danger">
    <p class="admonition-title"> Caution </p>
  <p>
    
        
            You're reading an old version of this documentation.
            If you want up-to-date information, please have a look at <a href="../../../0.9.1/index.html">0.9.1</a>.
        
    
  </p>
</div>


  <h1>Source code for librosa.sequence</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- encoding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sequential modeling</span>
<span class="sd">===================</span>

<span class="sd">Sequence alignment</span>
<span class="sd">------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    dtw</span>
<span class="sd">    rqa</span>

<span class="sd">Viterbi decoding</span>
<span class="sd">----------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    viterbi</span>
<span class="sd">    viterbi_discriminative</span>
<span class="sd">    viterbi_binary</span>

<span class="sd">Transition matrices</span>
<span class="sd">-------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    transition_uniform</span>
<span class="sd">    transition_loop</span>
<span class="sd">    transition_cycle</span>
<span class="sd">    transition_local</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">pad_center</span><span class="p">,</span> <span class="n">fill_off_diagonal</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">.filters</span> <span class="kn">import</span> <span class="n">get_window</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;dtw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dtw_backtracking&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rqa&quot;</span><span class="p">,</span>
    <span class="s2">&quot;viterbi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;viterbi_discriminative&quot;</span><span class="p">,</span>
    <span class="s2">&quot;viterbi_binary&quot;</span><span class="p">,</span>
    <span class="s2">&quot;transition_uniform&quot;</span><span class="p">,</span>
    <span class="s2">&quot;transition_loop&quot;</span><span class="p">,</span>
    <span class="s2">&quot;transition_cycle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;transition_local&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="dtw"><a class="viewcode-back" href="../../generated/librosa.sequence.dtw.html#librosa.sequence.dtw">[docs]</a><span class="k">def</span> <span class="nf">dtw</span><span class="p">(</span>
    <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
    <span class="n">step_sizes_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weights_add</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weights_mul</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">subseq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">backtrack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">global_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">band_rad</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">return_steps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dynamic time warping (DTW).</span>

<span class="sd">    This function performs a DTW and path backtracking on two sequences.</span>
<span class="sd">    We follow the nomenclature and algorithmic approach as described in [#]_.</span>

<span class="sd">    .. [#] Meinard Mueller</span>
<span class="sd">           Fundamentals of Music Processing — Audio, Analysis, Algorithms, Applications</span>
<span class="sd">           Springer Verlag, ISBN: 978-3-319-21944-8, 2015.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray [shape=(K, N)]</span>
<span class="sd">        audio feature matrix (e.g., chroma features)</span>

<span class="sd">    Y : np.ndarray [shape=(K, M)]</span>
<span class="sd">        audio feature matrix (e.g., chroma features)</span>

<span class="sd">    C : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Precomputed distance matrix. If supplied, X and Y must not be supplied and</span>
<span class="sd">        ``metric`` will be ignored.</span>

<span class="sd">    metric : str</span>
<span class="sd">        Identifier for the cost-function as documented</span>
<span class="sd">        in `scipy.spatial.distance.cdist()`</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    weights_add : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Additive weights to penalize certain step sizes.</span>

<span class="sd">    weights_mul : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Multiplicative weights to penalize certain step sizes.</span>

<span class="sd">    subseq : bool</span>
<span class="sd">        Enable subsequence DTW, e.g., for retrieval tasks.</span>

<span class="sd">    backtrack : bool</span>
<span class="sd">        Enable backtracking in accumulated cost matrix.</span>

<span class="sd">    global_constraints : bool</span>
<span class="sd">        Applies global constraints to the cost matrix ``C`` (Sakoe-Chiba band).</span>

<span class="sd">    band_rad : float</span>
<span class="sd">        The Sakoe-Chiba band radius (1/2 of the width) will be</span>
<span class="sd">        ``int(radius*min(C.shape))``.</span>

<span class="sd">    return_steps : bool</span>
<span class="sd">        If true, the function returns ``steps``, the step matrix, containing</span>
<span class="sd">        the indices of the used steps from the cost accumulation step.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(N, M)]</span>
<span class="sd">        accumulated cost matrix.</span>
<span class="sd">        D[N, M] is the total alignment cost.</span>
<span class="sd">        When doing subsequence DTW, D[N,:] indicates a matching function.</span>

<span class="sd">    wp : np.ndarray [shape=(N, 2)]</span>
<span class="sd">        Warping path with index pairs.</span>
<span class="sd">        Each row of the array contains an index pair (n, m).</span>
<span class="sd">        Only returned when ``backtrack`` is True.</span>

<span class="sd">    steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Step matrix, containing the indices of the used steps from the cost</span>
<span class="sd">        accumulation step.</span>
<span class="sd">        Only returned when ``return_steps`` is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If you are doing diagonal matching and Y is shorter than X or if an</span>
<span class="sd">        incompatible combination of X, Y, and C are supplied.</span>

<span class="sd">        If your input dimensions are incompatible.</span>

<span class="sd">        If the cost matrix has NaN values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;brahms&#39;), offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; X = librosa.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; noise = np.random.rand(X.shape[0], 200)</span>
<span class="sd">    &gt;&gt;&gt; Y = np.concatenate((noise, noise, X, noise), axis=1)</span>
<span class="sd">    &gt;&gt;&gt; D, wp = librosa.sequence.dtw(X, Y, subseq=True)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(D, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;,</span>
<span class="sd">    ...                                ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;DTW cost&#39;, xlabel=&#39;Noisy sequence&#39;, ylabel=&#39;Target&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(wp[:, 1], wp[:, 0], label=&#39;Optimal path&#39;, color=&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend()</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(D[-1, :] / wp.shape[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(xlim=[0, Y.shape[1]], ylim=[0, 2],</span>
<span class="sd">    ...           title=&#39;Matching cost function&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Default Parameters</span>
    <span class="n">default_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">default_weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">default_weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">step_sizes_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use the default steps</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">default_steps</span>

        <span class="c1"># Use default weights if none are provided</span>
        <span class="k">if</span> <span class="n">weights_add</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_add</span> <span class="o">=</span> <span class="n">default_weights_add</span>

        <span class="k">if</span> <span class="n">weights_mul</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">default_weights_mul</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If we have custom steps but no weights, construct them here</span>
        <span class="k">if</span> <span class="n">weights_add</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights_mul</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Make the default step weights infinite so that they are never</span>
        <span class="c1"># preferred over custom steps</span>
        <span class="n">default_weights_add</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">default_weights_mul</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="c1"># Append custom steps and weights to our defaults</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">))</span>
        <span class="n">weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_weights_add</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">))</span>
        <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_weights_mul</span><span class="p">,</span> <span class="n">weights_mul</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">step_sizes_sigma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;step_sizes_sigma cannot contain negative values&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_add</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;len(weights_add) must be equal to len(step_sizes_sigma)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_mul</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;len(weights_mul) must be equal to len(step_sizes_sigma)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;If C is not supplied, both X and Y must be supplied&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;If C is supplied, both X and Y must not be supplied&quot;</span><span class="p">)</span>

    <span class="n">c_is_transposed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># calculate pair-wise distances, unless already supplied.</span>
    <span class="c1"># C_local will keep track of whether the distance matrix was supplied</span>
    <span class="c1"># by the user (False) or constructed locally (True)</span>
    <span class="n">C_local</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C_local</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># take care of dimensions</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                <span class="s2">&quot;scipy.spatial.distance.cdist returned an error.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Please provide your input in the form X.shape=(K, N) &quot;</span>
                <span class="s2">&quot;and Y.shape=(K, M).</span><span class="se">\n</span><span class="s2"> 1-dimensional sequences should &quot;</span>
                <span class="s2">&quot;be reshaped to X.shape=(1, N) and Y.shape=(1, M).&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

        <span class="c1"># for subsequence matching:</span>
        <span class="c1"># if N &gt; M, Y can be a subsequence of X</span>
        <span class="k">if</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span>
            <span class="n">c_is_transposed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="c1"># if diagonal matching, Y has to be longer than X</span>
    <span class="c1"># (X simply cannot be contained in Y)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;For diagonal matching: Y.shape[1] &gt;= X.shape[1] &quot;</span>
            <span class="s2">&quot;(C.shape[1] &gt;= C.shape[0])&quot;</span>
        <span class="p">)</span>

    <span class="n">max_0</span> <span class="o">=</span> <span class="n">step_sizes_sigma</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">max_1</span> <span class="o">=</span> <span class="n">step_sizes_sigma</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># check C here for nans before building global constraints</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">C</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;DTW cost matrix C has NaN values. &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">global_constraints</span><span class="p">:</span>
        <span class="c1"># Apply global constraints to the cost matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">C_local</span><span class="p">:</span>
            <span class="c1"># If C was provided as input, make a copy here</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">fill_off_diagonal</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">band_rad</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="c1"># initialize whole matrix with infinity values</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># set starting point to C[0, 0]</span>
    <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">subseq</span><span class="p">:</span>
        <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># initialize step matrix with -1</span>
    <span class="c1"># will be filled in calc_accu_cost() with indices from step_sizes_sigma</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># these steps correspond to left- (first row) and up-(first column) moves</span>
    <span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">steps</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># calculate accumulated cost matrix</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">__dtw_calc_accu_cost</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">weights_mul</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">,</span> <span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span>
    <span class="p">)</span>

    <span class="c1"># delete infinity rows and columns</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">:,</span> <span class="n">max_1</span><span class="p">:]</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">max_0</span><span class="p">:,</span> <span class="n">max_1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">backtrack</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">subseq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                    <span class="s2">&quot;No valid sub-sequence warping path could &quot;</span>
                    <span class="s2">&quot;be constructed with the given step sizes.&quot;</span>
                <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">wp</span> <span class="o">=</span> <span class="n">__dtw_backtracking</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># perform warping path backtracking</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                    <span class="s2">&quot;No valid sub-sequence warping path could &quot;</span>
                    <span class="s2">&quot;be constructed with the given step sizes.&quot;</span>
                <span class="p">)</span>

            <span class="n">wp</span> <span class="o">=</span> <span class="n">__dtw_backtracking</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to compute a full DTW warping path. &quot;</span>
                    <span class="s2">&quot;You may want to try again with subseq=True.&quot;</span>
                <span class="p">)</span>

        <span class="n">wp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># since we transposed in the beginning, we have to adjust the index pairs back</span>
        <span class="k">if</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">c_is_transposed</span>
            <span class="ow">or</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">wp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">wp</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_steps</span><span class="p">:</span>
        <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">return_values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__dtw_calc_accu_cost</span><span class="p">(</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">weights_mul</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">,</span> <span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span>
<span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Calculate the accumulated cost matrix D.</span>

<span class="sd">    Use dynamic programming to calculate the accumulated costs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : np.ndarray [shape=(N, M)]</span>
<span class="sd">        pre-computed cost matrix</span>

<span class="sd">    D : np.ndarray [shape=(N, M)]</span>
<span class="sd">        accumulated cost matrix</span>

<span class="sd">    steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Step matrix, containing the indices of the used steps from the cost</span>
<span class="sd">        accumulation step.</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    weights_add : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Additive weights to penalize certain step sizes.</span>

<span class="sd">    weights_mul : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Multiplicative weights to penalize certain step sizes.</span>

<span class="sd">    max_0 : int</span>
<span class="sd">        maximum number of steps in step_sizes_sigma in dim 0.</span>

<span class="sd">    max_1 : int</span>
<span class="sd">        maximum number of steps in step_sizes_sigma in dim 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(N, M)]</span>
<span class="sd">        accumulated cost matrix.</span>
<span class="sd">        D[N, M] is the total alignment cost.</span>
<span class="sd">        When doing subsequence DTW, D[N,:] indicates a matching function.</span>

<span class="sd">    steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Step matrix, containing the indices of the used steps from the cost</span>
<span class="sd">        accumulation step.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtw</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">cur_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">cur_m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_1</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># accumulate costs</span>
            <span class="k">for</span> <span class="n">cur_step_idx</span><span class="p">,</span> <span class="n">cur_w_add</span><span class="p">,</span> <span class="n">cur_w_mul</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">weights_add</span><span class="p">,</span> <span class="n">weights_mul</span>
            <span class="p">):</span>
                <span class="n">cur_D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span>
                    <span class="n">cur_n</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">cur_m</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">cur_C</span> <span class="o">=</span> <span class="n">cur_w_mul</span> <span class="o">*</span> <span class="n">C</span><span class="p">[</span><span class="n">cur_n</span> <span class="o">-</span> <span class="n">max_0</span><span class="p">,</span> <span class="n">cur_m</span> <span class="o">-</span> <span class="n">max_1</span><span class="p">]</span>
                <span class="n">cur_C</span> <span class="o">+=</span> <span class="n">cur_w_add</span>
                <span class="n">cur_cost</span> <span class="o">=</span> <span class="n">cur_D</span> <span class="o">+</span> <span class="n">cur_C</span>

                <span class="c1"># check if cur_cost is smaller than the one stored in D</span>
                <span class="k">if</span> <span class="n">cur_cost</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]:</span>
                    <span class="n">D</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cost</span>

                    <span class="c1"># save step-index</span>
                    <span class="n">steps</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_step_idx</span>

    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">steps</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__dtw_backtracking</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Backtrack optimal warping path.</span>

<span class="sd">    Uses the saved step sizes from the cost accumulation</span>
<span class="sd">    step to backtrack the index pairs for an optimal</span>
<span class="sd">    warping path.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Step matrix, containing the indices of the used steps from the cost</span>
<span class="sd">        accumulation step.</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    subseq : bool</span>
<span class="sd">        Enable subsequence DTW, e.g., for retrieval tasks.</span>

<span class="sd">    start : int</span>
<span class="sd">        Start column index for backtraing (only allowed for ``subseq=True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wp : list [shape=(N,)]</span>
<span class="sd">        Warping path with index pairs.</span>
<span class="sd">        Each list entry contains an index pair</span>
<span class="sd">        (n, m) as a tuple</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtw</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>

    <span class="n">wp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Set starting point D(N, M) and append it to the path</span>
    <span class="n">wp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Loop backwards.</span>
    <span class="c1"># Stop criteria:</span>
    <span class="c1"># Setting it to (0, 0) does not work for the subsequence dtw,</span>
    <span class="c1"># so we only ask to reach the first row of the matrix.</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">subseq</span> <span class="ow">and</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="n">cur_idx</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">cur_step_idx</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[(</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># save tuple with minimal acc. cost in path</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># If we run off the side of the cost matrix, break here</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">cur_idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># append to warping path</span>
        <span class="n">wp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">wp</span>


<span class="k">def</span> <span class="nf">dtw_backtracking</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subseq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Backtrack a warping path.</span>

<span class="sd">    Uses the saved step sizes from the cost accumulation</span>
<span class="sd">    step to backtrack the index pairs for a warping path.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Step matrix, containing the indices of the used steps from the cost</span>
<span class="sd">        accumulation step.</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    subseq : bool</span>
<span class="sd">        Enable subsequence DTW, e.g., for retrieval tasks.</span>

<span class="sd">    start : int</span>
<span class="sd">        Start column index for backtraing (only allowed for ``subseq=True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wp : list [shape=(N,)]</span>
<span class="sd">        Warping path with index pairs.</span>
<span class="sd">        Each list entry contains an index pair</span>
<span class="sd">        (n, m) as a tuple</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtw</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">subseq</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;start is only allowed to be set if subseq is True &quot;</span>
            <span class="s2">&quot;(start=</span><span class="si">{}</span><span class="s2">, subseq=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">subseq</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Default Parameters</span>
    <span class="n">default_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">step_sizes_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use the default steps</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">default_steps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Append custom steps and weights to our defaults</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">))</span>

    <span class="n">wp</span> <span class="o">=</span> <span class="n">__dtw_backtracking</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>


<div class="viewcode-block" id="rqa"><a class="viewcode-back" href="../../generated/librosa.sequence.rqa.html#librosa.sequence.rqa">[docs]</a><span class="k">def</span> <span class="nf">rqa</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gap_extend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">knight_moves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">backtrack</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recurrence quantification analysis (RQA)</span>

<span class="sd">    This function implements different forms of RQA as described by</span>
<span class="sd">    Serra, Serra, and Andrzejak (SSA). [#]_  These methods take as input</span>
<span class="sd">    a self- or cross-similarity matrix ``sim``, and calculate the value</span>
<span class="sd">    of path alignments by dynamic programming.</span>

<span class="sd">    Note that unlike dynamic time warping (`dtw`), alignment paths here are</span>
<span class="sd">    maximized, not minimized, so the input should measure similarity rather</span>
<span class="sd">    than distance.</span>

<span class="sd">    The simplest RQA method, denoted as `L` (SSA equation 3) and equivalent</span>
<span class="sd">    to the method described by Eckman, Kamphorst, and Ruelle [#]_, accumulates</span>
<span class="sd">    the length of diagonal paths with positive values in the input:</span>

<span class="sd">        - ``score[i, j] = score[i-1, j-1] + 1``  if ``sim[i, j] &gt; 0``</span>
<span class="sd">        - ``score[i, j] = 0`` otherwise.</span>

<span class="sd">    The second method, denoted as `S` (SSA equation 4), is similar to the first,</span>
<span class="sd">    but allows for &quot;knight moves&quot; (as in the chess piece) in addition to strict</span>
<span class="sd">    diagonal moves:</span>

<span class="sd">        - ``score[i, j] = max(score[i-1, j-1], score[i-2, j-1], score[i-1, j-2]) + 1``  if ``sim[i, j] &gt;</span>
<span class="sd">          0``</span>
<span class="sd">        - ``score[i, j] = 0`` otherwise.</span>

<span class="sd">    The third method, denoted as `Q` (SSA equations 5 and 6) extends this by</span>
<span class="sd">    allowing gaps in the alignment that incur some cost, rather than a hard</span>
<span class="sd">    reset to 0 whenever ``sim[i, j] == 0``.</span>
<span class="sd">    Gaps are penalized by two additional parameters, ``gap_onset`` and ``gap_extend``,</span>
<span class="sd">    which are subtracted from the value of the alignment path every time a gap</span>
<span class="sd">    is introduced or extended (respectively).</span>

<span class="sd">    Note that setting ``gap_onset`` and ``gap_extend`` to `np.inf` recovers the second</span>
<span class="sd">    method, and disabling knight moves recovers the first.</span>


<span class="sd">    .. [#] Serrà, Joan, Xavier Serra, and Ralph G. Andrzejak.</span>
<span class="sd">        &quot;Cross recurrence quantification for cover song identification.&quot;</span>
<span class="sd">        New Journal of Physics 11, no. 9 (2009): 093017.</span>

<span class="sd">    .. [#] Eckmann, J. P., S. Oliffson Kamphorst, and D. Ruelle.</span>
<span class="sd">        &quot;Recurrence plots of dynamical systems.&quot;</span>
<span class="sd">        World Scientific Series on Nonlinear Science Series A 16 (1995): 441-446.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sim : np.ndarray [shape=(N, M), non-negative]</span>
<span class="sd">        The similarity matrix to use as input.</span>

<span class="sd">        This can either be a recurrence matrix (self-similarity)</span>
<span class="sd">        or a cross-similarity matrix between two sequences.</span>

<span class="sd">    gap_onset : float &gt; 0</span>
<span class="sd">        Penalty for introducing a gap to an alignment sequence</span>

<span class="sd">    gap_extend : float &gt; 0</span>
<span class="sd">        Penalty for extending a gap in an alignment sequence</span>

<span class="sd">    knight_moves : bool</span>
<span class="sd">        If ``True`` (default), allow for &quot;knight moves&quot; in the alignment,</span>
<span class="sd">        e.g., ``(n, m) =&gt; (n + 1, m + 2)`` or ``(n + 2, m + 1)``.</span>

<span class="sd">        If ``False``, only allow for diagonal moves ``(n, m) =&gt; (n + 1, m + 1)``.</span>

<span class="sd">    backtrack : bool</span>
<span class="sd">        If ``True``, return the alignment path.</span>

<span class="sd">        If ``False``, only return the score matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    score : np.ndarray [shape=(N, M)]</span>
<span class="sd">        The alignment score matrix.  ``score[n, m]`` is the cumulative value of</span>
<span class="sd">        the best alignment sequence ending in frames ``n`` and ``m``.</span>

<span class="sd">    path : np.ndarray [shape=(k, 2)] (optional)</span>
<span class="sd">        If ``backtrack=True``, ``path`` contains a list of pairs of aligned frames</span>
<span class="sd">        in the best alignment sequence.</span>

<span class="sd">        ``path[i] = [n, m]`` indicates that row ``n`` aligns to column ``m``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.segment.recurrence_matrix</span>
<span class="sd">    librosa.segment.cross_similarity</span>
<span class="sd">    dtw</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Simple diagonal path enhancement (L-mode)</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=30)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Use time-delay embedding to reduce noise</span>
<span class="sd">    &gt;&gt;&gt; chroma_stack = librosa.feature.stack_memory(chroma, n_steps=10, delay=3)</span>
<span class="sd">    &gt;&gt;&gt; # Build recurrence, suppress self-loops within 1 second</span>
<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(chroma_stack, width=43,</span>
<span class="sd">    ...                                         mode=&#39;affinity&#39;,</span>
<span class="sd">    ...                                         metric=&#39;cosine&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # using infinite cost for gaps enforces strict path continuation</span>
<span class="sd">    &gt;&gt;&gt; L_score, L_path = librosa.sequence.rqa(rec, np.inf, np.inf,</span>
<span class="sd">    ...                                        knight_moves=False)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(ncols=2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(L_score, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Alignment score matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(L_path[:, 1], L_path[:, 0], label=&#39;Optimal path&#39;, color=&#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>

<span class="sd">    Full alignment using gaps and knight moves</span>

<span class="sd">    &gt;&gt;&gt; # New gaps cost 5, extending old gaps cost 10 for each step</span>
<span class="sd">    &gt;&gt;&gt; score, path = librosa.sequence.rqa(rec, 5, 10)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(ncols=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(score, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Alignment score matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(path[:, 1], path[:, 0], label=&#39;Optimal path&#39;, color=&#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">gap_onset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;gap_onset=</span><span class="si">{}</span><span class="s2"> must be strictly positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gap_extend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;gap_extend=</span><span class="si">{}</span><span class="s2"> must be strictly positive&quot;</span><span class="p">)</span>

    <span class="n">score</span><span class="p">,</span> <span class="n">pointers</span> <span class="o">=</span> <span class="n">__rqa_dp</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="p">,</span> <span class="n">gap_extend</span><span class="p">,</span> <span class="n">knight_moves</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">backtrack</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">__rqa_backtrack</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pointers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">path</span>

    <span class="k">return</span> <span class="n">score</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__rqa_dp</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="p">,</span> <span class="n">gap_extend</span><span class="p">,</span> <span class="n">knight</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;RQA dynamic programming implementation&quot;&quot;&quot;</span>

    <span class="c1"># The output array</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># The backtracking array</span>
    <span class="n">backtrack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="c1"># These are place-holder arrays to limit the points being considered</span>
    <span class="c1"># at each step of the DP</span>
    <span class="c1">#</span>
    <span class="c1"># If knight moves are enabled, values are indexed according to</span>
    <span class="c1"># [(-1,-1), (-1, -2), (-2, -1)]</span>
    <span class="c1">#</span>
    <span class="c1"># If knight moves are disabled, then only the first entry is used.</span>
    <span class="c1">#</span>
    <span class="c1"># Using dummy vectors here makes the code a bit cleaner down below.</span>
    <span class="n">sim_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">score_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">knight</span><span class="p">:</span>
        <span class="c1"># Initial limit is for the base case: diagonal + one knight</span>
        <span class="n">init_limit</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Otherwise, we have 3 positions</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">init_limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># backtracking rubric:</span>
    <span class="c1">#   0 ==&gt; diagonal move</span>
    <span class="c1">#   1 ==&gt; knight move up</span>
    <span class="c1">#   2 ==&gt; knight move left</span>
    <span class="c1">#  -1 ==&gt; reset without inclusion</span>
    <span class="c1">#  -2 ==&gt; reset with inclusion (ie positive value at init)</span>

    <span class="c1"># Initialize the first row and column with the data</span>
    <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">score</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># backtracking initialization: the first row and column are all resets</span>
    <span class="c1"># if there&#39;s a positive link here, it&#39;s an inclusive reset</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the 1-1 case using only the diagonal</span>
    <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">*</span> <span class="n">gap_onset</span> <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">link</span><span class="p">)</span> <span class="o">*</span> <span class="n">gap_extend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the second row with diagonal and left-knight moves</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">score_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sim_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># or + 1 for binary</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span>
            <span class="p">)</span>

            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
            <span class="c1"># Is it a reset?</span>
            <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the second column with diagonal and up-knight moves</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">score_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sim_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># or + 1 for binary</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span>
            <span class="p">)</span>

            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
            <span class="c1"># Is it a reset?</span>
            <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Now fill in the rest of the table</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">score_values</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">sim_values</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if knight is true, it&#39;s max of (-1,-1), (-1, -2), (-2, -1)</span>
                <span class="c1"># otherwise, it&#39;s just the diagonal move (-1, -1)</span>
                <span class="c1"># for backtracking purposes, if the max is 0 then it&#39;s the start of a new sequence</span>
                <span class="c1"># if the max is non-zero, then we extend the existing sequence</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># or + 1 for binary</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the max of our options is negative, then it&#39;s a hard reset</span>
                <span class="c1"># otherwise, it&#39;s a skip move</span>
                <span class="n">vec</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">score_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                    <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span>
                <span class="p">)</span>

                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
                <span class="c1"># Is it a reset?</span>
                <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">backtrack</span>


<span class="k">def</span> <span class="nf">__rqa_backtrack</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pointers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RQA path backtracking</span>

<span class="sd">    Given the score matrix and backtracking index array,</span>
<span class="sd">    reconstruct the optimal path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># backtracking rubric:</span>
    <span class="c1">#   0 ==&gt; diagonal move</span>
    <span class="c1">#   1 ==&gt; knight move up</span>
    <span class="c1">#   2 ==&gt; knight move left</span>
    <span class="c1">#  -1 ==&gt; reset (sim = 0)</span>
    <span class="c1">#  -2 ==&gt; start of sequence (sim &gt; 0)</span>

    <span class="c1"># This array maps the backtracking values to the</span>
    <span class="c1"># relative index offsets</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Find the maximum to end the path</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="n">score</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Construct the path</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">bt_index</span> <span class="o">=</span> <span class="n">pointers</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>

        <span class="c1"># A -1 indicates a non-inclusive reset</span>
        <span class="c1"># this can only happen when sim[idx] == 0,</span>
        <span class="c1"># and a reset with zero score should not be included</span>
        <span class="c1"># in the path.  In this case, we&#39;re done.</span>
        <span class="k">if</span> <span class="n">bt_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Other bt_index values are okay for inclusion</span>
        <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># -2 indicates beginning of sequence,</span>
        <span class="c1"># so we can&#39;t backtrack any further</span>
        <span class="k">if</span> <span class="n">bt_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Otherwise, prepend this index and continue</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">bt_index</span><span class="p">][</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span>

    <span class="c1"># If there&#39;s no alignment path at all, eg an empty cross-similarity</span>
    <span class="c1"># matrix, return a properly shaped and typed array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">ptr</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Core Viterbi algorithm.</span>

<span class="sd">    This is intended for internal use only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_prob : np.ndarray [shape=(T, m)]</span>
<span class="sd">        ``log_prob[t, s]`` is the conditional log-likelihood</span>
<span class="sd">        ``log P[X = X(t) | State(t) = s]``</span>

<span class="sd">    log_trans : np.ndarray [shape=(m, m)]</span>
<span class="sd">        The log transition matrix</span>
<span class="sd">        ``log_trans[i, j] = log P[State(t+1) = j | State(t) = i]``</span>

<span class="sd">    log_p_init : np.ndarray [shape=(m,)]</span>
<span class="sd">        log of the initial state distribution</span>

<span class="sd">    state : np.ndarray [shape=(T,), dtype=int]</span>
<span class="sd">        Pre-allocated state index array</span>

<span class="sd">    value : np.ndarray [shape=(T, m)] float</span>
<span class="sd">        Pre-allocated value array</span>

<span class="sd">    ptr : np.ndarray [shape=(T, m), dtype=int]</span>
<span class="sd">        Pre-allocated pointer array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        All computations are performed in-place on ``state, value, ptr``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span> <span class="o">=</span> <span class="n">log_prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># factor in initial state distribution</span>
    <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_p_init</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">):</span>
        <span class="c1"># Want V[t, j] &lt;- p[t, j] * max_k V[t-1, k] * A[k, j]</span>
        <span class="c1">#    assume at time t-1 we were in state k</span>
        <span class="c1">#    transition k -&gt; j</span>

        <span class="c1"># Broadcast over rows:</span>
        <span class="c1">#    Tout[k, j] = V[t-1, k] * A[k, j]</span>
        <span class="c1">#    then take the max over columns</span>
        <span class="c1"># We&#39;ll do this in log-space for stability</span>

        <span class="n">trans_out</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_trans</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Unroll the max/argmax loop to enable numba support</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">trans_out</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="c1"># value[t, j] = log_prob[t, j] + np.max(trans_out[j])</span>
            <span class="n">value</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_prob</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">trans_out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>

    <span class="c1"># Now roll backward</span>

    <span class="c1"># Get the last state</span>
    <span class="n">state</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># Done.</span>


<div class="viewcode-block" id="viterbi"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi.html#librosa.sequence.viterbi">[docs]</a><span class="k">def</span> <span class="nf">viterbi</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Viterbi decoding from observation likelihoods.</span>

<span class="sd">    Given a sequence of observation likelihoods ``prob[s, t]``,</span>
<span class="sd">    indicating the conditional likelihood of seeing the observation</span>
<span class="sd">    at time ``t`` from state ``s``, and a transition matrix</span>
<span class="sd">    ``transition[i, j]`` which encodes the conditional probability of</span>
<span class="sd">    moving from state ``i`` to state ``j``, the Viterbi algorithm [#]_ computes</span>
<span class="sd">    the most likely sequence of states from the observations.</span>

<span class="sd">    .. [#] Viterbi, Andrew. &quot;Error bounds for convolutional codes and an</span>
<span class="sd">        asymptotically optimum decoding algorithm.&quot;</span>
<span class="sd">        IEEE transactions on Information Theory 13.2 (1967): 260-269.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_states, n_steps), non-negative]</span>
<span class="sd">        ``prob[s, t]`` is the probability of observation at time ``t``</span>
<span class="sd">        being generated by state ``s``.</span>

<span class="sd">    transition : np.ndarray [shape=(n_states, n_states), non-negative]</span>
<span class="sd">        ``transition[i, j]`` is the probability of a transition from i-&gt;j.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, a uniform distribution is assumed.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If ``True``, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either ``states`` or ``(states, logp)``:</span>

<span class="sd">    states : np.ndarray [shape=(n_steps,)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : scalar [float]</span>
<span class="sd">        If ``return_logp=True``, the log probability of ``states`` given</span>
<span class="sd">        the observations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi_discriminative : Viterbi decoding from state likelihoods</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example from https://en.wikipedia.org/wiki/Viterbi_algorithm#Example</span>

<span class="sd">    In this example, we have two states ``healthy`` and ``fever``, with</span>
<span class="sd">    initial probabilities 60% and 40%.</span>

<span class="sd">    We have three observation possibilities: ``normal``, ``cold``, and</span>
<span class="sd">    ``dizzy``, whose probabilities given each state are:</span>

<span class="sd">    ``healthy =&gt; {normal: 50%, cold: 40%, dizzy: 10%}`` and</span>
<span class="sd">    ``fever =&gt; {normal: 10%, cold: 30%, dizzy: 60%}``</span>

<span class="sd">    Finally, we have transition probabilities:</span>

<span class="sd">    ``healthy =&gt; healthy (70%)`` and</span>
<span class="sd">    ``fever =&gt; fever (60%)``.</span>

<span class="sd">    Over three days, we observe the sequence ``[normal, cold, dizzy]``,</span>
<span class="sd">    and wish to know the maximum likelihood assignment of states for the</span>
<span class="sd">    corresponding days, which we compute with the Viterbi algorithm below.</span>

<span class="sd">    &gt;&gt;&gt; p_init = np.array([0.6, 0.4])</span>
<span class="sd">    &gt;&gt;&gt; p_emit = np.array([[0.5, 0.4, 0.1],</span>
<span class="sd">    ...                    [0.1, 0.3, 0.6]])</span>
<span class="sd">    &gt;&gt;&gt; p_trans = np.array([[0.7, 0.3], [0.4, 0.6]])</span>
<span class="sd">    &gt;&gt;&gt; path, logp = librosa.sequence.viterbi(p_emit, p_trans, p_init,</span>
<span class="sd">    ...                                       return_logp=True)</span>
<span class="sd">    &gt;&gt;&gt; print(logp, path)</span>
<span class="sd">    -4.19173690823075 [0 0 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;transition.shape=</span><span class="si">{}</span><span class="s2">, must be &quot;</span>
            <span class="s2">&quot;(n_states, n_states)=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid transition matrix: must be non-negative &quot;</span>
            <span class="s2">&quot;and sum to 1 on each row.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Invalid probability values: must be between 0 and 1.&quot;</span><span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Compute log-likelihoods while avoiding log-underflow</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
    <span class="n">log_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transition</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">log_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_init</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">p_init</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid initial state distribution: &quot;</span> <span class="s2">&quot;p_init=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">log_p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_init</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="viterbi_discriminative"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi_discriminative.html#librosa.sequence.viterbi_discriminative">[docs]</a><span class="k">def</span> <span class="nf">viterbi_discriminative</span><span class="p">(</span>
    <span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Viterbi decoding from discriminative state predictions.</span>

<span class="sd">    Given a sequence of conditional state predictions ``prob[s, t]``,</span>
<span class="sd">    indicating the conditional likelihood of state ``s`` given the</span>
<span class="sd">    observation at time ``t``, and a transition matrix ``transition[i, j]``</span>
<span class="sd">    which encodes the conditional probability of moving from state ``i``</span>
<span class="sd">    to state ``j``, the Viterbi algorithm computes the most likely sequence</span>
<span class="sd">    of states from the observations.</span>

<span class="sd">    This implementation uses the standard Viterbi decoding algorithm</span>
<span class="sd">    for observation likelihood sequences, under the assumption that</span>
<span class="sd">    ``P[Obs(t) | State(t) = s]`` is proportional to</span>
<span class="sd">    ``P[State(t) = s | Obs(t)] / P[State(t) = s]``, where the denominator</span>
<span class="sd">    is the marginal probability of state ``s`` occurring as given by ``p_state``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_states, n_steps), non-negative]</span>
<span class="sd">        ``prob[s, t]`` is the probability of state ``s`` conditional on</span>
<span class="sd">        the observation at time ``t``.</span>
<span class="sd">        Must be non-negative and sum to 1 along each column.</span>

<span class="sd">    transition : np.ndarray [shape=(n_states, n_states), non-negative]</span>
<span class="sd">        ``transition[i, j]`` is the probability of a transition from i-&gt;j.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">    p_state : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: marginal probability distribution over states,</span>
<span class="sd">        must be non-negative and sum to 1.</span>
<span class="sd">        If not provided, a uniform distribution is assumed.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, it is assumed to be uniform.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If ``True``, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either ``states`` or ``(states, logp)``:</span>

<span class="sd">    states : np.ndarray [shape=(n_steps,)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : scalar [float]</span>
<span class="sd">        If ``return_logp=True``, the log probability of ``states`` given</span>
<span class="sd">        the observations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi : Viterbi decoding from observation likelihoods</span>
<span class="sd">    viterbi_binary: Viterbi decoding for multi-label, conditional state likelihoods</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This example constructs a simple, template-based discriminative chord estimator,</span>
<span class="sd">    using CENS chroma as input features.</span>

<span class="sd">    .. note:: this chord model is not accurate enough to use in practice. It is only</span>
<span class="sd">            intended to demonstrate how to use discriminative Viterbi decoding.</span>

<span class="sd">    &gt;&gt;&gt; # Create templates for major, minor, and no-chord qualities</span>
<span class="sd">    &gt;&gt;&gt; maj_template = np.array([1,0,0, 0,1,0, 0,1,0, 0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; min_template = np.array([1,0,0, 1,0,0, 0,1,0, 0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; N_template   = np.array([1,1,1, 1,1,1, 1,1,1, 1,1,1.]) / 4.</span>
<span class="sd">    &gt;&gt;&gt; # Generate the weighting matrix that maps chroma to labels</span>
<span class="sd">    &gt;&gt;&gt; weights = np.zeros((25, 12), dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; labels = [&#39;C:maj&#39;, &#39;C#:maj&#39;, &#39;D:maj&#39;, &#39;D#:maj&#39;, &#39;E:maj&#39;, &#39;F:maj&#39;,</span>
<span class="sd">    ...           &#39;F#:maj&#39;, &#39;G:maj&#39;, &#39;G#:maj&#39;, &#39;A:maj&#39;, &#39;A#:maj&#39;, &#39;B:maj&#39;,</span>
<span class="sd">    ...           &#39;C:min&#39;, &#39;C#:min&#39;, &#39;D:min&#39;, &#39;D#:min&#39;, &#39;E:min&#39;, &#39;F:min&#39;,</span>
<span class="sd">    ...           &#39;F#:min&#39;, &#39;G:min&#39;, &#39;G#:min&#39;, &#39;A:min&#39;, &#39;A#:min&#39;, &#39;B:min&#39;,</span>
<span class="sd">    ...           &#39;N&#39;]</span>
<span class="sd">    &gt;&gt;&gt; for c in range(12):</span>
<span class="sd">    ...     weights[c, :] = np.roll(maj_template, c) # c:maj</span>
<span class="sd">    ...     weights[c + 12, :] = np.roll(min_template, c)  # c:min</span>
<span class="sd">    &gt;&gt;&gt; weights[-1] = N_template  # the last row is the no-chord class</span>
<span class="sd">    &gt;&gt;&gt; # Make a self-loop transition matrix over 25 states</span>
<span class="sd">    &gt;&gt;&gt; trans = librosa.sequence.transition_loop(25, 0.9)</span>

<span class="sd">    &gt;&gt;&gt; # Load in audio and make features</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=30)</span>
<span class="sd">    &gt;&gt;&gt; # Suppress percussive elements</span>
<span class="sd">    &gt;&gt;&gt; y = librosa.effects.harmonic(y, margin=4)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Map chroma (observations) to class (state) likelihoods</span>
<span class="sd">    &gt;&gt;&gt; probs = np.exp(weights.dot(chroma))  # P[class | chroma] ~= exp(template&#39; chroma)</span>
<span class="sd">    &gt;&gt;&gt; probs /= probs.sum(axis=0, keepdims=True)  # probabilities must sum to 1 in each column</span>
<span class="sd">    &gt;&gt;&gt; # Compute independent frame-wise estimates</span>
<span class="sd">    &gt;&gt;&gt; chords_ind = np.argmax(probs, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; # And viterbi estimates</span>
<span class="sd">    &gt;&gt;&gt; chords_vit = librosa.sequence.viterbi_discriminative(probs, trans)</span>

<span class="sd">    &gt;&gt;&gt; # Plot the features and prediction map</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, x_axis=&#39;time&#39;, y_axis=&#39;chroma&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(weights, x_axis=&#39;chroma&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(yticks=np.arange(25) + 0.5, yticklabels=labels, ylabel=&#39;Chord&#39;)</span>

<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(probs, x_axis=&#39;time&#39;, cmap=&#39;gray&#39;, ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(chords_vit)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(times, chords_ind + 0.75, color=&#39;lime&#39;, alpha=0.5, marker=&#39;+&#39;,</span>
<span class="sd">    ...            s=15, label=&#39;Independent&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(times, chords_vit + 0.25, color=&#39;deeppink&#39;, alpha=0.5, marker=&#39;o&#39;,</span>
<span class="sd">    ...            s=15, label=&#39;Viterbi&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(yticks=0.5 + np.unique(chords_vit),</span>
<span class="sd">    ...        yticklabels=[labels[i] for i in np.unique(chords_vit)])</span>
<span class="sd">    &gt;&gt;&gt; ax.legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;transition.shape=</span><span class="si">{}</span><span class="s2">, must be &quot;</span>
            <span class="s2">&quot;(n_states, n_states)=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid transition matrix: must be non-negative &quot;</span>
            <span class="s2">&quot;and sum to 1 on each row.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid probability values: each column must &quot;</span>
            <span class="s2">&quot;sum to 1 and be non-negative&quot;</span>
        <span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Compute log-likelihoods while avoiding log-underflow</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>

    <span class="c1"># Compute marginal log probabilities while avoiding underflow</span>
    <span class="k">if</span> <span class="n">p_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_state</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">p_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Marginal distribution p_state must have shape (n_states,). &quot;</span>
            <span class="s2">&quot;Got p_state.shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_state</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid marginal state distribution: &quot;</span> <span class="s2">&quot;p_state=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">log_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transition</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">log_marginal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_state</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="c1"># By Bayes&#39; rule, P[X | Y] * P[Y] = P[Y | X] * P[X]</span>
    <span class="c1"># P[X] is constant for the sake of maximum likelihood inference</span>
    <span class="c1"># and P[Y] is given by the marginal distribution p_state.</span>
    <span class="c1">#</span>
    <span class="c1"># So we have P[X | y] \propto P[Y | x] / P[Y]</span>
    <span class="c1"># if X = observation and Y = states, this can be done in log space as</span>
    <span class="c1"># log P[X | y] \propto \log P[Y | x] - \log P[Y]</span>
    <span class="n">log_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_marginal</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_init</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">p_init</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid initial state distribution: &quot;</span> <span class="s2">&quot;p_init=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">log_p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_init</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="viterbi_binary"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi_binary.html#librosa.sequence.viterbi_binary">[docs]</a><span class="k">def</span> <span class="nf">viterbi_binary</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Viterbi decoding from binary (multi-label), discriminative state predictions.</span>

<span class="sd">    Given a sequence of conditional state predictions ``prob[s, t]``,</span>
<span class="sd">    indicating the conditional likelihood of state ``s`` being active</span>
<span class="sd">    conditional on observation at time ``t``, and a 2*2 transition matrix</span>
<span class="sd">    ``transition`` which encodes the conditional probability of moving from</span>
<span class="sd">    state ``s`` to state ``~s`` (not-``s``), the Viterbi algorithm computes the</span>
<span class="sd">    most likely sequence of states from the observations.</span>

<span class="sd">    This function differs from `viterbi_discriminative` in that it does not assume the</span>
<span class="sd">    states to be mutually exclusive.  `viterbi_binary` is implemented by</span>
<span class="sd">    transforming the multi-label decoding problem to a collection</span>
<span class="sd">    of binary Viterbi problems (one for each *state* or label).</span>

<span class="sd">    The output is a binary matrix ``states[s, t]`` indicating whether each</span>
<span class="sd">    state ``s`` is active at time ``t``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_steps,) or (n_states, n_steps)], non-negative</span>
<span class="sd">        ``prob[s, t]`` is the probability of state ``s`` being active</span>
<span class="sd">        conditional on the observation at time ``t``.</span>
<span class="sd">        Must be non-negative and less than 1.</span>

<span class="sd">        If ``prob`` is 1-dimensional, it is expanded to shape ``(1, n_steps)``.</span>

<span class="sd">    transition : np.ndarray [shape=(2, 2) or (n_states, 2, 2)], non-negative</span>
<span class="sd">        If 2-dimensional, the same transition matrix is applied to each sub-problem.</span>
<span class="sd">        ``transition[0, i]`` is the probability of the state going from inactive to ``i``,</span>
<span class="sd">        ``transition[1, i]`` is the probability of the state going from active to ``i``.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">        If 3-dimensional, ``transition[s]`` is interpreted as the 2x2 transition matrix</span>
<span class="sd">        for state label ``s``.</span>

<span class="sd">    p_state : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: marginal probability for each state (between [0,1]).</span>
<span class="sd">        If not provided, a uniform distribution (0.5 for each state)</span>
<span class="sd">        is assumed.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, it is assumed to be uniform.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If ``True``, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either ``states`` or ``(states, logp)``:</span>

<span class="sd">    states : np.ndarray [shape=(n_states, n_steps)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        If ``return_logp=True``, the log probability of each state activation</span>
<span class="sd">        sequence ``states``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi : Viterbi decoding from observation likelihoods</span>
<span class="sd">    viterbi_discriminative : Viterbi decoding for discriminative (mutually exclusive) state predictions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we have a sequence of binary state likelihoods that we want to de-noise</span>
<span class="sd">    under the assumption that state changes are relatively uncommon.  Positive predictions</span>
<span class="sd">    should only be retained if they persist for multiple steps, and any transient predictions</span>
<span class="sd">    should be considered as errors.  This use case arises frequently in problems such as</span>
<span class="sd">    instrument recognition, where state activations tend to be stable over time, but subject</span>
<span class="sd">    to abrupt changes (e.g., when an instrument joins the mix).</span>

<span class="sd">    We assume that the 0 state has a self-transition probability of 90%, and the 1 state</span>
<span class="sd">    has a self-transition probability of 70%.  We assume the marginal and initial</span>
<span class="sd">    probability of either state is 50%.</span>

<span class="sd">    &gt;&gt;&gt; trans = np.array([[0.9, 0.1], [0.3, 0.7]])</span>
<span class="sd">    &gt;&gt;&gt; prob = np.array([0.1, 0.7, 0.4, 0.3, 0.8, 0.9, 0.8, 0.2, 0.6, 0.3])</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.viterbi_binary(prob, trans, p_state=0.5, p_init=0.5)</span>
<span class="sd">    array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;transition.shape=</span><span class="si">{}</span><span class="s2">, must be (2, 2) or &quot;</span>
            <span class="s2">&quot;(n_states, 2, 2)=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid transition matrix: must be non-negative &quot;</span>
            <span class="s2">&quot;and sum to 1 on each row.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Invalid probability values: prob must be between [0, 1]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_state</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid marginal state distributions: p_state=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p_init</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_init</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid initial state distributions: p_init=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">logp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>

    <span class="n">prob_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">))</span>
    <span class="n">p_state_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p_init_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
        <span class="n">prob_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">prob_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">p_state_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">p_state_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">p_init_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_init</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">p_init_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_init</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="p">:],</span> <span class="n">logp</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">viterbi_discriminative</span><span class="p">(</span>
            <span class="n">prob_binary</span><span class="p">,</span>
            <span class="n">transition</span><span class="p">[</span><span class="n">state</span><span class="p">],</span>
            <span class="n">p_state</span><span class="o">=</span><span class="n">p_state_binary</span><span class="p">,</span>
            <span class="n">p_init</span><span class="o">=</span><span class="n">p_init_binary</span><span class="p">,</span>
            <span class="n">return_logp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">logp</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="transition_uniform"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_uniform.html#librosa.sequence.transition_uniform">[docs]</a><span class="k">def</span> <span class="nf">transition_uniform</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a uniform transition matrix over ``n_states``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 0</span>
<span class="sd">        The number of states</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        ``transition[i, j] = 1./n_states``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_uniform(3)</span>
<span class="sd">    array([[0.333, 0.333, 0.333],</span>
<span class="sd">           [0.333, 0.333, 0.333],</span>
<span class="sd">           [0.333, 0.333, 0.333]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_states=</span><span class="si">{}</span><span class="s2"> must be a positive integer&quot;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">transition</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_states</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_loop"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_loop.html#librosa.sequence.transition_loop">[docs]</a><span class="k">def</span> <span class="nf">transition_loop</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a self-loop transition matrix over ``n_states``.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - ``transition[i, i] = p`` for all ``i``</span>
<span class="sd">        - ``transition[i, j] = (1 - p) / (n_states - 1)`` for all ``j != i``</span>

<span class="sd">    This type of transition matrix is appropriate when states tend to be</span>
<span class="sd">    locally stable, and there is no additional structure between different</span>
<span class="sd">    states.  This is primarily useful for de-noising frame-wise predictions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    prob : float in [0, 1] or iterable, length=n_states</span>
<span class="sd">        If a scalar, this is the probability of a self-transition.</span>

<span class="sd">        If a vector of length ``n_states``, ``p[i]`` is the probability of self-transition in state ``i``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_loop(3, 0.5)</span>
<span class="sd">    array([[0.5 , 0.25, 0.25],</span>
<span class="sd">           [0.25, 0.5 , 0.25],</span>
<span class="sd">           [0.25, 0.25, 0.5 ]])</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_loop(3, [0.8, 0.5, 0.25])</span>
<span class="sd">    array([[0.8  , 0.1  , 0.1  ],</span>
<span class="sd">           [0.25 , 0.5  , 0.25 ],</span>
<span class="sd">           [0.375, 0.375, 0.25 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_states=</span><span class="si">{}</span><span class="s2"> must be a positive integer &gt; 1&quot;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># if it&#39;s a float, make it a vector</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;prob=</span><span class="si">{}</span><span class="s2"> must have length equal to n_states=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;prob=</span><span class="si">{}</span><span class="s2"> must have values in the range [0, 1]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob</span><span class="p">):</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">prob_i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_states</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_i</span>

    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_cycle"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_cycle.html#librosa.sequence.transition_cycle">[docs]</a><span class="k">def</span> <span class="nf">transition_cycle</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a cyclic transition matrix over ``n_states``.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - ``transition[i, i] = p``</span>
<span class="sd">        - ``transition[i, i + 1] = (1 - p)``</span>

<span class="sd">    This type of transition matrix is appropriate for state spaces</span>
<span class="sd">    with cyclical structure, such as metrical position within a bar.</span>
<span class="sd">    For example, a song in 4/4 time has state transitions of the form</span>

<span class="sd">        1-&gt;{1, 2}, 2-&gt;{2, 3}, 3-&gt;{3, 4}, 4-&gt;{4, 1}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    prob : float in [0, 1] or iterable, length=n_states</span>
<span class="sd">        If a scalar, this is the probability of a self-transition.</span>

<span class="sd">        If a vector of length ``n_states``, ``p[i]`` is the probability of</span>
<span class="sd">        self-transition in state ``i``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_cycle(4, 0.9)</span>
<span class="sd">    array([[0.9, 0.1, 0. , 0. ],</span>
<span class="sd">           [0. , 0.9, 0.1, 0. ],</span>
<span class="sd">           [0. , 0. , 0.9, 0.1],</span>
<span class="sd">           [0.1, 0. , 0. , 0.9]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_states=</span><span class="si">{}</span><span class="s2"> must be a positive integer &gt; 1&quot;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># if it&#39;s a float, make it a vector</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;prob=</span><span class="si">{}</span><span class="s2"> must have length equal to n_states=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;prob=</span><span class="si">{}</span><span class="s2"> must have values in the range [0, 1]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob</span><span class="p">):</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">prob_i</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_i</span>

    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_local"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_local.html#librosa.sequence.transition_local">[docs]</a><span class="k">def</span> <span class="nf">transition_local</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a localized transition matrix.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - ``transition[i, j] = 0`` if ``|i - j| &gt; width``</span>
<span class="sd">        - ``transition[i, i]`` is maximal</span>
<span class="sd">        - ``transition[i, i - width//2 : i + width//2]`` has shape ``window``</span>

<span class="sd">    This type of transition matrix is appropriate for state spaces</span>
<span class="sd">    that discretely approximate continuous variables, such as in fundamental</span>
<span class="sd">    frequency estimation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    width : int &gt;= 1 or iterable</span>
<span class="sd">        The maximum number of states to treat as &quot;local&quot;.</span>
<span class="sd">        If iterable, it should have length equal to ``n_states``,</span>
<span class="sd">        and specify the width independently for each state.</span>

<span class="sd">    window : str, callable, or window specification</span>
<span class="sd">        The window function to determine the shape of the &quot;local&quot; distribution.</span>

<span class="sd">        Any window specification supported by `filters.get_window` will work here.</span>

<span class="sd">        .. note:: Certain windows (e.g., &#39;hann&#39;) are identically 0 at the boundaries,</span>
<span class="sd">            so and effectively have ``width-2`` non-zero values.  You may have to expand</span>
<span class="sd">            ``width`` to get the desired behavior.</span>


<span class="sd">    wrap : bool</span>
<span class="sd">        If ``True``, then state locality ``|i - j|`` is computed modulo ``n_states``.</span>
<span class="sd">        If ``False`` (default), then locality is absolute.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.get_window</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Triangular distributions with and without wrapping</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, 3, window=&#39;triangle&#39;, wrap=False)</span>
<span class="sd">    array([[0.667, 0.333, 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.25 , 0.5  , 0.25 , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.25 , 0.5  , 0.25 , 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.25 , 0.5  , 0.25 ],</span>
<span class="sd">           [0.   , 0.   , 0.   , 0.333, 0.667]])</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, 3, window=&#39;triangle&#39;, wrap=True)</span>
<span class="sd">    array([[0.5 , 0.25, 0.  , 0.  , 0.25],</span>
<span class="sd">           [0.25, 0.5 , 0.25, 0.  , 0.  ],</span>
<span class="sd">           [0.  , 0.25, 0.5 , 0.25, 0.  ],</span>
<span class="sd">           [0.  , 0.  , 0.25, 0.5 , 0.25],</span>
<span class="sd">           [0.25, 0.  , 0.  , 0.25, 0.5 ]])</span>

<span class="sd">    Uniform local distributions with variable widths and no wrapping</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, [1, 2, 3, 3, 1], window=&#39;ones&#39;, wrap=False)</span>
<span class="sd">    array([[1.   , 0.   , 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.5  , 0.5  , 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.333, 0.333, 0.333, 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.333, 0.333, 0.333],</span>
<span class="sd">           [0.   , 0.   , 0.   , 0.   , 1.   ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_states=</span><span class="si">{}</span><span class="s2"> must be a positive integer &gt; 1&quot;</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">width</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;width=</span><span class="si">{}</span><span class="s2"> must have length equal to n_states=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">width</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;width=</span><span class="si">{}</span><span class="s2"> must be at least 1&quot;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Fill in the widths.  This is inefficient, but simple</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">width_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">trans_row</span> <span class="o">=</span> <span class="n">pad_center</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">width_i</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="n">trans_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">trans_row</span><span class="p">,</span> <span class="n">n_states</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="c1"># Knock out the off-diagonal-band elements</span>
            <span class="n">trans_row</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">width_i</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">trans_row</span><span class="p">[:</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">width_i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_row</span>

    <span class="c1"># Row-normalize</span>
    <span class="n">transition</span> <span class="o">/=</span> <span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transition</span></div>
</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.8.1
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Releases</dt>
      <dd><a href="../../../0.7.2/index.html">0.7.2</a></dd>
      <dd><a href="sequence.html">0.8.1</a></dd>
      <dd><a href="../../../0.9.0/index.html">0.9.0</a></dd>
      <dd><a href="../../../0.9.1/index.html">0.9.1</a></dd>
    </dl>
    <dl>
      <dt>Development versions</dt>
      <dd><a href="../../../main/index.html">main</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>