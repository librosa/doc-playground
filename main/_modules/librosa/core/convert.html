<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.core.convert &mdash; librosa 0.9.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html">
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../multichannel.html">Multi-channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>librosa.core.convert</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             

<div class="admonition danger">
    <p class="admonition-title"> Caution </p>
  <p>
    
        You're reading the documentation for a development version.
        For the latest released version, please have a look at <a href="../../../../0.9.1/index.html">0.9.1</a>.
    
  </p>
</div>


  <h1>Source code for librosa.core.convert</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Unit conversion utilities&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">notation</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">..util.decorators</span> <span class="kn">import</span> <span class="n">deprecate_positional_args</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;frames_to_samples&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frames_to_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;samples_to_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;samples_to_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_to_samples&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_to_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;blocks_to_samples&quot;</span><span class="p">,</span>
    <span class="s2">&quot;blocks_to_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;blocks_to_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;note_to_hz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;note_to_midi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midi_to_hz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midi_to_note&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_note&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_midi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_mel&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_octs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mel_to_hz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;octs_to_hz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;A4_to_tuning&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tuning_to_A4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fft_frequencies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cqt_frequencies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mel_frequencies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tempo_frequencies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fourier_tempo_frequencies&quot;</span><span class="p">,</span>
    <span class="s2">&quot;A_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;B_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;C_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;D_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Z_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frequency_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;multi_frequency_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;samples_like&quot;</span><span class="p">,</span>
    <span class="s2">&quot;times_like&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midi_to_svara_h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;midi_to_svara_c&quot;</span><span class="p">,</span>
    <span class="s2">&quot;note_to_svara_h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;note_to_svara_c&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_svara_h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hz_to_svara_c&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="frames_to_samples"><a class="viewcode-back" href="../../../generated/librosa.frames_to_samples.html#librosa.frames_to_samples">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">frames_to_samples</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts frame indices to audio sample indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frames : number or np.ndarray [shape=(n,)]</span>
<span class="sd">        frame index or vector of frame indices</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>
<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``n_fft // 2``</span>
<span class="sd">        to counteract windowing effects when using a non-centered STFT.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : number or np.ndarray</span>
<span class="sd">        time (in samples) of each given frame number::</span>

<span class="sd">            times[i] = frames[i] * hop_length</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    frames_to_time : convert frame indices to time values</span>
<span class="sd">    samples_to_frames : convert sample indices to frame indices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;choice&#39;))</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; beat_samples = librosa.frames_to_samples(beats)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">*</span> <span class="n">hop_length</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="samples_to_frames"><a class="viewcode-back" href="../../../generated/librosa.samples_to_frames.html#librosa.samples_to_frames">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">samples_to_frames</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts sample indices into STFT frames.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Get the frame numbers for every 256 samples</span>
<span class="sd">    &gt;&gt;&gt; librosa.samples_to_frames(np.arange(0, 22050, 256))</span>
<span class="sd">    array([ 0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,</span>
<span class="sd">            7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 13, 13,</span>
<span class="sd">           14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20,</span>
<span class="sd">           21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27,</span>
<span class="sd">           28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34,</span>
<span class="sd">           35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41,</span>
<span class="sd">           42, 42, 43])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : int or np.ndarray [shape=(n,)]</span>
<span class="sd">        sample index or vector of sample indices</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>

<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``- n_fft // 2``</span>
<span class="sd">        to counteract windowing effects in STFT.</span>

<span class="sd">        .. note:: This may result in negative frame indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frames : int or np.ndarray [shape=(n,), dtype=int]</span>
<span class="sd">        Frame numbers corresponding to the given times::</span>

<span class="sd">            frames[i] = floor( samples[i] / hop_length )</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    samples_to_time : convert sample indices to time values</span>
<span class="sd">    frames_to_samples : convert frame indices to sample indices</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">samples</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">//</span> <span class="n">hop_length</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="frames_to_time"><a class="viewcode-back" href="../../../generated/librosa.frames_to_time.html#librosa.frames_to_time">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">frames_to_time</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts frame counts to time (seconds).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frames : np.ndarray [shape=(n,)]</span>
<span class="sd">        frame index or vector of frame indices</span>
<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>
<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``n_fft // 2``</span>
<span class="sd">        to counteract windowing effects when using a non-centered STFT.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=(n,)]</span>
<span class="sd">        time (in seconds) of each given frame number::</span>

<span class="sd">            times[i] = frames[i] * hop_length / sr</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    time_to_frames : convert time values to frame indices</span>
<span class="sd">    frames_to_samples : convert frame indices to sample indices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;choice&#39;))</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; beat_times = librosa.frames_to_time(beats, sr=sr)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">frames_to_samples</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">samples_to_time</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span></div>


<div class="viewcode-block" id="time_to_frames"><a class="viewcode-back" href="../../../generated/librosa.time_to_frames.html#librosa.time_to_frames">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">time_to_frames</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts time stamps into STFT frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : np.ndarray [shape=(n,)]</span>
<span class="sd">        time (in seconds) or vector of time values</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>

<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``- n_fft // 2``</span>
<span class="sd">        to counteract windowing effects in STFT.</span>

<span class="sd">        .. note:: This may result in negative frame indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frames : np.ndarray [shape=(n,), dtype=int]</span>
<span class="sd">        Frame numbers corresponding to the given times::</span>

<span class="sd">            frames[i] = floor( times[i] * sr / hop_length )</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    frames_to_time : convert frame indices to time values</span>
<span class="sd">    time_to_samples : convert time values to sample indices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the frame numbers for every 100ms</span>

<span class="sd">    &gt;&gt;&gt; librosa.time_to_frames(np.arange(0, 1, 0.1),</span>
<span class="sd">    ...                         sr=22050, hop_length=512)</span>
<span class="sd">    array([ 0,  4,  8, 12, 17, 21, 25, 30, 34, 38])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">time_to_samples</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">samples_to_frames</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span></div>


<div class="viewcode-block" id="time_to_samples"><a class="viewcode-back" href="../../../generated/librosa.time_to_samples.html#librosa.time_to_samples">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">time_to_samples</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert timestamps (in seconds) to sample indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : number or np.ndarray</span>
<span class="sd">        Time value or array of time values (in seconds)</span>
<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        Sampling rate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : int or np.ndarray [shape=times.shape, dtype=int]</span>
<span class="sd">        Sample indices corresponding to values in ``times``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    time_to_frames : convert time values to frame indices</span>
<span class="sd">    samples_to_time : convert sample indices to time values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.time_to_samples(np.arange(0, 1, 0.1), sr=22050)</span>
<span class="sd">    array([    0,  2205,  4410,  6615,  8820, 11025, 13230, 15435,</span>
<span class="sd">           17640, 19845])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">*</span> <span class="n">sr</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="samples_to_time"><a class="viewcode-back" href="../../../generated/librosa.samples_to_time.html#librosa.samples_to_time">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">samples_to_time</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert sample indices to time (in seconds).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : np.ndarray</span>
<span class="sd">        Sample index or array of sample indices</span>
<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        Sampling rate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=samples.shape]</span>
<span class="sd">        Time values corresponding to ``samples`` (in seconds)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    samples_to_frames : convert sample indices to frame indices</span>
<span class="sd">    time_to_samples : convert time values to sample indices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get timestamps corresponding to every 512 samples</span>

<span class="sd">    &gt;&gt;&gt; librosa.samples_to_time(np.arange(0, 22050, 512))</span>
<span class="sd">    array([ 0.   ,  0.023,  0.046,  0.07 ,  0.093,  0.116,  0.139,</span>
<span class="sd">            0.163,  0.186,  0.209,  0.232,  0.255,  0.279,  0.302,</span>
<span class="sd">            0.325,  0.348,  0.372,  0.395,  0.418,  0.441,  0.464,</span>
<span class="sd">            0.488,  0.511,  0.534,  0.557,  0.58 ,  0.604,  0.627,</span>
<span class="sd">            0.65 ,  0.673,  0.697,  0.72 ,  0.743,  0.766,  0.789,</span>
<span class="sd">            0.813,  0.836,  0.859,  0.882,  0.906,  0.929,  0.952,</span>
<span class="sd">            0.975,  0.998])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span></div>


<div class="viewcode-block" id="blocks_to_frames"><a class="viewcode-back" href="../../../generated/librosa.blocks_to_frames.html#librosa.blocks_to_frames">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">blocks_to_frames</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">block_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert block indices to frame indices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    blocks : np.ndarray</span>
<span class="sd">        Block index or array of block indices</span>
<span class="sd">    block_length : int &gt; 0</span>
<span class="sd">        The number of frames per block</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frames : np.ndarray [shape=samples.shape, dtype=int]</span>
<span class="sd">        The index or indices of frames corresponding to the beginning</span>
<span class="sd">        of each provided block.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blocks_to_samples</span>
<span class="sd">    blocks_to_time</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get frame indices for each block in a stream</span>

<span class="sd">    &gt;&gt;&gt; filename = librosa.ex(&#39;brahms&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sr = librosa.get_samplerate(filename)</span>
<span class="sd">    &gt;&gt;&gt; stream = librosa.stream(filename, block_length=16,</span>
<span class="sd">    ...                         frame_length=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; for n, y in enumerate(stream):</span>
<span class="sd">    ...     n_frame = librosa.blocks_to_frames(n, block_length=16)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">block_length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span></div>


<div class="viewcode-block" id="blocks_to_samples"><a class="viewcode-back" href="../../../generated/librosa.blocks_to_samples.html#librosa.blocks_to_samples">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">blocks_to_samples</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">block_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert block indices to sample indices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    blocks : np.ndarray</span>
<span class="sd">        Block index or array of block indices</span>
<span class="sd">    block_length : int &gt; 0</span>
<span class="sd">        The number of frames per block</span>
<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        The number of samples to advance between frames</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : np.ndarray [shape=samples.shape, dtype=int]</span>
<span class="sd">        The index or indices of samples corresponding to the beginning</span>
<span class="sd">        of each provided block.</span>

<span class="sd">        Note that these correspond to the *first* sample index in</span>
<span class="sd">        each block, and are not frame-centered.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blocks_to_frames</span>
<span class="sd">    blocks_to_time</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get sample indices for each block in a stream</span>

<span class="sd">    &gt;&gt;&gt; filename = librosa.ex(&#39;brahms&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sr = librosa.get_samplerate(filename)</span>
<span class="sd">    &gt;&gt;&gt; stream = librosa.stream(filename, block_length=16,</span>
<span class="sd">    ...                         frame_length=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; for n, y in enumerate(stream):</span>
<span class="sd">    ...     n_sample = librosa.blocks_to_samples(n, block_length=16,</span>
<span class="sd">    ...                                          hop_length=512)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">blocks_to_frames</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="n">block_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frames_to_samples</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="blocks_to_time"><a class="viewcode-back" href="../../../generated/librosa.blocks_to_time.html#librosa.blocks_to_time">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">blocks_to_time</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">block_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert block indices to time (in seconds)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    blocks : np.ndarray</span>
<span class="sd">        Block index or array of block indices</span>
<span class="sd">    block_length : int &gt; 0</span>
<span class="sd">        The number of frames per block</span>
<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        The number of samples to advance between frames</span>
<span class="sd">    sr : int &gt; 0</span>
<span class="sd">        The sampling rate (samples per second)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=samples.shape]</span>
<span class="sd">        The time index or indices (in seconds) corresponding to the</span>
<span class="sd">        beginning of each provided block.</span>

<span class="sd">        Note that these correspond to the time of the *first* sample</span>
<span class="sd">        in each block, and are not frame-centered.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blocks_to_frames</span>
<span class="sd">    blocks_to_samples</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get time indices for each block in a stream</span>

<span class="sd">    &gt;&gt;&gt; filename = librosa.ex(&#39;brahms&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sr = librosa.get_samplerate(filename)</span>
<span class="sd">    &gt;&gt;&gt; stream = librosa.stream(filename, block_length=16,</span>
<span class="sd">    ...                         frame_length=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; for n, y in enumerate(stream):</span>
<span class="sd">    ...     n_time = librosa.blocks_to_time(n, block_length=16,</span>
<span class="sd">    ...                                     hop_length=512, sr=sr)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">blocks_to_samples</span><span class="p">(</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="n">block_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">samples_to_time</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span></div>


<div class="viewcode-block" id="note_to_hz"><a class="viewcode-back" href="../../../generated/librosa.note_to_hz.html#librosa.note_to_hz">[docs]</a><span class="k">def</span> <span class="nf">note_to_hz</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert one or more note names to frequency (Hz)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Get the frequency of a note</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_hz(&#39;C&#39;)</span>
<span class="sd">    array([ 16.352])</span>
<span class="sd">    &gt;&gt;&gt; # Or multiple notes</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_hz([&#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;])</span>
<span class="sd">    array([ 220.,  440.,  880.])</span>
<span class="sd">    &gt;&gt;&gt; # Or notes with tuning deviations</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_hz(&#39;C2-32&#39;, round_midi=False)</span>
<span class="sd">    array([ 64.209])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    note : str or iterable of str</span>
<span class="sd">        One or more note names to convert</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Additional parameters to `note_to_midi`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequencies : number or np.ndarray [shape=(len(note),)]</span>
<span class="sd">        Array of frequencies (in Hz) corresponding to ``note``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_hz</span>
<span class="sd">    note_to_midi</span>
<span class="sd">    hz_to_note</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">midi_to_hz</span><span class="p">(</span><span class="n">note_to_midi</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="note_to_midi"><a class="viewcode-back" href="../../../generated/librosa.note_to_midi.html#librosa.note_to_midi">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">note_to_midi</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">round_midi</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert one or more spelled notes to MIDI number(s).</span>

<span class="sd">    Notes may be spelled out with optional accidentals or octave numbers.</span>

<span class="sd">    The leading note name is case-insensitive.</span>

<span class="sd">    Sharps are indicated with ``#``, flats may be indicated with ``!`` or ``b``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    note : str or iterable of str</span>
<span class="sd">        One or more note names.</span>
<span class="sd">    round_midi : bool</span>
<span class="sd">        - If ``True``, allow for fractional midi notes</span>
<span class="sd">        - Otherwise, round cent deviations to the nearest note</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    midi : float or np.array</span>
<span class="sd">        Midi note numbers corresponding to inputs.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If the input is not in valid note format</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_note</span>
<span class="sd">    note_to_hz</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;C&#39;)</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;C#3&#39;)</span>
<span class="sd">    49</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;C♯3&#39;)  # Using Unicode sharp</span>
<span class="sd">    49</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;C♭3&#39;)  # Using Unicode flat</span>
<span class="sd">    47</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;f4&#39;)</span>
<span class="sd">    65</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;Bb-1&#39;)</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;A!8&#39;)</span>
<span class="sd">    116</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;G𝄪6&#39;)  # Double-sharp</span>
<span class="sd">    93</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;B𝄫6&#39;)  # Double-flat</span>
<span class="sd">    93</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi(&#39;C♭𝄫5&#39;)  # Triple-flats also work</span>
<span class="sd">    69</span>
<span class="sd">    &gt;&gt;&gt; # Lists of notes also work</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_midi([&#39;C&#39;, &#39;E&#39;, &#39;G&#39;])</span>
<span class="sd">    array([12, 16, 19])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">note_to_midi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">round_midi</span><span class="o">=</span><span class="n">round_midi</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">note</span><span class="p">])</span>

    <span class="n">pitch_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">11</span><span class="p">}</span>
    <span class="n">acc_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;#&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;!&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;♯&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;𝄪&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;♭&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;𝄫&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;♮&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;^(?P&lt;note&gt;[A-Ga-g])&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;(?P&lt;accidental&gt;[#♯𝄪b!♭𝄫♮]*)&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;(?P&lt;octave&gt;[+-]?\d+)?&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;(?P&lt;cents&gt;[+-]\d+)?$&quot;</span><span class="p">,</span>
        <span class="n">note</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Improper note format: </span><span class="si">{:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">note</span><span class="p">))</span>

    <span class="n">pitch</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;note&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">acc_map</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;accidental&quot;</span><span class="p">)])</span>
    <span class="n">octave</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;octave&quot;</span><span class="p">)</span>
    <span class="n">cents</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;cents&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">octave</span><span class="p">:</span>
        <span class="n">octave</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">octave</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">octave</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cents</span><span class="p">:</span>
        <span class="n">cents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cents</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cents</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-2</span>

    <span class="n">note_value</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="p">(</span><span class="n">octave</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">pitch_map</span><span class="p">[</span><span class="n">pitch</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">cents</span>

    <span class="k">if</span> <span class="n">round_midi</span><span class="p">:</span>
        <span class="n">note_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">note_value</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">note_value</span></div>


<div class="viewcode-block" id="midi_to_note"><a class="viewcode-back" href="../../../generated/librosa.midi_to_note.html#librosa.midi_to_note">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">midi_to_note</span><span class="p">(</span><span class="n">midi</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;C:maj&quot;</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert one or more MIDI numbers to note strings.</span>

<span class="sd">    MIDI numbers will be rounded to the nearest integer.</span>

<span class="sd">    Notes will be of the format &#39;C0&#39;, &#39;C♯0&#39;, &#39;D0&#39;, ...</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(0)</span>
<span class="sd">    &#39;C-1&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(37)</span>
<span class="sd">    &#39;C♯2&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(37, unicode=False)</span>
<span class="sd">    &#39;C#2&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(-2)</span>
<span class="sd">    &#39;A♯-2&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(104.7)</span>
<span class="sd">    &#39;A7&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(104.7, cents=True)</span>
<span class="sd">    &#39;A7-30&#39;</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(list(range(12, 24)))</span>
<span class="sd">    [&#39;C0&#39;, &#39;C♯0&#39;, &#39;D0&#39;, &#39;D♯0&#39;, &#39;E0&#39;, &#39;F0&#39;, &#39;F♯0&#39;, &#39;G0&#39;, &#39;G♯0&#39;, &#39;A0&#39;, &#39;A♯0&#39;, &#39;B0&#39;]</span>

<span class="sd">    Use a key signature to resolve enharmonic equivalences</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_note(range(12, 24), key=&#39;F:min&#39;)</span>
<span class="sd">    [&#39;C0&#39;, &#39;D♭0&#39;, &#39;D0&#39;, &#39;E♭0&#39;, &#39;E0&#39;, &#39;F0&#39;, &#39;G♭0&#39;, &#39;G0&#39;, &#39;A♭0&#39;, &#39;A0&#39;, &#39;B♭0&#39;, &#39;B0&#39;]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    midi : int or iterable of int</span>
<span class="sd">        Midi numbers to convert.</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If True, include the octave number</span>

<span class="sd">    cents : bool</span>
<span class="sd">        If true, cent markers will be appended for fractional notes.</span>
<span class="sd">        Eg, ``midi_to_note(69.3, cents=True) == &#39;A4+03&#39;``</span>

<span class="sd">    key : str</span>
<span class="sd">        A key signature to use when resolving enharmonic equivalences.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If ``True`` (default), accidentals will use Unicode notation: ♭ or ♯</span>

<span class="sd">        If ``False``, accidentals will use ASCII-compatible notation: b or #</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    notes : str or iterable of str</span>
<span class="sd">        Strings describing each midi note.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if ``cents`` is True and ``octave`` is False</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_hz</span>
<span class="sd">    note_to_midi</span>
<span class="sd">    hz_to_note</span>
<span class="sd">    key_to_notes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cents</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">octave</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Cannot encode cents without octave information.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">midi</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">midi_to_note</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">cents</span><span class="o">=</span><span class="n">cents</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">midi</span>
        <span class="p">]</span>

    <span class="n">note_map</span> <span class="o">=</span> <span class="n">notation</span><span class="o">.</span><span class="n">key_to_notes</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span><span class="p">)</span>

    <span class="n">note_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">midi</span><span class="p">))</span>
    <span class="n">note_cents</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">midi</span> <span class="o">-</span> <span class="n">note_num</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">note</span> <span class="o">=</span> <span class="n">note_map</span><span class="p">[</span><span class="n">note_num</span> <span class="o">%</span> <span class="mi">12</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">octave</span><span class="p">:</span>
        <span class="n">note</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}{:0d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">note_num</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cents</span><span class="p">:</span>
        <span class="n">note</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:s}{:+02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">note_cents</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">note</span></div>


<div class="viewcode-block" id="midi_to_hz"><a class="viewcode-back" href="../../../generated/librosa.midi_to_hz.html#librosa.midi_to_hz">[docs]</a><span class="k">def</span> <span class="nf">midi_to_hz</span><span class="p">(</span><span class="n">notes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the frequency (Hz) of MIDI note(s)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.midi_to_hz(36)</span>
<span class="sd">    65.406</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_hz(np.arange(36, 48))</span>
<span class="sd">    array([  65.406,   69.296,   73.416,   77.782,   82.407,</span>
<span class="sd">             87.307,   92.499,   97.999,  103.826,  110.   ,</span>
<span class="sd">            116.541,  123.471])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    notes : int or np.ndarray [shape=(n,), dtype=int]</span>
<span class="sd">        midi number(s) of the note(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequency : number or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        frequency (frequencies) of ``notes`` in Hz</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_midi</span>
<span class="sd">    note_to_hz</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">notes</span><span class="p">)</span> <span class="o">-</span> <span class="mf">69.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">12.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="hz_to_midi"><a class="viewcode-back" href="../../../generated/librosa.hz_to_midi.html#librosa.hz_to_midi">[docs]</a><span class="k">def</span> <span class="nf">hz_to_midi</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get MIDI note number(s) for given frequencies</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_midi(60)</span>
<span class="sd">    34.506</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_midi([110, 220, 440])</span>
<span class="sd">    array([ 45.,  57.,  69.])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : float or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        frequencies to convert</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    note_nums : number or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        MIDI notes to ``frequencies``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_hz</span>
<span class="sd">    note_to_midi</span>
<span class="sd">    hz_to_note</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mi">12</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">440.0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">69</span></div>


<div class="viewcode-block" id="hz_to_note"><a class="viewcode-back" href="../../../generated/librosa.hz_to_note.html#librosa.hz_to_note">[docs]</a><span class="k">def</span> <span class="nf">hz_to_note</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert one or more frequencies (in Hz) to the nearest note names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : float or iterable of float</span>
<span class="sd">        Input frequencies, specified in Hz</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Arguments passed through to `midi_to_note`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    notes : list of str</span>
<span class="sd">        ``notes[i]`` is the closest note name to ``frequency[i]``</span>
<span class="sd">        (or ``frequency`` if the input is scalar)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_midi</span>
<span class="sd">    midi_to_note</span>
<span class="sd">    note_to_hz</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get a single note name for a frequency</span>

<span class="sd">    &gt;&gt;&gt; librosa.hz_to_note(440.0)</span>
<span class="sd">    [&#39;A5&#39;]</span>

<span class="sd">    Get multiple notes with cent deviation</span>

<span class="sd">    &gt;&gt;&gt; librosa.hz_to_note([32, 64], cents=True)</span>
<span class="sd">    [&#39;C1-38&#39;, &#39;C2-38&#39;]</span>

<span class="sd">    Get multiple notes, but suppress octave labels</span>

<span class="sd">    &gt;&gt;&gt; librosa.hz_to_note(440.0 * (2.0 ** np.linspace(0, 1, 12)),</span>
<span class="sd">    ...                    octave=False)</span>
<span class="sd">    [&#39;A&#39;, &#39;A#&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C#&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;F#&#39;, &#39;G&#39;, &#39;G#&#39;, &#39;A&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">midi_to_note</span><span class="p">(</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="n">frequencies</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="hz_to_mel"><a class="viewcode-back" href="../../../generated/librosa.hz_to_mel.html#librosa.hz_to_mel">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">hz_to_mel</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Hz to Mels</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_mel(60)</span>
<span class="sd">    0.9</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_mel([110, 220, 440])</span>
<span class="sd">    array([ 1.65,  3.3 ,  6.6 ])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : number or np.ndarray [shape=(n,)] , float</span>
<span class="sd">        scalar or array of frequencies</span>
<span class="sd">    htk : bool</span>
<span class="sd">        use HTK formula instead of Slaney</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mels : number or np.ndarray [shape=(n,)]</span>
<span class="sd">        input frequencies in Mels</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mel_to_hz</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">htk</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">2595.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">frequencies</span> <span class="o">/</span> <span class="mf">700.0</span><span class="p">)</span>

    <span class="c1"># Fill in the linear part</span>
    <span class="n">f_min</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f_sp</span> <span class="o">=</span> <span class="mf">200.0</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="n">mels</span> <span class="o">=</span> <span class="p">(</span><span class="n">frequencies</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>

    <span class="c1"># Fill in the log-scale part</span>

    <span class="n">min_log_hz</span> <span class="o">=</span> <span class="mf">1000.0</span>  <span class="c1"># beginning of log region (Hz)</span>
    <span class="n">min_log_mel</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_log_hz</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>  <span class="c1"># same (Mels)</span>
    <span class="n">logstep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">6.4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">27.0</span>  <span class="c1"># step size for log region</span>

    <span class="k">if</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c1"># If we have array data, vectorize</span>
        <span class="n">log_t</span> <span class="o">=</span> <span class="n">frequencies</span> <span class="o">&gt;=</span> <span class="n">min_log_hz</span>
        <span class="n">mels</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_log_mel</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">frequencies</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">/</span> <span class="n">min_log_hz</span><span class="p">)</span> <span class="o">/</span> <span class="n">logstep</span>
    <span class="k">elif</span> <span class="n">frequencies</span> <span class="o">&gt;=</span> <span class="n">min_log_hz</span><span class="p">:</span>
        <span class="c1"># If we have scalar data, heck directly</span>
        <span class="n">mels</span> <span class="o">=</span> <span class="n">min_log_mel</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="n">min_log_hz</span><span class="p">)</span> <span class="o">/</span> <span class="n">logstep</span>

    <span class="k">return</span> <span class="n">mels</span></div>


<div class="viewcode-block" id="mel_to_hz"><a class="viewcode-back" href="../../../generated/librosa.mel_to_hz.html#librosa.mel_to_hz">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">mel_to_hz</span><span class="p">(</span><span class="n">mels</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert mel bin numbers to frequencies</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.mel_to_hz(3)</span>
<span class="sd">    200.</span>

<span class="sd">    &gt;&gt;&gt; librosa.mel_to_hz([1,2,3,4,5])</span>
<span class="sd">    array([  66.667,  133.333,  200.   ,  266.667,  333.333])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mels : np.ndarray [shape=(n,)], float</span>
<span class="sd">        mel bins to convert</span>
<span class="sd">    htk : bool</span>
<span class="sd">        use HTK formula instead of Slaney</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequencies : np.ndarray [shape=(n,)]</span>
<span class="sd">        input mels in Hz</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_mel</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">mels</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">htk</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">700.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">10.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">mels</span> <span class="o">/</span> <span class="mf">2595.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Fill in the linear scale</span>
    <span class="n">f_min</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f_sp</span> <span class="o">=</span> <span class="mf">200.0</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">f_min</span> <span class="o">+</span> <span class="n">f_sp</span> <span class="o">*</span> <span class="n">mels</span>

    <span class="c1"># And now the nonlinear scale</span>
    <span class="n">min_log_hz</span> <span class="o">=</span> <span class="mf">1000.0</span>  <span class="c1"># beginning of log region (Hz)</span>
    <span class="n">min_log_mel</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_log_hz</span> <span class="o">-</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_sp</span>  <span class="c1"># same (Mels)</span>
    <span class="n">logstep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">6.4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">27.0</span>  <span class="c1"># step size for log region</span>

    <span class="k">if</span> <span class="n">mels</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c1"># If we have vector data, vectorize</span>
        <span class="n">log_t</span> <span class="o">=</span> <span class="n">mels</span> <span class="o">&gt;=</span> <span class="n">min_log_mel</span>
        <span class="n">freqs</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_log_hz</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logstep</span> <span class="o">*</span> <span class="p">(</span><span class="n">mels</span><span class="p">[</span><span class="n">log_t</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_log_mel</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mels</span> <span class="o">&gt;=</span> <span class="n">min_log_mel</span><span class="p">:</span>
        <span class="c1"># If we have scalar data, check directly</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">min_log_hz</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logstep</span> <span class="o">*</span> <span class="p">(</span><span class="n">mels</span> <span class="o">-</span> <span class="n">min_log_mel</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="hz_to_octs"><a class="viewcode-back" href="../../../generated/librosa.hz_to_octs.html#librosa.hz_to_octs">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">hz_to_octs</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert frequencies (Hz) to (fractional) octave numbers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_octs(440.0)</span>
<span class="sd">    4.</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_octs([32, 64, 128, 256])</span>
<span class="sd">    array([ 0.219,  1.219,  2.219,  3.219])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : number &gt;0 or np.ndarray [shape=(n,)] or float</span>
<span class="sd">        scalar or vector of frequencies</span>
<span class="sd">    tuning : float</span>
<span class="sd">        Tuning deviation from A440 in (fractional) bins per octave.</span>
<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    octaves : number or np.ndarray [shape=(n,)]</span>
<span class="sd">        octave number for each frequency</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    octs_to_hz</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A440</span> <span class="o">=</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">A440</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">))</span></div>


<div class="viewcode-block" id="octs_to_hz"><a class="viewcode-back" href="../../../generated/librosa.octs_to_hz.html#librosa.octs_to_hz">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">octs_to_hz</span><span class="p">(</span><span class="n">octs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert octaves numbers to frequencies.</span>

<span class="sd">    Octaves are counted relative to A.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.octs_to_hz(1)</span>
<span class="sd">    55.</span>
<span class="sd">    &gt;&gt;&gt; librosa.octs_to_hz([-2, -1, 0, 1, 2])</span>
<span class="sd">    array([   6.875,   13.75 ,   27.5  ,   55.   ,  110.   ])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    octs : np.ndarray [shape=(n,)] or float</span>
<span class="sd">        octave number for each frequency</span>
<span class="sd">    tuning : float</span>
<span class="sd">        Tuning deviation from A440 in (fractional) bins per octave.</span>
<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequencies : number or np.ndarray [shape=(n,)]</span>
<span class="sd">        scalar or vector of frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_octs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A440</span> <span class="o">=</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">A440</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">octs</span><span class="p">))</span></div>


<div class="viewcode-block" id="A4_to_tuning"><a class="viewcode-back" href="../../../generated/librosa.A4_to_tuning.html#librosa.A4_to_tuning">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">A4_to_tuning</span><span class="p">(</span><span class="n">A4</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a reference pitch frequency (e.g., ``A4=435``) to a tuning</span>
<span class="sd">    estimation, in fractions of a bin per octave.</span>

<span class="sd">    This is useful for determining the tuning deviation relative to</span>
<span class="sd">    A440 of a given frequency, assuming equal temperament. By default,</span>
<span class="sd">    12 bins per octave are used.</span>

<span class="sd">    This method is the inverse of `tuning_to_A4`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The base case of this method in which A440 yields 0 tuning offset</span>
<span class="sd">    from itself.</span>

<span class="sd">    &gt;&gt;&gt; librosa.A4_to_tuning(440.0)</span>
<span class="sd">    0.</span>

<span class="sd">    Convert a non-A440 frequency to a tuning offset relative</span>
<span class="sd">    to A440 using the default of 12 bins per octave.</span>

<span class="sd">    &gt;&gt;&gt; librosa.A4_to_tuning(432.0)</span>
<span class="sd">    -0.318</span>

<span class="sd">    Convert two reference pitch frequencies to corresponding</span>
<span class="sd">    tuning estimations at once, but using 24 bins per octave.</span>

<span class="sd">    &gt;&gt;&gt; librosa.A4_to_tuning([440.0, 444.0], bins_per_octave=24)</span>
<span class="sd">    array([   0.,   0.313   ])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A4 : float or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        Reference frequency(s) corresponding to A4.</span>
<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuning : float or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        Tuning deviation from A440 in (fractional) bins per octave.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    tuning_to_A4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">bins_per_octave</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">A4</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">440.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="tuning_to_A4"><a class="viewcode-back" href="../../../generated/librosa.tuning_to_A4.html#librosa.tuning_to_A4">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">tuning_to_A4</span><span class="p">(</span><span class="n">tuning</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a tuning deviation (from 0) in fractions of a bin per</span>
<span class="sd">    octave (e.g., ``tuning=-0.1``) to a reference pitch frequency</span>
<span class="sd">    relative to A440.</span>

<span class="sd">    This is useful if you are working in a non-A440 tuning system</span>
<span class="sd">    to determine the reference pitch frequency given a tuning</span>
<span class="sd">    offset and assuming equal temperament. By default, 12 bins per</span>
<span class="sd">    octave are used.</span>

<span class="sd">    This method is the inverse of  `A4_to_tuning`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The base case of this method in which a tuning deviation of 0</span>
<span class="sd">    gets us to our A440 reference pitch.</span>

<span class="sd">    &gt;&gt;&gt; librosa.tuning_to_A4(0.0)</span>
<span class="sd">    440.</span>

<span class="sd">    Convert a nonzero tuning offset to its reference pitch frequency.</span>

<span class="sd">    &gt;&gt;&gt; librosa.tuning_to_A4(-0.318)</span>
<span class="sd">    431.992</span>

<span class="sd">    Convert 3 tuning deviations at once to respective reference</span>
<span class="sd">    pitch frequencies, using 36 bins per octave.</span>

<span class="sd">    &gt;&gt;&gt; librosa.tuning_to_A4([0.1, 0.2, -0.1], bins_per_octave=36)</span>
<span class="sd">    array([   440.848,    441.698   439.154])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tuning : float or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        Tuning deviation from A440 in fractional bins per octave.</span>
<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A4 : float or np.ndarray [shape=(n,), dtype=float]</span>
<span class="sd">        Reference frequency corresponding to A4.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    A4_to_tuning</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">tuning</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_frequencies"><a class="viewcode-back" href="../../../generated/librosa.fft_frequencies.html#librosa.fft_frequencies">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">fft_frequencies</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternative implementation of `np.fft.fftfreq`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        Audio sampling rate</span>
<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freqs : np.ndarray [shape=(1 + n_fft/2,)]</span>
<span class="sd">        Frequencies ``(0, sr/n_fft, 2*sr/n_fft, ..., sr/2)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.fft_frequencies(sr=22050, n_fft=16)</span>
<span class="sd">    array([     0.   ,   1378.125,   2756.25 ,   4134.375,</span>
<span class="sd">             5512.5  ,   6890.625,   8268.75 ,   9646.875,  11025.   ])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sr</span><span class="p">)</span></div>


<div class="viewcode-block" id="cqt_frequencies"><a class="viewcode-back" href="../../../generated/librosa.cqt_frequencies.html#librosa.cqt_frequencies">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">cqt_frequencies</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmin</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the center frequencies of Constant-Q bins.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Get the CQT frequencies for 24 notes, starting at C2</span>
<span class="sd">    &gt;&gt;&gt; librosa.cqt_frequencies(24, fmin=librosa.note_to_hz(&#39;C2&#39;))</span>
<span class="sd">    array([  65.406,   69.296,   73.416,   77.782,   82.407,   87.307,</span>
<span class="sd">             92.499,   97.999,  103.826,  110.   ,  116.541,  123.471,</span>
<span class="sd">            130.813,  138.591,  146.832,  155.563,  164.814,  174.614,</span>
<span class="sd">            184.997,  195.998,  207.652,  220.   ,  233.082,  246.942])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_bins : int &gt; 0 [scalar]</span>
<span class="sd">        Number of constant-Q bins</span>
<span class="sd">    fmin : float &gt; 0 [scalar]</span>
<span class="sd">        Minimum frequency</span>
<span class="sd">    bins_per_octave : int &gt; 0 [scalar]</span>
<span class="sd">        Number of bins per octave</span>
<span class="sd">    tuning : float</span>
<span class="sd">        Deviation from A440 tuning in fractional bins</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequencies : np.ndarray [shape=(n_bins,)]</span>
<span class="sd">        Center frequency for each CQT bin</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">correction</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tuning</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">correction</span> <span class="o">*</span> <span class="n">fmin</span> <span class="o">*</span> <span class="n">frequencies</span></div>


<div class="viewcode-block" id="mel_frequencies"><a class="viewcode-back" href="../../../generated/librosa.mel_frequencies.html#librosa.mel_frequencies">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">mel_frequencies</span><span class="p">(</span><span class="n">n_mels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mf">11025.0</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute an array of acoustic frequencies tuned to the mel scale.</span>

<span class="sd">    The mel scale is a quasi-logarithmic function of acoustic frequency</span>
<span class="sd">    designed such that perceptually similar pitch intervals (e.g. octaves)</span>
<span class="sd">    appear equal in width over the full hearing range.</span>

<span class="sd">    Because the definition of the mel scale is conditioned by a finite number</span>
<span class="sd">    of subjective psychoaoustical experiments, several implementations coexist</span>
<span class="sd">    in the audio signal processing literature [#]_. By default, librosa replicates</span>
<span class="sd">    the behavior of the well-established MATLAB Auditory Toolbox of Slaney [#]_.</span>
<span class="sd">    According to this default implementation,  the conversion from Hertz to mel is</span>
<span class="sd">    linear below 1 kHz and logarithmic above 1 kHz. Another available implementation</span>
<span class="sd">    replicates the Hidden Markov Toolkit [#]_ (HTK) according to the following formula::</span>

<span class="sd">        mel = 2595.0 * np.log10(1.0 + f / 700.0).</span>

<span class="sd">    The choice of implementation is determined by the ``htk`` keyword argument: setting</span>
<span class="sd">    ``htk=False`` leads to the Auditory toolbox implementation, whereas setting it ``htk=True``</span>
<span class="sd">    leads to the HTK implementation.</span>

<span class="sd">    .. [#] Umesh, S., Cohen, L., &amp; Nelson, D. Fitting the mel scale.</span>
<span class="sd">        In Proc. International Conference on Acoustics, Speech, and Signal Processing</span>
<span class="sd">        (ICASSP), vol. 1, pp. 217-220, 1998.</span>

<span class="sd">    .. [#] Slaney, M. Auditory Toolbox: A MATLAB Toolbox for Auditory</span>
<span class="sd">        Modeling Work. Technical Report, version 2, Interval Research Corporation, 1998.</span>

<span class="sd">    .. [#] Young, S., Evermann, G., Gales, M., Hain, T., Kershaw, D., Liu, X.,</span>
<span class="sd">        Moore, G., Odell, J., Ollason, D., Povey, D., Valtchev, V., &amp; Woodland, P.</span>
<span class="sd">        The HTK book, version 3.4. Cambridge University, March 2009.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_mel</span>
<span class="sd">    mel_to_hz</span>
<span class="sd">    librosa.feature.melspectrogram</span>
<span class="sd">    librosa.feature.mfcc</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_mels : int &gt; 0 [scalar]</span>
<span class="sd">        Number of mel bins.</span>
<span class="sd">    fmin : float &gt;= 0 [scalar]</span>
<span class="sd">        Minimum frequency (Hz).</span>
<span class="sd">    fmax : float &gt;= 0 [scalar]</span>
<span class="sd">        Maximum frequency (Hz).</span>
<span class="sd">    htk : bool</span>
<span class="sd">        If True, use HTK formula to convert Hz to mel.</span>
<span class="sd">        Otherwise (False), use Slaney&#39;s Auditory Toolbox.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_frequencies : ndarray [shape=(n_mels,)]</span>
<span class="sd">        Vector of ``n_mels`` frequencies in Hz which are uniformly spaced on the Mel</span>
<span class="sd">        axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.mel_frequencies(n_mels=40)</span>
<span class="sd">    array([     0.   ,     85.317,    170.635,    255.952,</span>
<span class="sd">              341.269,    426.586,    511.904,    597.221,</span>
<span class="sd">              682.538,    767.855,    853.173,    938.49 ,</span>
<span class="sd">             1024.856,   1119.114,   1222.042,   1334.436,</span>
<span class="sd">             1457.167,   1591.187,   1737.532,   1897.337,</span>
<span class="sd">             2071.84 ,   2262.393,   2470.47 ,   2697.686,</span>
<span class="sd">             2945.799,   3216.731,   3512.582,   3835.643,</span>
<span class="sd">             4188.417,   4573.636,   4994.285,   5453.621,</span>
<span class="sd">             5955.205,   6502.92 ,   7101.009,   7754.107,</span>
<span class="sd">             8467.272,   9246.028,  10096.408,  11025.   ])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># &#39;Center freqs&#39; of mel bands - uniformly spaced between limits</span>
    <span class="n">min_mel</span> <span class="o">=</span> <span class="n">hz_to_mel</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="n">htk</span><span class="p">)</span>
    <span class="n">max_mel</span> <span class="o">=</span> <span class="n">hz_to_mel</span><span class="p">(</span><span class="n">fmax</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="n">htk</span><span class="p">)</span>

    <span class="n">mels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_mel</span><span class="p">,</span> <span class="n">max_mel</span><span class="p">,</span> <span class="n">n_mels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mel_to_hz</span><span class="p">(</span><span class="n">mels</span><span class="p">,</span> <span class="n">htk</span><span class="o">=</span><span class="n">htk</span><span class="p">)</span></div>


<div class="viewcode-block" id="tempo_frequencies"><a class="viewcode-back" href="../../../generated/librosa.tempo_frequencies.html#librosa.tempo_frequencies">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">tempo_frequencies</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the frequencies (in beats per minute) corresponding</span>
<span class="sd">    to an onset auto-correlation or tempogram matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_bins : int &gt; 0</span>
<span class="sd">        The number of lag bins</span>
<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        The number of samples between each bin</span>
<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        The audio sampling rate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_frequencies : ndarray [shape=(n_bins,)]</span>
<span class="sd">        vector of bin frequencies measured in BPM.</span>

<span class="sd">        .. note:: ``bin_frequencies[0] = +np.inf`` corresponds to 0-lag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the tempo frequencies corresponding to a 384-bin (8-second) tempogram</span>

<span class="sd">    &gt;&gt;&gt; librosa.tempo_frequencies(384)</span>
<span class="sd">    array([      inf,  2583.984,  1291.992, ...,     6.782,</span>
<span class="sd">               6.764,     6.747])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bin_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">bin_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">bin_frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="p">(</span><span class="n">hop_length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bin_frequencies</span></div>


<div class="viewcode-block" id="fourier_tempo_frequencies"><a class="viewcode-back" href="../../../generated/librosa.fourier_tempo_frequencies.html#librosa.fourier_tempo_frequencies">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">fourier_tempo_frequencies</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="mi">384</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the frequencies (in beats per minute) corresponding</span>
<span class="sd">    to a Fourier tempogram matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        The audio sampling rate</span>
<span class="sd">    win_length : int &gt; 0</span>
<span class="sd">        The number of frames per analysis window</span>
<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        The number of samples between each bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_frequencies : ndarray [shape=(win_length // 2 + 1 ,)]</span>
<span class="sd">        vector of bin frequencies measured in BPM.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the tempo frequencies corresponding to a 384-bin (8-second) tempogram</span>

<span class="sd">    &gt;&gt;&gt; librosa.fourier_tempo_frequencies(win_length=384)</span>
<span class="sd">    array([ 0.   ,  0.117,  0.234, ..., 22.266, 22.383, 22.5  ])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># sr / hop_length gets the frame rate</span>
    <span class="c1"># multiplying by 60 turns frames / sec into frames / minute</span>
    <span class="k">return</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">),</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">win_length</span><span class="p">)</span></div>


<span class="c1"># A-weighting should be capitalized: suppress the naming warning</span>
<div class="viewcode-block" id="A_weighting"><a class="viewcode-back" href="../../../generated/librosa.A_weighting.html#librosa.A_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">A_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_db</span><span class="o">=-</span><span class="mf">80.0</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;Compute the A-weighting of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    min_db : float [scalar] or None</span>
<span class="sd">        Clip weights below this threshold.</span>
<span class="sd">        If `None`, no clipping is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A_weighting : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        ``A_weighting[i]`` is the A-weighting of ``frequencies[i]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    frequency_weighting</span>
<span class="sd">    multi_frequency_weighting</span>
<span class="sd">    B_weighting</span>
<span class="sd">    C_weighting</span>
<span class="sd">    D_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the A-weighting for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.A_weighting(freqs)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(freqs, weights)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;,</span>
<span class="sd">    ...        ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;A-Weighting of CQT frequencies&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">12194.217</span><span class="p">,</span> <span class="mf">20.598997</span><span class="p">,</span> <span class="mf">107.65265</span><span class="p">,</span> <span class="mf">737.86223</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="mf">20.0</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">weights</span> <span class="k">if</span> <span class="n">min_db</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">min_db</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="B_weighting"><a class="viewcode-back" href="../../../generated/librosa.B_weighting.html#librosa.B_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">B_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_db</span><span class="o">=-</span><span class="mf">80.0</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;Compute the B-weighting of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    min_db : float [scalar] or None</span>
<span class="sd">        Clip weights below this threshold.</span>
<span class="sd">        If `None`, no clipping is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B_weighting : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        ``B_weighting[i]`` is the B-weighting of ``frequencies[i]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    frequency_weighting</span>
<span class="sd">    multi_frequency_weighting</span>
<span class="sd">    A_weighting</span>
<span class="sd">    C_weighting</span>
<span class="sd">    D_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the B-weighting for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.B_weighting(freqs)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(freqs, weights)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;,</span>
<span class="sd">    ...        ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;B-Weighting of CQT frequencies&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">12194.217</span><span class="p">,</span> <span class="mf">20.598997</span><span class="p">,</span> <span class="mf">158.48932</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.17</span> <span class="o">+</span> <span class="mf">20.0</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">weights</span> <span class="k">if</span> <span class="n">min_db</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">min_db</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="C_weighting"><a class="viewcode-back" href="../../../generated/librosa.C_weighting.html#librosa.C_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">C_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_db</span><span class="o">=-</span><span class="mf">80.0</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;Compute the C-weighting of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    min_db : float [scalar] or None</span>
<span class="sd">        Clip weights below this threshold.</span>
<span class="sd">        If `None`, no clipping is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C_weighting : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        ``C_weighting[i]`` is the C-weighting of ``frequencies[i]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    frequency_weighting</span>
<span class="sd">    multi_frequency_weighting</span>
<span class="sd">    A_weighting</span>
<span class="sd">    B_weighting</span>
<span class="sd">    D_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the C-weighting for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.C_weighting(freqs)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(freqs, weights)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;, ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;C-Weighting of CQT frequencies&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">12194.217</span><span class="p">,</span> <span class="mf">20.598997</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.062</span> <span class="o">+</span> <span class="mf">20.0</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">weights</span> <span class="k">if</span> <span class="n">min_db</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">min_db</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="D_weighting"><a class="viewcode-back" href="../../../generated/librosa.D_weighting.html#librosa.D_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">D_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_db</span><span class="o">=-</span><span class="mf">80.0</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;Compute the D-weighting of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    min_db : float [scalar] or None</span>
<span class="sd">        Clip weights below this threshold.</span>
<span class="sd">        If `None`, no clipping is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_weighting : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        ``D_weighting[i]`` is the D-weighting of ``frequencies[i]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    frequency_weighting</span>
<span class="sd">    multi_frequency_weighting</span>
<span class="sd">    A_weighting</span>
<span class="sd">    B_weighting</span>
<span class="sd">    C_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the D-weighting for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.D_weighting(freqs)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(freqs, weights)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;, ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;D-Weighting of CQT frequencies&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">8.3046305e-3</span><span class="p">,</span> <span class="mf">1018.7</span><span class="p">,</span> <span class="mf">1039.6</span><span class="p">,</span> <span class="mf">3136.5</span><span class="p">,</span> <span class="mi">3424</span><span class="p">,</span> <span class="mf">282.7</span><span class="p">,</span> <span class="mi">1160</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mf">20.0</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_sq</span><span class="p">)</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="o">+</span> <span class="mf">0.5</span>
        <span class="o">*</span> <span class="p">(</span>
            <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_sq</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">f_sq</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((</span><span class="n">const</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_sq</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">const</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">f_sq</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">f_sq</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">const</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">f_sq</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">weights</span> <span class="k">if</span> <span class="n">min_db</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">min_db</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">Z_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_db</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">weights</span> <span class="k">if</span> <span class="n">min_db</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">min_db</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>


<span class="n">WEIGHTING_FUNCTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="n">A_weighting</span><span class="p">,</span>
    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">B_weighting</span><span class="p">,</span>
    <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="n">C_weighting</span><span class="p">,</span>
    <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="n">D_weighting</span><span class="p">,</span>
    <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="n">Z_weighting</span><span class="p">,</span>
    <span class="kc">None</span><span class="p">:</span> <span class="n">Z_weighting</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="frequency_weighting"><a class="viewcode-back" href="../../../generated/librosa.frequency_weighting.html#librosa.frequency_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">frequency_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the weighting of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    kind : str in</span>
<span class="sd">        The weighting kind. e.g. `&#39;A&#39;`, `&#39;B&#39;`, `&#39;C&#39;`, `&#39;D&#39;`, `&#39;Z&#39;`</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Additional keyword arguments to A_weighting, B_weighting, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weighting : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        ``weighting[i]`` is the weighting of ``frequencies[i]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    multi_frequency_weighting</span>
<span class="sd">    A_weighting</span>
<span class="sd">    B_weighting</span>
<span class="sd">    C_weighting</span>
<span class="sd">    D_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the A-weighting for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.frequency_weighting(freqs, kind=&#39;A&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(freqs, weights)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;, ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;A-Weighting of CQT frequencies&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">WEIGHTING_FUNCTIONS</span><span class="p">[</span><span class="n">kind</span><span class="p">](</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="multi_frequency_weighting"><a class="viewcode-back" href="../../../generated/librosa.multi_frequency_weighting.html#librosa.multi_frequency_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">multi_frequency_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kinds</span><span class="o">=</span><span class="s2">&quot;ZAC&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute multiple weightings of a set of frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : scalar or np.ndarray [shape=(n,)]</span>
<span class="sd">        One or more frequencies (in Hz)</span>
<span class="sd">    kinds : list or tuple or str</span>
<span class="sd">        An iterable of weighting kinds. e.g. `(&#39;Z&#39;, &#39;B&#39;)`, `&#39;ZAD&#39;`, `&#39;C&#39;`</span>
<span class="sd">    **kwargs : keywords to pass to the weighting function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weighting : scalar or np.ndarray [shape=(len(kinds), n)]</span>
<span class="sd">        ``weighting[i, j]`` is the weighting of ``frequencies[j]``</span>
<span class="sd">        using the curve determined by ``kinds[i]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    frequency_weighting</span>
<span class="sd">    A_weighting</span>
<span class="sd">    B_weighting</span>
<span class="sd">    C_weighting</span>
<span class="sd">    D_weighting</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the A, B, C, D, and Z weightings for CQT frequencies</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=108, fmin=librosa.note_to_hz(&#39;C1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; weightings = &#39;ABCDZ&#39;</span>
<span class="sd">    &gt;&gt;&gt; weights = librosa.multi_frequency_weighting(freqs, kinds=weightings)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; for label, w in zip(weightings, weights):</span>
<span class="sd">    ...     ax.plot(freqs, w, label=label)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlabel=&#39;Frequency (Hz)&#39;, ylabel=&#39;Weighting (log10)&#39;,</span>
<span class="sd">    ...        title=&#39;Weightings of CQT frequencies&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">frequency_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="times_like"><a class="viewcode-back" href="../../../generated/librosa.times_like.html#librosa.times_like">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">times_like</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an array of time values to match the time axis from a feature matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray or scalar</span>
<span class="sd">        - If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.</span>
<span class="sd">        - If scalar, X represents the number of frames.</span>
<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>
<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``n_fft // 2``</span>
<span class="sd">        to counteract windowing effects when using a non-centered STFT.</span>
<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The axis representing the time axis of X.</span>
<span class="sd">        By default, the last axis (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=(n,)]</span>
<span class="sd">        ndarray of times (in seconds) corresponding to each frame of X.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    samples_like :</span>
<span class="sd">        Return an array of sample indices to match the time axis from a feature matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Provide a feature matrix input:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(D)</span>
<span class="sd">    &gt;&gt;&gt; times</span>
<span class="sd">    array([0.   , 0.023, ..., 5.294, 5.317])</span>

<span class="sd">    Provide a scalar input:</span>

<span class="sd">    &gt;&gt;&gt; n_frames = 2647</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(n_frames)</span>
<span class="sd">    &gt;&gt;&gt; times</span>
<span class="sd">    array([  0.00000000e+00,   2.32199546e-02,   4.64399093e-02, ...,</span>
<span class="sd">             6.13935601e+01,   6.14167800e+01,   6.14400000e+01])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">samples_like</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples_to_time</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span></div>


<div class="viewcode-block" id="samples_like"><a class="viewcode-back" href="../../../generated/librosa.samples_like.html#librosa.samples_like">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">samples_like</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an array of sample indices to match the time axis from a feature matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray or scalar</span>
<span class="sd">        - If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.</span>
<span class="sd">        - If scalar, X represents the number of frames.</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames</span>
<span class="sd">    n_fft : None or int &gt; 0 [scalar]</span>
<span class="sd">        Optional: length of the FFT window.</span>
<span class="sd">        If given, time conversion will include an offset of ``n_fft // 2``</span>
<span class="sd">        to counteract windowing effects when using a non-centered STFT.</span>
<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The axis representing the time axis of ``X``.</span>
<span class="sd">        By default, the last axis (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : np.ndarray [shape=(n,)]</span>
<span class="sd">        ndarray of sample indices corresponding to each frame of ``X``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    times_like :</span>
<span class="sd">        Return an array of time values to match the time axis from a feature matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Provide a feature matrix input:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; X = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; samples = librosa.samples_like(X)</span>
<span class="sd">    &gt;&gt;&gt; samples</span>
<span class="sd">    array([     0,    512, ..., 116736, 117248])</span>

<span class="sd">    Provide a scalar input:</span>

<span class="sd">    &gt;&gt;&gt; n_frames = 2647</span>
<span class="sd">    &gt;&gt;&gt; samples = librosa.samples_like(n_frames)</span>
<span class="sd">    &gt;&gt;&gt; samples</span>
<span class="sd">    array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">frames_to_samples</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span></div>


<div class="viewcode-block" id="midi_to_svara_h"><a class="viewcode-back" href="../../../generated/librosa.midi_to_svara_h.html#librosa.midi_to_svara_h">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">midi_to_svara_h</span><span class="p">(</span><span class="n">midi</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert MIDI numbers to Hindustani svara</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    midi : numeric or np.ndarray</span>
<span class="sd">        The MIDI number or numbers to convert</span>

<span class="sd">    Sa : number &gt; 0</span>
<span class="sd">        MIDI number of the reference Sa.</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;r&#39;, &#39;R&#39;, &#39;g&#39;, &#39;G&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;re&#39;, &#39;Re&#39;, &#39;ga&#39;, &#39;Ga&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">        This only takes effect if `octave=True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given MIDI number(s)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_svara_h</span>
<span class="sd">    note_to_svara_h</span>
<span class="sd">    midi_to_svara_c</span>
<span class="sd">    midi_to_note</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The first three svara with Sa at midi number 60:</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_svara_h([60, 61, 62], Sa=60)</span>
<span class="sd">    [&#39;S&#39;, &#39;r&#39;, &#39;R&#39;]</span>

<span class="sd">    With Sa=67, midi 60-62 are in the octave below:</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_svara_h([60, 61, 62], Sa=67)</span>
<span class="sd">    [&#39;ṃ&#39;, &#39;Ṃ&#39;, &#39;P̣&#39;]</span>

<span class="sd">    Or without unicode decoration:</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_svara_h([60, 61, 62], Sa=67, unicode=False)</span>
<span class="sd">    [&#39;m,&#39;, &#39;M,&#39;, &#39;P,&#39;]</span>

<span class="sd">    Or going up an octave, with Sa=60, and using unabbreviated notes</span>

<span class="sd">    &gt;&gt;&gt; librosa.midi_to_svara_h([72, 73, 74], Sa=60, abbr=False)</span>
<span class="sd">    [&#39;Ṡa&#39;, &#39;ṙe&#39;, &#39;Ṙe&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SVARA_MAP</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Sa&quot;</span><span class="p">,</span>
        <span class="s2">&quot;re&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Re&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ga&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Ga&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ma&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Ma&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Pa&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dha&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Dha&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ni&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Ni&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">SVARA_MAP_SHORT</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">SVARA_MAP</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">midi</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">midi_to_svara_h</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">Sa</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">midi</span>
        <span class="p">]</span>

    <span class="n">svara_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">midi</span> <span class="o">-</span> <span class="n">Sa</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">abbr</span><span class="p">:</span>
        <span class="n">svara</span> <span class="o">=</span> <span class="n">SVARA_MAP_SHORT</span><span class="p">[</span><span class="n">svara_num</span> <span class="o">%</span> <span class="mi">12</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">svara</span> <span class="o">=</span> <span class="n">SVARA_MAP</span><span class="p">[</span><span class="n">svara_num</span> <span class="o">%</span> <span class="mi">12</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">octave</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">24</span> <span class="o">&gt;</span> <span class="n">svara_num</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">=</span> <span class="n">svara</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\u0307</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">svara</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">+=</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="k">elif</span> <span class="o">-</span><span class="mi">12</span> <span class="o">&lt;=</span> <span class="n">svara_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">=</span> <span class="n">svara</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\u0323</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">svara</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span>

    <span class="k">return</span> <span class="n">svara</span></div>


<div class="viewcode-block" id="hz_to_svara_h"><a class="viewcode-back" href="../../../generated/librosa.hz_to_svara_h.html#librosa.hz_to_svara_h">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">hz_to_svara_h</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert frequencies (in Hz) to Hindustani svara</span>

<span class="sd">    Note that this conversion assumes 12-tone equal temperament.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : positive number or np.ndarray</span>
<span class="sd">        The frequencies (in Hz) to convert</span>

<span class="sd">    Sa : positive number</span>
<span class="sd">        Frequency (in Hz) of the reference Sa.</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;r&#39;, &#39;R&#39;, &#39;g&#39;, &#39;G&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;re&#39;, &#39;Re&#39;, &#39;ga&#39;, &#39;Ga&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">        This only takes effect if `octave=True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given frequency/frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_svara_h</span>
<span class="sd">    note_to_svara_h</span>
<span class="sd">    hz_to_svara_c</span>
<span class="sd">    hz_to_note</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert Sa in three octaves:</span>

<span class="sd">    &gt;&gt;&gt; librosa.hz_to_svara_h([261/2, 261, 261*2], Sa=261)</span>
<span class="sd">    [&#39;Ṣ&#39;, &#39;S&#39;, &#39;Ṡ&#39;]</span>

<span class="sd">    Convert one octave worth of frequencies with full names:</span>

<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=12, fmin=261)</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_svara_h(freqs, Sa=freqs[0], abbr=False)</span>
<span class="sd">    [&#39;Sa&#39;, &#39;re&#39;, &#39;Re&#39;, &#39;ga&#39;, &#39;Ga&#39;, &#39;ma&#39;, &#39;Ma&#39;, &#39;Pa&#39;, &#39;dha&#39;, &#39;Dha&#39;, &#39;ni&#39;, &#39;Ni&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">midis</span> <span class="o">=</span> <span class="n">hz_to_midi</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">midi_to_svara_h</span><span class="p">(</span>
        <span class="n">midis</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="n">Sa</span><span class="p">),</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="note_to_svara_h"><a class="viewcode-back" href="../../../generated/librosa.note_to_svara_h.html#librosa.note_to_svara_h">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">note_to_svara_h</span><span class="p">(</span><span class="n">notes</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert western notes to Hindustani svara</span>

<span class="sd">    Note that this conversion assumes 12-tone equal temperament.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    notes : str or list of str</span>
<span class="sd">        Notes to convert (e.g., `&#39;C#&#39;` or `[&#39;C4&#39;, &#39;Db4&#39;, &#39;D4&#39;]`</span>

<span class="sd">    Sa : str</span>
<span class="sd">        Note corresponding to Sa (e.g., `&#39;C&#39;` or `&#39;C5&#39;`).</span>

<span class="sd">        If no octave information is provided, it will default to octave 0</span>
<span class="sd">        (``C0`` ~= 16 Hz)</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;r&#39;, &#39;R&#39;, &#39;g&#39;, &#39;G&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;re&#39;, &#39;Re&#39;, &#39;ga&#39;, &#39;Ga&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">        This only takes effect if `octave=True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given notes</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_svara_h</span>
<span class="sd">    hz_to_svara_h</span>
<span class="sd">    note_to_svara_c</span>
<span class="sd">    note_to_midi</span>
<span class="sd">    note_to_hz</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_svara_h([&#39;C4&#39;, &#39;G4&#39;, &#39;C5&#39;, &#39;G5&#39;], Sa=&#39;C5&#39;)</span>
<span class="sd">    [&#39;Ṣ&#39;, &#39;P̣&#39;, &#39;S&#39;, &#39;P&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">midis</span> <span class="o">=</span> <span class="n">note_to_midi</span><span class="p">(</span><span class="n">notes</span><span class="p">,</span> <span class="n">round_midi</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">midi_to_svara_h</span><span class="p">(</span>
        <span class="n">midis</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">note_to_midi</span><span class="p">(</span><span class="n">Sa</span><span class="p">),</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="midi_to_svara_c"><a class="viewcode-back" href="../../../generated/librosa.midi_to_svara_c.html#librosa.midi_to_svara_c">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">midi_to_svara_c</span><span class="p">(</span><span class="n">midi</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert MIDI numbers to Carnatic svara within a given melakarta raga</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    midi : numeric</span>
<span class="sd">        The MIDI numbers to convert</span>

<span class="sd">    Sa : number &gt; 0</span>
<span class="sd">        MIDI number of the reference Sa.</span>

<span class="sd">        Default: 60 (261.6 Hz, `C4`)</span>

<span class="sd">    mela : int or str</span>
<span class="sd">        The name or index of the melakarta raga</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;R1&#39;, &#39;R2&#39;, &#39;G1&#39;, &#39;G2&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;Ri1&#39;, &#39;Ri2&#39;, &#39;Ga1&#39;, &#39;Ga2&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information and subscript</span>
<span class="sd">        numbers.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given MIDI number(s)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hz_to_svara_c</span>
<span class="sd">    note_to_svara_c</span>
<span class="sd">    mela_to_degrees</span>
<span class="sd">    mela_to_svara</span>
<span class="sd">    list_mela</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">midi</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">midi_to_svara_c</span><span class="p">(</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">Sa</span><span class="p">,</span> <span class="n">mela</span><span class="o">=</span><span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">midi</span>
        <span class="p">]</span>

    <span class="n">svara_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">midi</span> <span class="o">-</span> <span class="n">Sa</span><span class="p">))</span>

    <span class="n">svara_map</span> <span class="o">=</span> <span class="n">notation</span><span class="o">.</span><span class="n">mela_to_svara</span><span class="p">(</span><span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span><span class="p">)</span>

    <span class="n">svara</span> <span class="o">=</span> <span class="n">svara_map</span><span class="p">[</span><span class="n">svara_num</span> <span class="o">%</span> <span class="mi">12</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">octave</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">24</span> <span class="o">&gt;</span> <span class="n">svara_num</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">=</span> <span class="n">svara</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\u0307</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">svara</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">+=</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="k">elif</span> <span class="o">-</span><span class="mi">12</span> <span class="o">&lt;=</span> <span class="n">svara_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">=</span> <span class="n">svara</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\u0323</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">svara</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">svara</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span>

    <span class="k">return</span> <span class="n">svara</span></div>


<div class="viewcode-block" id="hz_to_svara_c"><a class="viewcode-back" href="../../../generated/librosa.hz_to_svara_c.html#librosa.hz_to_svara_c">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">hz_to_svara_c</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert frequencies (in Hz) to Carnatic svara</span>

<span class="sd">    Note that this conversion assumes 12-tone equal temperament.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : positive number or np.ndarray</span>
<span class="sd">        The frequencies (in Hz) to convert</span>

<span class="sd">    Sa : positive number</span>
<span class="sd">        Frequency (in Hz) of the reference Sa.</span>

<span class="sd">    mela : int [1, 72] or string</span>
<span class="sd">        The melakarta raga to use.</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;R1&#39;, &#39;R2&#39;, &#39;G1&#39;, &#39;G2&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;Ri1&#39;, &#39;Ri2&#39;, &#39;Ga1&#39;, &#39;Ga2&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">        This only takes effect if `octave=True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given frequency/frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    note_to_svara_c</span>
<span class="sd">    midi_to_svara_c</span>
<span class="sd">    hz_to_svara_h</span>
<span class="sd">    hz_to_note</span>
<span class="sd">    list_mela</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert Sa in three octaves:</span>

<span class="sd">    &gt;&gt;&gt; librosa.hz_to_svara_c([261/2, 261, 261*2], Sa=261, mela=&#39;kanakangi&#39;)</span>
<span class="sd">    [&#39;Ṣ&#39;, &#39;S&#39;, &#39;Ṡ&#39;]</span>

<span class="sd">    Convert one octave worth of frequencies using melakarta #36:</span>

<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(n_bins=12, fmin=261)</span>
<span class="sd">    &gt;&gt;&gt; librosa.hz_to_svara_c(freqs, Sa=freqs[0], mela=36)</span>
<span class="sd">    [&#39;S&#39;, &#39;R₁&#39;, &#39;R₂&#39;, &#39;R₃&#39;, &#39;G₃&#39;, &#39;M₁&#39;, &#39;M₂&#39;, &#39;P&#39;, &#39;D₁&#39;, &#39;D₂&#39;, &#39;D₃&#39;, &#39;N₃&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">midis</span> <span class="o">=</span> <span class="n">hz_to_midi</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">midi_to_svara_c</span><span class="p">(</span>
        <span class="n">midis</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="n">Sa</span><span class="p">),</span> <span class="n">mela</span><span class="o">=</span><span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="note_to_svara_c"><a class="viewcode-back" href="../../../generated/librosa.note_to_svara_c.html#librosa.note_to_svara_c">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">note_to_svara_c</span><span class="p">(</span><span class="n">notes</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">Sa</span><span class="p">,</span> <span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert western notes to Carnatic svara</span>

<span class="sd">    Note that this conversion assumes 12-tone equal temperament.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    notes : str or list of str</span>
<span class="sd">        Notes to convert (e.g., `&#39;C#&#39;` or `[&#39;C4&#39;, &#39;Db4&#39;, &#39;D4&#39;]`</span>

<span class="sd">    Sa : str</span>
<span class="sd">        Note corresponding to Sa (e.g., `&#39;C&#39;` or `&#39;C5&#39;`).</span>

<span class="sd">        If no octave information is provided, it will default to octave 0</span>
<span class="sd">        (``C0`` ~= 16 Hz)</span>

<span class="sd">    mela : str or int [1, 72]</span>
<span class="sd">        Melakarta raga name or index</span>

<span class="sd">    abbr : bool</span>
<span class="sd">        If `True` (default) return abbreviated names (&#39;S&#39;, &#39;R1&#39;, &#39;R2&#39;, &#39;G1&#39;, &#39;G2&#39;, ...)</span>

<span class="sd">        If `False`, return long-form names (&#39;Sa&#39;, &#39;Ri1&#39;, &#39;Ri2&#39;, &#39;Ga1&#39;, &#39;Ga2&#39;, ...)</span>

<span class="sd">    octave : bool</span>
<span class="sd">        If `True`, decorate svara in neighboring octaves with over- or under-dots.</span>

<span class="sd">        If `False`, ignore octave height information.</span>

<span class="sd">    unicode : bool</span>
<span class="sd">        If `True`, use unicode symbols to decorate octave information.</span>

<span class="sd">        If `False`, use low-order ASCII (&#39; and ,) for octave decorations.</span>

<span class="sd">        This only takes effect if `octave=True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svara : str or list of str</span>
<span class="sd">        The svara corresponding to the given notes</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    midi_to_svara_c</span>
<span class="sd">    hz_to_svara_c</span>
<span class="sd">    note_to_svara_h</span>
<span class="sd">    note_to_midi</span>
<span class="sd">    note_to_hz</span>
<span class="sd">    list_mela</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.note_to_svara_h([&#39;C4&#39;, &#39;G4&#39;, &#39;C5&#39;, &#39;D5&#39;, &#39;G5&#39;], Sa=&#39;C5&#39;, mela=1)</span>
<span class="sd">    [&#39;Ṣ&#39;, &#39;P̣&#39;, &#39;S&#39;, &#39;G₁&#39;, &#39;P&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">midis</span> <span class="o">=</span> <span class="n">note_to_midi</span><span class="p">(</span><span class="n">notes</span><span class="p">,</span> <span class="n">round_midi</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">midi_to_svara_c</span><span class="p">(</span>
        <span class="n">midis</span><span class="p">,</span> <span class="n">Sa</span><span class="o">=</span><span class="n">note_to_midi</span><span class="p">(</span><span class="n">Sa</span><span class="p">),</span> <span class="n">mela</span><span class="o">=</span><span class="n">mela</span><span class="p">,</span> <span class="n">abbr</span><span class="o">=</span><span class="n">abbr</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">unicode</span><span class="o">=</span><span class="n">unicode</span>
    <span class="p">)</span></div>
</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: main
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Releases</dt>
      <dd><a href="../../../../0.7.2/index.html">0.7.2</a></dd>
      <dd><a href="../../../../0.8.1/index.html">0.8.1</a></dd>
      <dd><a href="../../../../0.9.0/index.html">0.9.0</a></dd>
      <dd><a href="../../../../0.9.1/index.html">0.9.1</a></dd>
    </dl>
    <dl>
      <dt>Development versions</dt>
      <dd><a href="convert.html">main</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>