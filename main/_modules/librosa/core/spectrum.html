<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.core.spectrum &mdash; librosa 0.9.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html">
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../multichannel.html">Multi-channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>librosa.core.spectrum</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             

<div class="admonition danger">
    <p class="admonition-title"> Caution </p>
  <p>
    
        You're reading the documentation for a development version.
        For the latest released version, please have a look at <a href="../../../../0.9.1/index.html">0.9.1</a>.
    
  </p>
</div>


  <h1>Source code for librosa.core.spectrum</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Utilities for spectral processing&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">convert</span>
<span class="kn">from</span> <span class="nn">.fft</span> <span class="kn">import</span> <span class="n">get_fftlib</span>
<span class="kn">from</span> <span class="nn">.audio</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="nn">.._cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">semitone_filterbank</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">window_sumsquare</span>
<span class="kn">from</span> <span class="nn">..util.decorators</span> <span class="kn">import</span> <span class="n">deprecate_positional_args</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;stft&quot;</span><span class="p">,</span>
    <span class="s2">&quot;istft&quot;</span><span class="p">,</span>
    <span class="s2">&quot;magphase&quot;</span><span class="p">,</span>
    <span class="s2">&quot;iirt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;reassigned_spectrogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;phase_vocoder&quot;</span><span class="p">,</span>
    <span class="s2">&quot;perceptual_weighting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;power_to_db&quot;</span><span class="p">,</span>
    <span class="s2">&quot;db_to_power&quot;</span><span class="p">,</span>
    <span class="s2">&quot;amplitude_to_db&quot;</span><span class="p">,</span>
    <span class="s2">&quot;db_to_amplitude&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fmt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pcen&quot;</span><span class="p">,</span>
    <span class="s2">&quot;griffinlim&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="stft"><a class="viewcode-back" href="../../../generated/librosa.stft.html#librosa.stft">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stft</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Short-time Fourier transform (STFT).</span>

<span class="sd">    The STFT represents a signal in the time-frequency domain by</span>
<span class="sd">    computing discrete Fourier transforms (DFT) over short overlapping</span>
<span class="sd">    windows.</span>

<span class="sd">    This function returns a complex-valued matrix D such that</span>

<span class="sd">    - ``np.abs(D[..., f, t])`` is the magnitude of frequency bin ``f``</span>
<span class="sd">      at frame ``t``, and</span>

<span class="sd">    - ``np.angle(D[..., f, t])`` is the phase of frequency bin ``f``</span>
<span class="sd">      at frame ``t``.</span>

<span class="sd">    The integers ``t`` and ``f`` can be converted to physical units by means</span>
<span class="sd">    of the utility functions `frames_to_sample` and `fft_frequencies`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)], real-valued</span>
<span class="sd">        input signal. Multi-channel is supported.</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        length of the windowed signal after padding with zeros.</span>
<span class="sd">        The number of rows in the STFT matrix ``D`` is ``(1 + n_fft/2)``.</span>
<span class="sd">        The default value, ``n_fft=2048`` samples, corresponds to a physical</span>
<span class="sd">        duration of 93 milliseconds at a sample rate of 22050 Hz, i.e. the</span>
<span class="sd">        default sample rate in librosa. This value is well adapted for music</span>
<span class="sd">        signals. However, in speech processing, the recommended value is 512,</span>
<span class="sd">        corresponding to 23 milliseconds at a sample rate of 22050 Hz.</span>
<span class="sd">        In any case, we recommend setting ``n_fft`` to a power of two for</span>
<span class="sd">        optimizing the speed of the fast Fourier transform (FFT) algorithm.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of audio samples between adjacent STFT columns.</span>

<span class="sd">        Smaller values increase the number of columns in ``D`` without</span>
<span class="sd">        affecting the frequency resolution of the STFT.</span>

<span class="sd">        If unspecified, defaults to ``win_length // 4`` (see below).</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by ``window`` of length ``win_length``</span>
<span class="sd">        and then padded with zeros to match ``n_fft``.</span>

<span class="sd">        Smaller values improve the temporal resolution of the STFT (i.e. the</span>
<span class="sd">        ability to discriminate impulses that are closely spaced in time)</span>
<span class="sd">        at the expense of frequency resolution (i.e. the ability to discriminate</span>
<span class="sd">        pure tones that are closely spaced in frequency). This effect is known</span>
<span class="sd">        as the time-frequency localization trade-off and needs to be adjusted</span>
<span class="sd">        according to the properties of the input signal ``y``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        Either:</span>

<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        Defaults to a raised cosine window (`&#39;hann&#39;`), which is adequate for</span>
<span class="sd">        most applications in audio signal processing.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        If ``True``, the signal ``y`` is padded so that frame</span>
<span class="sd">        ``D[:, t]`` is centered at ``y[t * hop_length]``.</span>

<span class="sd">        If ``False``, then ``D[:, t]`` begins at ``y[t * hop_length]``.</span>

<span class="sd">        Defaults to ``True``,  which simplifies the alignment of ``D`` onto a</span>
<span class="sd">        time grid by means of `librosa.frames_to_samples`.</span>
<span class="sd">        Note, however, that ``center`` must be set to `False` when analyzing</span>
<span class="sd">        signals with `librosa.stream`.</span>

<span class="sd">        .. see also:: `librosa.stream`</span>

<span class="sd">    dtype : np.dtype, optional</span>
<span class="sd">        Complex numeric type for ``D``.  Default is inferred to match the</span>
<span class="sd">        precision of the input signal.</span>

<span class="sd">    pad_mode : string or function</span>
<span class="sd">        If ``center=True``, this argument is passed to `np.pad` for padding</span>
<span class="sd">        the edges of the signal ``y``. By default (``pad_mode=&quot;constant&quot;``),</span>
<span class="sd">        ``y`` is padded on both sides with zeros.</span>
<span class="sd">        If ``center=False``,  this argument is ignored.</span>

<span class="sd">        .. see also:: `numpy.pad`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(..., 1 + n_fft/2, n_frames), dtype=dtype]</span>
<span class="sd">        Complex-valued matrix of short-term Fourier transform</span>
<span class="sd">        coefficients.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    istft : Inverse STFT</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 20.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; S</span>
<span class="sd">    array([[5.395e-03, 3.332e-03, ..., 9.862e-07, 1.201e-05],</span>
<span class="sd">           [3.244e-03, 2.690e-03, ..., 9.536e-07, 1.201e-05],</span>
<span class="sd">           ...,</span>
<span class="sd">           [7.523e-05, 3.722e-05, ..., 1.188e-04, 1.031e-03],</span>
<span class="sd">           [7.640e-05, 3.944e-05, ..., 5.180e-04, 1.346e-03]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Use left-aligned frames, instead of centered frames</span>

<span class="sd">    &gt;&gt;&gt; S_left = librosa.stft(y, center=False)</span>

<span class="sd">    Use a shorter hop length</span>

<span class="sd">    &gt;&gt;&gt; D_short = librosa.stft(y, hop_length=64)</span>

<span class="sd">    Display a spectrogram</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(S,</span>
<span class="sd">    ...                                                        ref=np.max),</span>
<span class="sd">    ...                                y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax, format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Check audio is valid</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad the window out to n_fft size</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">fft_window</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Reshape so that the window can be broadcast</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">fft_window</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_fft</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;n_fft=</span><span class="si">{}</span><span class="s2"> is too small for input signal of length=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">n_fft</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">),</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">padding</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">n_fft</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;n_fft=</span><span class="si">{}</span><span class="s2"> is too large for input signal of length=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">n_fft</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Window the time series.</span>
    <span class="n">y_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dtype_r2c</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the STFT matrix</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y_frames</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="n">n_columns</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">//</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="p">)</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">stft_matrix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span>
            <span class="n">fft_window</span> <span class="o">*</span> <span class="n">y_frames</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">stft_matrix</span></div>


<div class="viewcode-block" id="istft"><a class="viewcode-back" href="../../../generated/librosa.istft.html#librosa.istft">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">istft</span><span class="p">(</span>
    <span class="n">stft_matrix</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse short-time Fourier transform (ISTFT).</span>

<span class="sd">    Converts a complex-valued spectrogram ``stft_matrix`` to time-series ``y``</span>
<span class="sd">    by minimizing the mean squared error between ``stft_matrix`` and STFT of</span>
<span class="sd">    ``y`` as described in [#]_ up to Section 2 (reconstruction from MSTFT).</span>

<span class="sd">    In general, window function, hop length and other parameters should be same</span>
<span class="sd">    as in stft, which mostly leads to perfect reconstruction of a signal from</span>
<span class="sd">    unmodified ``stft_matrix``.</span>

<span class="sd">    .. [#] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stft_matrix : np.ndarray [shape=(..., 1 + n_fft//2, t)]</span>
<span class="sd">        STFT matrix from ``stft``</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Number of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults to ``win_length // 4``.</span>

<span class="sd">    win_length : int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span>
<span class="sd">        When reconstructing the time series, each frame is windowed</span>
<span class="sd">        and each sample is normalized by the sum of squared window</span>
<span class="sd">        according to the ``window`` function (see below).</span>

<span class="sd">        If unspecified, defaults to ``n_fft``.</span>

<span class="sd">    n_fft : int &gt; 0 or None</span>
<span class="sd">        The number of samples per frame in the input spectrogram.</span>
<span class="sd">        By default, this will be inferred from the shape of ``stft_matrix``.</span>
<span class="sd">        However, if an odd frame length was used, you can specify the correct</span>
<span class="sd">        length by setting ``n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a user-specified window vector of length ``n_fft``</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True``, ``D`` is assumed to have centered frames.</span>
<span class="sd">        - If ``False``, ``D`` is assumed to have left-aligned frames.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Real numeric type for ``y``.  Default is to match the numerical</span>
<span class="sd">        precision of the input spectrogram.</span>

<span class="sd">    length : int &gt; 0, optional</span>
<span class="sd">        If provided, the output ``y`` is zero-padded or clipped to exactly</span>
<span class="sd">        ``length`` samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)]</span>
<span class="sd">        time domain signal reconstructed from ``stft_matrix``.</span>
<span class="sd">        If ``stft_matrix`` contains more than two axes</span>
<span class="sd">        (e.g., from a stereo input signal), then ``y`` will match shape on the leading dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; y_hat = librosa.istft(D)</span>
<span class="sd">    &gt;&gt;&gt; y_hat</span>
<span class="sd">    array([-1.407e-03, -4.461e-04, ...,  5.131e-06, -1.417e-05],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Exactly preserving length of the input signal requires explicit padding.</span>
<span class="sd">    Otherwise, a partial frame at the end of ``y`` will not be represented.</span>

<span class="sd">    &gt;&gt;&gt; n = len(y)</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 2048</span>
<span class="sd">    &gt;&gt;&gt; y_pad = librosa.util.fix_length(y, size=n + n_fft // 2)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y_pad, n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; y_out = librosa.istft(D, length=n)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(y - y_out))</span>
<span class="sd">    8.940697e-08</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad out to match n_fft, and add broadcasting axes</span>
    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">ifft_window</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>
    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">ifft_window</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># For efficiency, trim STFT frames according to signal length if available</span>
    <span class="k">if</span> <span class="n">length</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">padded_length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padded_length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">padded_length</span> <span class="o">/</span> <span class="n">hop_length</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dtype_c2r</span><span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">expected_signal_len</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">+</span> <span class="n">hop_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expected_signal_len</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">n_columns</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">//</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="p">)</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>

        <span class="c1"># invert the block and apply the window function</span>
        <span class="n">ytmp</span> <span class="o">=</span> <span class="n">ifft_window</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Overlap-add the istft block starting at the i&#39;th frame</span>
        <span class="n">__overlap_add</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame</span> <span class="o">*</span> <span class="n">hop_length</span> <span class="p">:],</span> <span class="n">ytmp</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">)</span>

        <span class="n">frame</span> <span class="o">+=</span> <span class="n">bl_t</span> <span class="o">-</span> <span class="n">bl_s</span>

    <span class="c1"># Normalize by sum of squared window</span>
    <span class="n">ifft_window_sum</span> <span class="o">=</span> <span class="n">window_sumsquare</span><span class="p">(</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">n_frames</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">approx_nonzero_indices</span> <span class="o">=</span> <span class="n">ifft_window_sum</span> <span class="o">&gt;</span> <span class="n">util</span><span class="o">.</span><span class="n">tiny</span><span class="p">(</span><span class="n">ifft_window_sum</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">approx_nonzero_indices</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ifft_window_sum</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If we don&#39;t need to control length, just do the usual center trimming</span>
        <span class="c1"># to eliminate padded data</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="c1"># If we&#39;re centering, crop off the first n_fft//2 samples</span>
            <span class="c1"># and then trim/pad to the target length.</span>
            <span class="c1"># We don&#39;t trim the end here, so that if the signal is zero-padded</span>
            <span class="c1"># to a longer duration, the decay is smooth by windowing</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;re not centering, start at 0 and trim/pad as necessary</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_length</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">start</span><span class="p">:],</span> <span class="n">size</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__overlap_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ytmp</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">):</span>
    <span class="c1"># numba-accelerated overlap add for inverse stft</span>
    <span class="c1"># y is the pre-allocated output buffer</span>
    <span class="c1"># ytmp is the windowed inverse-stft frames</span>
    <span class="c1"># hop_length is the hop-length of the STFT analysis</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="n">ytmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ytmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">frame</span> <span class="o">*</span> <span class="n">hop_length</span>
        <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">sample</span> <span class="p">:</span> <span class="p">(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">ytmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">__reassign_frequencies</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Instantaneous frequencies based on a spectrogram representation.</span>

<span class="sd">    The reassignment vector is calculated using equation 5.20 in Flandrin,</span>
<span class="sd">    Auger, &amp; Chassande-Mottin 2002::</span>

<span class="sd">        omega_reassigned = omega - np.imag(S_dh/S_h)</span>

<span class="sd">    where ``S_h`` is the complex STFT calculated using the original window, and</span>
<span class="sd">    ``S_dh`` is the complex STFT calculated using the derivative of the original</span>
<span class="sd">    window.</span>

<span class="sd">    See `reassigned_spectrogram` for references.</span>

<span class="sd">    It is recommended to use ``pad_mode=&quot;wrap&quot;`` or else ``center=False``, rather</span>
<span class="sd">    than the defaults. Frequency reassignment assumes that the energy in each</span>
<span class="sd">    FFT bin is associated with exactly one signal component. Reflection padding</span>
<span class="sd">    at the edges of the signal may invalidate the reassigned estimates in the</span>
<span class="sd">    boundary frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)], real-valued</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to `__reassign_frequencies`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to ``win_length // 4``.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to ``n_fft``.</span>
<span class="sd">        See ``stft`` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a user-specified window vector of length ``n_fft``</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True``, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``S[:, t]`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If ``False``, then ``S[:, t]`` begins at ``y[t * hop_length]``.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for ``S``. Default is inferred to match</span>
<span class="sd">        the numerical precision of the input signal.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freqs : np.ndarray [shape=(..., 1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequencies:</span>
<span class="sd">        ``freqs[f, t]`` is the frequency for bin ``f``, frame ``t``.</span>
<span class="sd">    S : np.ndarray [shape=(..., 1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Frequencies with zero support will produce a divide-by-zero warning and</span>
<span class="sd">        will be returned as `np.nan`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; frequencies, S = librosa.core.spectrum.__reassign_frequencies(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; frequencies</span>
<span class="sd">    array([[0.000e+00, 0.000e+00, ..., 0.000e+00, 0.000e+00],</span>
<span class="sd">           [3.628e+00, 4.698e+00, ..., 1.239e+01, 1.072e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [1.101e+04, 1.102e+04, ..., 1.105e+04, 1.102e+04],</span>
<span class="sd">           [1.102e+04, 1.102e+04, ..., 1.102e+04, 1.102e+04]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># retrieve window samples if needed so that the window derivative can be</span>
    <span class="c1"># calculated</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dtype_r2c</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">S_h</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">S_h</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># cyclic gradient to correctly handle edges of a periodic window</span>
    <span class="n">window_derivative</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">cyclic_gradient</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="n">S_dh</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window_derivative</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># equation 5.20 of Flandrin, Auger, &amp; Chassande-Mottin 2002</span>
    <span class="c1"># the sign of the correction is reversed in some papers - see Plante,</span>
    <span class="c1"># Meyer, &amp; Ainsworth 1998 pp. 283-284</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">S_dh</span> <span class="o">/</span> <span class="n">S_h</span><span class="p">)</span>

    <span class="n">freqs</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">correction</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">correction</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">S_h</span>


<span class="k">def</span> <span class="nf">__reassign_times</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time reassignments based on a spectrogram representation.</span>

<span class="sd">    The reassignment vector is calculated using equation 5.23 in Flandrin,</span>
<span class="sd">    Auger, &amp; Chassande-Mottin 2002::</span>

<span class="sd">        t_reassigned = t + np.real(S_th/S_h)</span>

<span class="sd">    where ``S_h`` is the complex STFT calculated using the original window, and</span>
<span class="sd">    ``S_th`` is the complex STFT calculated using the original window multiplied</span>
<span class="sd">    by the time offset from the window center.</span>

<span class="sd">    See `reassigned_spectrogram` for references.</span>

<span class="sd">    It is recommended to use ``pad_mode=&quot;constant&quot;`` (zero padding) or else</span>
<span class="sd">    ``center=False``, rather than the defaults. Time reassignment assumes that</span>
<span class="sd">    the energy in each FFT bin is associated with exactly one impulse event.</span>
<span class="sd">    Reflection padding at the edges of the signal may invalidate the reassigned</span>
<span class="sd">    estimates in the boundary frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)], real-valued</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to `__reassign_times`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to ``win_length // 4``.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to ``n_fft``.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a user-specified window vector of length ``n_fft``</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True``, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``S[:, t]`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If ``False``, then ``S[:, t]`` begins at ``y[t * hop_length]``.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for ``S``. Default is inferred to match</span>
<span class="sd">        the precision of the input signal.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=(..., 1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Reassigned times:</span>
<span class="sd">        ``times[f, t]`` is the time for bin ``f``, frame ``t``.</span>
<span class="sd">    S : np.ndarray [shape=(..., 1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Time estimates with zero support will produce a divide-by-zero warning</span>
<span class="sd">        and will be returned as `np.nan`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; times, S = librosa.core.spectrum.__reassign_times(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; times</span>
<span class="sd">    array([[ 2.268e-05,  1.144e-02, ...,  5.332e+00,  5.333e+00],</span>
<span class="sd">           [ 2.268e-05,  1.451e-02, ...,  5.334e+00,  5.333e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 2.268e-05, -6.177e-04, ...,  5.368e+00,  5.327e+00],</span>
<span class="sd">           [ 2.268e-05,  1.420e-03, ...,  5.307e+00,  5.328e+00]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># retrieve window samples if needed so that the time-weighted window can be</span>
    <span class="c1"># calculated</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># retrieve hop length if needed so that the frame times can be calculated</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dtype_r2c</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># calculate window weighted by time</span>
    <span class="n">half_width</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">n_fft</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">window_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">half_width</span><span class="p">,</span> <span class="n">half_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">window_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">half_width</span><span class="p">)</span>

    <span class="n">window_time_weighted</span> <span class="o">=</span> <span class="n">window</span> <span class="o">*</span> <span class="n">window_times</span>

    <span class="n">S_th</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window_time_weighted</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># equation 5.23 of Flandrin, Auger, &amp; Chassande-Mottin 2002</span>
    <span class="c1"># the sign of the correction is reversed in some papers - see Plante,</span>
    <span class="c1"># Meyer, &amp; Ainsworth 1998 pp. 283-284</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">S_th</span> <span class="o">/</span> <span class="n">S_h</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">pad_length</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">pad_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">S_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">pad_length</span>
    <span class="p">)</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">correction</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">correction</span> <span class="o">/</span> <span class="n">sr</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S_h</span>


<div class="viewcode-block" id="reassigned_spectrogram"><a class="viewcode-back" href="../../../generated/librosa.reassigned_spectrogram.html#librosa.reassigned_spectrogram">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">reassigned_spectrogram</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">reassign_frequencies</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">reassign_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ref_power</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">fill_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Time-frequency reassigned spectrogram.</span>

<span class="sd">    The reassignment vectors are calculated using equations 5.20 and 5.23 in</span>
<span class="sd">    [#]_::</span>

<span class="sd">        t_reassigned = t + np.real(S_th/S_h)</span>
<span class="sd">        omega_reassigned = omega - np.imag(S_dh/S_h)</span>

<span class="sd">    where ``S_h`` is the complex STFT calculated using the original window,</span>
<span class="sd">    ``S_dh`` is the complex STFT calculated using the derivative of the original</span>
<span class="sd">    window, and ``S_th`` is the complex STFT calculated using the original window</span>
<span class="sd">    multiplied by the time offset from the window center. See [#]_ for</span>
<span class="sd">    additional algorithms, and [#]_ and [#]_ for history and discussion of the</span>
<span class="sd">    method.</span>

<span class="sd">    .. [#] Flandrin, P., Auger, F., &amp; Chassande-Mottin, E. (2002).</span>
<span class="sd">        Time-Frequency reassignment: From principles to algorithms. In</span>
<span class="sd">        Applications in Time-Frequency Signal Processing (Vol. 10, pp.</span>
<span class="sd">        179-204). CRC Press.</span>

<span class="sd">    .. [#] Fulop, S. A., &amp; Fitz, K. (2006). Algorithms for computing the</span>
<span class="sd">        time-corrected instantaneous frequency (reassigned) spectrogram, with</span>
<span class="sd">        applications. The Journal of the Acoustical Society of America, 119(1),</span>
<span class="sd">        360. doi:10.1121/1.2133000</span>

<span class="sd">    .. [#] Auger, F., Flandrin, P., Lin, Y.-T., McLaughlin, S., Meignen, S.,</span>
<span class="sd">        Oberlin, T., &amp; Wu, H.-T. (2013). Time-Frequency Reassignment and</span>
<span class="sd">        Synchrosqueezing: An Overview. IEEE Signal Processing Magazine, 30(6),</span>
<span class="sd">        32-41. doi:10.1109/MSP.2013.2265316</span>

<span class="sd">    .. [#] Hainsworth, S., Macleod, M. (2003). Time-frequency reassignment: a</span>
<span class="sd">        review and analysis. Tech. Rep. CUED/FINFENG/TR.459, Cambridge</span>
<span class="sd">        University Engineering Department</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)], real-valued</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to ``reassigned_spectrogram``</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to ``win_length // 4``.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to ``n_fft``.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a user-specified window vector of length ``n_fft``</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True`` (default), the signal ``y`` is padded so that frame</span>
<span class="sd">          ``S[:, t]`` is centered at ``y[t * hop_length]``. See `Notes` for</span>
<span class="sd">          recommended usage in this function.</span>
<span class="sd">        - If ``False``, then ``S[:, t]`` begins at ``y[t * hop_length]``.</span>

<span class="sd">    reassign_frequencies : boolean</span>
<span class="sd">        - If ``True`` (default), the returned frequencies will be instantaneous</span>
<span class="sd">          frequency estimates.</span>
<span class="sd">        - If ``False``, the returned frequencies will be a read-only view of the</span>
<span class="sd">          STFT bin frequencies for all frames.</span>

<span class="sd">    reassign_times : boolean</span>
<span class="sd">        - If ``True`` (default), the returned times will be corrected</span>
<span class="sd">          (reassigned) time estimates for each bin.</span>
<span class="sd">        - If ``False``, the returned times will be a read-only view of the STFT</span>
<span class="sd">          frame times for all bins.</span>

<span class="sd">    ref_power : float &gt;= 0 or callable</span>
<span class="sd">        Minimum power threshold for estimating time-frequency reassignments.</span>
<span class="sd">        Any bin with ``np.abs(S[f, t])**2 &lt; ref_power`` will be returned as</span>
<span class="sd">        `np.nan` in both frequency and time, unless ``fill_nan`` is ``True``. If 0</span>
<span class="sd">        is provided, then only bins with zero power will be returned as</span>
<span class="sd">        `np.nan` (unless ``fill_nan=True``).</span>

<span class="sd">    fill_nan : boolean</span>
<span class="sd">        - If ``False`` (default), the frequency and time reassignments for bins</span>
<span class="sd">          below the power threshold provided in ``ref_power`` will be returned as</span>
<span class="sd">          `np.nan`.</span>
<span class="sd">        - If ``True``, the frequency and time reassignments for these bins will</span>
<span class="sd">          be returned as the bin center frequencies and frame times.</span>

<span class="sd">    clip : boolean</span>
<span class="sd">        - If ``True`` (default), estimated frequencies outside the range</span>
<span class="sd">          `[0, 0.5 * sr]` or times outside the range `[0, len(y) / sr]` will be</span>
<span class="sd">          clipped to those ranges.</span>
<span class="sd">        - If ``False``, estimated frequencies and times beyond the bounds of the</span>
<span class="sd">          spectrogram may be returned.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for STFT calculation. Default is inferred to match</span>
<span class="sd">        the precision of the input signal.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freqs, times, mags : np.ndarray [shape=(..., 1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequencies:</span>
<span class="sd">            ``freqs[..., f, t]`` is the frequency for bin ``f``, frame ``t``.</span>
<span class="sd">            If ``reassign_frequencies=False``, this will instead be a read-only array</span>
<span class="sd">            of the same shape containing the bin center frequencies for all frames.</span>

<span class="sd">        Reassigned times:</span>
<span class="sd">            ``times[..., f, t]`` is the time for bin ``f``, frame ``t``.</span>
<span class="sd">            If ``reassign_times=False``, this will instead be a read-only array of</span>
<span class="sd">            the same shape containing the frame times for all bins.</span>

<span class="sd">        Magnitudes from short-time Fourier transform:</span>
<span class="sd">            ``mags[..., f, t]`` is the magnitude for bin ``f``, frame ``t``.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Frequency or time estimates with zero support will produce a</span>
<span class="sd">        divide-by-zero warning, and will be returned as `np.nan` unless</span>
<span class="sd">        ``fill_nan=True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is recommended to use ``center=False`` with this function rather than the</span>
<span class="sd">    librosa default ``True``. Unlike ``stft``, reassigned times are not aligned to</span>
<span class="sd">    the left or center of each frame, so padding the signal does not affect the</span>
<span class="sd">    meaning of the reassigned times. However, reassignment assumes that the</span>
<span class="sd">    energy in each FFT bin is associated with exactly one signal component and</span>
<span class="sd">    impulse event.</span>

<span class="sd">    If ``reassign_times`` is ``False``, the frame times that are returned will be</span>
<span class="sd">    aligned to the left or center of the frame, depending on the value of</span>
<span class="sd">    ``center``. In this case, if ``center`` is ``True``, then ``pad_mode=&quot;wrap&quot;`` is</span>
<span class="sd">    recommended for valid estimation of the instantaneous frequencies in the</span>
<span class="sd">    boundary frames.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; amin = 1e-10</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 64</span>
<span class="sd">    &gt;&gt;&gt; sr = 4000</span>
<span class="sd">    &gt;&gt;&gt; y = 1e-3 * librosa.clicks(times=[0.3], sr=sr, click_duration=1.0,</span>
<span class="sd">    ...                           click_freq=1200.0, length=8000) +\</span>
<span class="sd">    ...     1e-3 * librosa.clicks(times=[1.5], sr=sr, click_duration=0.5,</span>
<span class="sd">    ...                           click_freq=400.0, length=8000) +\</span>
<span class="sd">    ...     1e-3 * librosa.chirp(fmin=200, fmax=1600, sr=sr, duration=2.0) +\</span>
<span class="sd">    ...     1e-6 * np.random.randn(2*sr)</span>
<span class="sd">    &gt;&gt;&gt; freqs, times, mags = librosa.reassigned_spectrogram(y=y, sr=sr,</span>
<span class="sd">    ...                                                     n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; mags_db = librosa.amplitude_to_db(mags, ref=np.max)</span>

<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(mags_db, x_axis=&quot;s&quot;, y_axis=&quot;linear&quot;, sr=sr,</span>
<span class="sd">    ...                          hop_length=n_fft//4, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&quot;Spectrogram&quot;, xlabel=None)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; ax[1].scatter(times, freqs, c=mags_db, cmap=&quot;magma&quot;, alpha=0.1, s=5)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_title(&quot;Reassigned spectrogram&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax, format=&quot;%+2.f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ref_power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;ref_power must be non-negative or callable.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">reassign_frequencies</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;reassign_frequencies or reassign_times must be True.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># frequency and time reassignment if requested</span>
    <span class="k">if</span> <span class="n">reassign_frequencies</span><span class="p">:</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">__reassign_frequencies</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">__reassign_times</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># clean up reassignment issues: divide-by-zero, bins with near-zero power,</span>
    <span class="c1"># and estimates outside the spectrogram bounds</span>

    <span class="c1"># retrieve bin frequencies and frame times to replace missing estimates</span>
    <span class="k">if</span> <span class="n">fill_nan</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reassign_frequencies</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">pad_length</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">pad_length</span> <span class="o">=</span> <span class="n">n_fft</span>

        <span class="n">bin_freqs</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span>
            <span class="n">frames</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">pad_length</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># find bins below the power threshold</span>
    <span class="c1"># reassigned bins with zero power will already be NaN</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="n">ref_power</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">mags</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">mags_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">ref_power</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mags</span><span class="p">))</span>

    <span class="c1"># for reassigned estimates, optionally set thresholded bins to NaN, return</span>
    <span class="c1"># bin frequencies and frame times in place of NaN generated by</span>
    <span class="c1"># divide-by-zero and power threshold, and clip to spectrogram bounds</span>
    <span class="k">if</span> <span class="n">reassign_frequencies</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">mags_low</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">fill_nan</span><span class="p">:</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="n">bin_freqs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">freqs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sr</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">freqs</span><span class="p">)</span>

    <span class="c1"># or if reassignment was not requested, return bin frequencies and frame</span>
    <span class="c1"># times for every cell is the spectrogram</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">bin_freqs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">times</span><span class="p">[</span><span class="n">mags_low</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">fill_nan</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">times</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">frame_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mags</span></div>


<div class="viewcode-block" id="magphase"><a class="viewcode-back" href="../../../generated/librosa.magphase.html#librosa.magphase">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Separate a complex-valued spectrogram D into its magnitude (S)</span>
<span class="sd">    and phase (P) components, so that ``D = S * P``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(..., d, t), dtype=complex]</span>
<span class="sd">        complex-valued spectrogram</span>
<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_mag : np.ndarray [shape=(..., d, t), dtype=real]</span>
<span class="sd">        magnitude of ``D``, raised to ``power``</span>
<span class="sd">    D_phase : np.ndarray [shape=(..., d, t), dtype=complex]</span>
<span class="sd">        ``exp(1.j * phi)`` where ``phi`` is the phase of ``D``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; magnitude, phase = librosa.magphase(D)</span>
<span class="sd">    &gt;&gt;&gt; magnitude</span>
<span class="sd">    array([[5.395e-03, 3.332e-03, ..., 9.862e-07, 1.201e-05],</span>
<span class="sd">           [3.244e-03, 2.690e-03, ..., 9.536e-07, 1.201e-05],</span>
<span class="sd">           ...,</span>
<span class="sd">           [7.523e-05, 3.722e-05, ..., 1.188e-04, 1.031e-03],</span>
<span class="sd">           [7.640e-05, 3.944e-05, ..., 5.180e-04, 1.346e-03]],</span>
<span class="sd">          dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([[ 1.   +0.000e+00j,  1.   +0.000e+00j, ...,</span>
<span class="sd">            -1.   -8.742e-08j, -1.   -8.742e-08j],</span>
<span class="sd">           [-1.   -8.742e-08j, -0.775-6.317e-01j, ...,</span>
<span class="sd">            -0.885-4.648e-01j,  0.472-8.815e-01j],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 1.   -4.342e-12j,  0.028-9.996e-01j, ...,</span>
<span class="sd">            -0.222-9.751e-01j, -0.75 -6.610e-01j],</span>
<span class="sd">           [-1.   -8.742e-08j, -1.   -8.742e-08j, ...,</span>
<span class="sd">             1.   +0.000e+00j,  1.   +0.000e+00j]], dtype=complex64)</span>

<span class="sd">    Or get the phase angle (in radians)</span>

<span class="sd">    &gt;&gt;&gt; np.angle(phase)</span>
<span class="sd">    array([[ 0.000e+00,  0.000e+00, ..., -3.142e+00, -3.142e+00],</span>
<span class="sd">           [-3.142e+00, -2.458e+00, ..., -2.658e+00, -1.079e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-4.342e-12, -1.543e+00, ..., -1.794e+00, -2.419e+00],</span>
<span class="sd">           [-3.142e+00, -3.142e+00, ...,  0.000e+00,  0.000e+00]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">mag</span> <span class="o">**=</span> <span class="n">power</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="phase_vocoder"><a class="viewcode-back" href="../../../generated/librosa.phase_vocoder.html#librosa.phase_vocoder">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Phase vocoder.  Given an STFT matrix D, speed up by a factor of ``rate``</span>

<span class="sd">    Based on the implementation provided by [#]_.</span>

<span class="sd">    This is a simplified implementation, intended primarily for</span>
<span class="sd">    reference and pedagogical purposes.  It makes no attempt to</span>
<span class="sd">    handle transients, and is likely to produce many audible</span>
<span class="sd">    artifacts.  For a higher quality implementation, we recommend</span>
<span class="sd">    the RubberBand library [#]_ and its Python wrapper `pyrubberband`.</span>

<span class="sd">    .. [#] Ellis, D. P. W. &quot;A phase vocoder in Matlab.&quot;</span>
<span class="sd">        Columbia University, 2002.</span>
<span class="sd">        http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/</span>

<span class="sd">    .. [#] https://breakfastquay.com/rubberband/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Play at double speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_fast  = librosa.phase_vocoder(D, rate=2.0, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_fast  = librosa.istft(D_fast, hop_length=512)</span>

<span class="sd">    &gt;&gt;&gt; # Or play at 1/3 speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_slow  = librosa.phase_vocoder(D, rate=1./3, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_slow  = librosa.istft(D_slow, hop_length=512)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(..., d, t), dtype=complex]</span>
<span class="sd">        STFT matrix</span>

<span class="sd">    rate : float &gt; 0 [scalar]</span>
<span class="sd">        Speed-up factor: ``rate &gt; 1`` is faster, ``rate &lt; 1`` is slower.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar] or None</span>
<span class="sd">        The number of samples between successive columns of ``D``.</span>

<span class="sd">        If None, defaults to ``n_fft//4 = (D.shape[0]-1)//2``</span>

<span class="sd">    n_fft : int &gt; 0 or None</span>
<span class="sd">        The number of samples per frame in D.</span>
<span class="sd">        By default (None), this will be inferred from the shape of D.</span>
<span class="sd">        However, if D was constructed using an odd-length window, the correct</span>
<span class="sd">        frame length can be specified here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_stretched : np.ndarray [shape=(..., d, t / rate), dtype=complex]</span>
<span class="sd">        time-stretched STFT</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pyrubberband</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Create an empty output array</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)</span>
    <span class="n">d_stretch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Expected phase advance in each bin</span>
    <span class="n">phi_advance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Phase accumulator; initialize to the first sample</span>
    <span class="n">phase_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Pad 0 columns to simplify boundary logic</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">padding</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_steps</span><span class="p">):</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Weighting for linear magnitude interpolation</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Store to output array</span>
        <span class="n">d_stretch</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_acc</span><span class="p">)</span>

        <span class="c1"># Compute phase advance</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">phi_advance</span>

        <span class="c1"># Wrap to -pi:pi range</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="n">dphase</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dphase</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

        <span class="c1"># Accumulate phase</span>
        <span class="n">phase_acc</span> <span class="o">+=</span> <span class="n">phi_advance</span> <span class="o">+</span> <span class="n">dphase</span>

    <span class="k">return</span> <span class="n">d_stretch</span></div>


<div class="viewcode-block" id="iirt"><a class="viewcode-back" href="../../../generated/librosa.iirt.html#librosa.iirt">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iirt</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">flayout</span><span class="o">=</span><span class="s2">&quot;sos&quot;</span><span class="p">,</span>
    <span class="n">res_type</span><span class="o">=</span><span class="s2">&quot;kaiser_best&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Time-frequency representation using IIR filters</span>

<span class="sd">    This function will return a time-frequency representation</span>
<span class="sd">    using a multirate filter bank consisting of IIR filters. [#]_</span>

<span class="sd">    First, ``y`` is resampled as needed according to the provided ``sample_rates``.</span>

<span class="sd">    Then, a filterbank with with ``n`` band-pass filters is designed.</span>

<span class="sd">    The resampled input signals are processed by the filterbank as a whole.</span>
<span class="sd">    (`scipy.signal.filtfilt` resp. `sosfiltfilt` is used to make the phase linear.)</span>
<span class="sd">    The output of the filterbank is cut into frames.</span>
<span class="sd">    For each band, the short-time mean-square power (STMSP) is calculated by</span>
<span class="sd">    summing ``win_length`` subsequent filtered time samples.</span>

<span class="sd">    When called with the default set of parameters, it will generate the TF-representation</span>
<span class="sd">    (pitch filterbank):</span>

<span class="sd">        * 85 filters with MIDI pitches [24, 108] as ``center_freqs``.</span>
<span class="sd">        * each filter having a bandwidth of one semitone.</span>

<span class="sd">    .. [#] Müller, Meinard.</span>
<span class="sd">           &quot;Information Retrieval for Music and Motion.&quot;</span>
<span class="sd">           Springer Verlag. 2007.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)]</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>
<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>
<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length.</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to ``win_length // 4``.</span>
<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True``, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``D[..., :, t]`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If ``False``, then `D[..., :, t]`` begins at ``y[t * hop_length]``</span>
<span class="sd">    tuning : float [scalar]</span>
<span class="sd">        Tuning deviation from A440 in fractions of a bin.</span>
<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, this function uses zero padding.</span>
<span class="sd">    flayout : string</span>
<span class="sd">        - If `sos` (default), a series of second-order filters is used for filtering with `scipy.signal.sosfiltfilt`.</span>
<span class="sd">          Minimizes numerical precision errors for high-order filters, but is slower.</span>
<span class="sd">        - If `ba`, the standard difference equation is used for filtering with `scipy.signal.filtfilt`.</span>
<span class="sd">          Can be unstable for high-order filters.</span>
<span class="sd">    res_type : string</span>
<span class="sd">        The resampling mode.  See `librosa.resample` for details.</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Additional arguments for `librosa.filters.semitone_filterbank`</span>
<span class="sd">        (e.g., could be used to provide another set of ``center_freqs`` and ``sample_rates``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bands_power : np.ndarray [shape=(..., n, t), dtype=dtype]</span>
<span class="sd">        Short-time mean-square power for the input signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``flayout`` is not None, `ba`, or `sos`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.semitone_filterbank</span>
<span class="sd">    librosa.filters.mr_frequencies</span>
<span class="sd">    librosa.cqt</span>
<span class="sd">    scipy.signal.filtfilt</span>
<span class="sd">    scipy.signal.sosfiltfilt</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;), duration=3)</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.iirt(y))</span>
<span class="sd">    &gt;&gt;&gt; C = np.abs(librosa.cqt(y=y, sr=sr))</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(C, ref=np.max),</span>
<span class="sd">    ...                                y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Constant-Q transform&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(D, ref=np.max),</span>
<span class="sd">    ...                                y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_title(&#39;Semitone spectrogram (iirt)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax, format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">flayout</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="s2">&quot;sos&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Unsupported flayout=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flayout</span><span class="p">))</span>

    <span class="c1"># check audio input</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">padding</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">win_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># get the semitone filterbank</span>
    <span class="n">filterbank_ct</span><span class="p">,</span> <span class="n">sample_rates</span> <span class="o">=</span> <span class="n">semitone_filterbank</span><span class="p">(</span>
        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">flayout</span><span class="o">=</span><span class="n">flayout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="c1"># create three downsampled versions of the audio signal</span>
    <span class="n">y_resampled</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">y_srs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_sr</span> <span class="ow">in</span> <span class="n">y_srs</span><span class="p">:</span>
        <span class="n">y_resampled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">orig_sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">target_sr</span><span class="o">=</span><span class="n">cur_sr</span><span class="p">,</span> <span class="n">res_type</span><span class="o">=</span><span class="n">res_type</span><span class="p">))</span>

    <span class="c1"># Compute the number of frames that will fit. The end may get truncated.</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">win_length</span><span class="p">)</span> <span class="o">//</span> <span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the output array</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Time dimension reduces to n_frames</span>
    <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_frames</span>
    <span class="c1"># Insert a new axis at position -2 for filter response</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">filterbank_ct</span><span class="p">))</span>

    <span class="n">bands_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">bands_power</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cur_sr</span><span class="p">,</span> <span class="n">cur_filter</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">,</span> <span class="n">filterbank_ct</span><span class="p">)):</span>

        <span class="n">slices</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># filter the signal</span>
        <span class="n">cur_sr_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">y_srs</span> <span class="o">==</span> <span class="n">cur_sr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s2">&quot;ba&quot;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span>
                <span class="n">cur_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s2">&quot;sos&quot;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span>
                <span class="n">cur_filter</span><span class="p">,</span> <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">/</span> <span class="n">cur_sr</span>
        <span class="n">hop_length_STMSP</span> <span class="o">=</span> <span class="n">hop_length</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">win_length_STMSP_round</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">win_length</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span>

        <span class="c1"># hop_length_STMSP is used here as a floating-point number.</span>
        <span class="c1"># The discretization happens at the end to avoid accumulated rounding errors.</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">cur_filter_output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">win_length_STMSP_round</span><span class="p">,</span> <span class="n">hop_length_STMSP</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_frames</span><span class="p">:</span>
            <span class="n">min_length</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_frames</span> <span class="o">*</span> <span class="n">hop_length_STMSP</span><span class="p">))</span> <span class="o">+</span> <span class="n">win_length_STMSP_round</span>
            <span class="p">)</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_length</span><span class="p">(</span><span class="n">cur_filter_output</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">min_length</span><span class="p">)</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">cur_filter_output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">win_length_STMSP_round</span><span class="p">,</span>
                <span class="n">hop_length_STMSP</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">start_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[:</span><span class="n">n_frames</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">win_length_STMSP_round</span><span class="p">))</span>

        <span class="n">bands_power</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">cur_filter_output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">bands_power</span></div>


<div class="viewcode-block" id="power_to_db"><a class="viewcode-back" href="../../../generated/librosa.power_to_db.html#librosa.power_to_db">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a power spectrogram (amplitude squared) to decibel (dB) units</span>

<span class="sd">    This computes the scaling ``10 * log10(S / ref)`` in a numerically</span>
<span class="sd">    stable way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input power</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude ``abs(S)`` is scaled relative to ``ref``::</span>

<span class="sd">            10 * log10(S / ref)</span>

<span class="sd">        Zeros in the output correspond to positions where ``S == ref``.</span>

<span class="sd">        If callable, the reference value is computed as ``ref(S)``.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for ``abs(S)`` and ``ref``</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at ``top_db`` below the peak:</span>
<span class="sd">        ``max(10 * log10(S)) - top_db``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        ``S_db ~= 10 * log10(S) - 10 * log10(ref)``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    db_to_power</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get a power spectrogram from a waveform ``y``</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2)</span>
<span class="sd">    array([[-41.809, -41.809, ..., -41.809, -41.809],</span>
<span class="sd">           [-41.809, -41.809, ..., -41.809, -41.809],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-41.809, -41.809, ..., -41.809, -41.809],</span>
<span class="sd">           [-41.809, -41.809, ..., -41.809, -41.809]], dtype=float32)</span>

<span class="sd">    Compute dB relative to peak power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.max)</span>
<span class="sd">    array([[-80., -80., ..., -80., -80.],</span>
<span class="sd">           [-80., -80., ..., -80., -80.],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-80., -80., ..., -80., -80.],</span>
<span class="sd">           [-80., -80., ..., -80., -80.]], dtype=float32)</span>

<span class="sd">    Or compare to median power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.median)</span>
<span class="sd">    array([[16.578, 16.578, ..., 16.578, 16.578],</span>
<span class="sd">           [16.578, 16.578, ..., 16.578, 16.578],</span>
<span class="sd">           ...,</span>
<span class="sd">           [16.578, 16.578, ..., 16.578, 16.578],</span>
<span class="sd">           [16.578, 16.578, ..., 16.578, 16.578]], dtype=float32)</span>

<span class="sd">    And plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; imgpow = librosa.display.specshow(S**2, sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                                   ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgdb = librosa.display.specshow(librosa.power_to_db(S**2, ref=np.max),</span>
<span class="sd">    ...                                  sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Log-Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgpow, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgdb, ax=ax[1], format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;amin must be strictly positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;power_to_db was called on complex input so phase &quot;</span>
            <span class="s2">&quot;information will be discarded. To suppress this warning, &quot;</span>
            <span class="s2">&quot;call power_to_db(np.abs(D)**2) instead.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">log_spec</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">))</span>
    <span class="n">log_spec</span> <span class="o">-=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">ref_value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">top_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_db</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;top_db must be non-negative&quot;</span><span class="p">)</span>
        <span class="n">log_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">log_spec</span><span class="p">,</span> <span class="n">log_spec</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">top_db</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_spec</span></div>


<div class="viewcode-block" id="db_to_power"><a class="viewcode-back" href="../../../generated/librosa.db_to_power.html#librosa.db_to_power">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a dB-scale spectrogram to a power spectrogram.</span>

<span class="sd">    This effectively inverts ``power_to_db``::</span>

<span class="sd">        db_to_power(S_db) ~= ref * 10.0**(S_db / 10)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>
<span class="sd">    ref : number &gt; 0</span>
<span class="sd">        Reference power: output will be scaled by this value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">S_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="amplitude_to_db"><a class="viewcode-back" href="../../../generated/librosa.amplitude_to_db.html#librosa.amplitude_to_db">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an amplitude spectrogram to dB-scaled spectrogram.</span>

<span class="sd">    This is equivalent to ``power_to_db(S**2)``, but is provided for convenience.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input amplitude</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude ``abs(S)`` is scaled relative to ``ref``:</span>
<span class="sd">        ``20 * log10(S / ref)``.</span>
<span class="sd">        Zeros in the output correspond to positions where ``S == ref``.</span>

<span class="sd">        If callable, the reference value is computed as ``ref(S)``.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for ``S`` and ``ref``</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at ``top_db`` below the peak:</span>
<span class="sd">        ``max(20 * log10(S)) - top_db``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        ``S`` measured in dB</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db, db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;amplitude_to_db was called on complex input so phase &quot;</span>
            <span class="s2">&quot;information will be discarded. To suppress this warning, &quot;</span>
            <span class="s2">&quot;call amplitude_to_db(np.abs(S)) instead.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">magnitude</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_value</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="n">amin</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="n">top_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="db_to_amplitude"><a class="viewcode-back" href="../../../generated/librosa.db_to_amplitude.html#librosa.db_to_amplitude">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_amplitude</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a dB-scaled spectrogram to an amplitude spectrogram.</span>

<span class="sd">    This effectively inverts `amplitude_to_db`::</span>

<span class="sd">        db_to_amplitude(S_db) ~= 10.0**(0.5 * (S_db + log10(ref)/10))</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>
<span class="sd">    ref : number &gt; 0</span>
<span class="sd">        Optional reference power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Linear magnitude spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>


<div class="viewcode-block" id="perceptual_weighting"><a class="viewcode-back" href="../../../generated/librosa.perceptual_weighting.html#librosa.perceptual_weighting">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">perceptual_weighting</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perceptual weighting of a power spectrogram::</span>

<span class="sd">        S_p[..., f, :] = frequency_weighting(f, &#39;A&#39;) + 10*log(S[..., f, :] / ref)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(..., d, t)]</span>
<span class="sd">        Power spectrogram</span>
<span class="sd">    frequencies : np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequency for each row of` `S``</span>
<span class="sd">    kind : str</span>
<span class="sd">        The frequency weighting curve to use.</span>
<span class="sd">        e.g. `&#39;A&#39;`, `&#39;B&#39;`, `&#39;C&#39;`, `&#39;D&#39;`, `None or &#39;Z&#39;`</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Additional keyword arguments to `power_to_db`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_p : np.ndarray [shape=(..., d, t)]</span>
<span class="sd">        perceptually weighted version of ``S``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Re-weight a CQT power spectrum, using peak power as reference</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; C = np.abs(librosa.cqt(y, sr=sr, fmin=librosa.note_to_hz(&#39;A1&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(C.shape[0],</span>
<span class="sd">    ...                                 fmin=librosa.note_to_hz(&#39;A1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT = librosa.perceptual_weighting(C**2,</span>
<span class="sd">    ...                                               freqs,</span>
<span class="sd">    ...                                               ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT</span>
<span class="sd">    array([[ -96.528,  -97.101, ..., -108.561, -108.561],</span>
<span class="sd">           [ -95.88 ,  -96.479, ..., -107.551, -107.551],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -65.142,  -53.256, ...,  -80.098,  -80.098],</span>
<span class="sd">           [ -71.542,  -53.197, ...,  -80.311,  -80.311]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(C,</span>
<span class="sd">    ...                                                        ref=np.max),</span>
<span class="sd">    ...                                fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                                y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                                ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Log CQT power&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgp = librosa.display.specshow(perceptual_CQT, y_axis=&#39;cqt_hz&#39;,</span>
<span class="sd">    ...                                 fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                                 x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Perceptually weighted log CQT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax[0], format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgp, ax=ax[1], format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">frequency_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmt"><a class="viewcode-back" href="../../../generated/librosa.fmt.html#librosa.fmt">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">over_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The fast Mellin transform (FMT)</span>

<span class="sd">    The Mellin of a signal `y` is performed by interpolating `y` on an exponential time</span>
<span class="sd">    axis, applying a polynomial window, and then taking the discrete Fourier transform.</span>

<span class="sd">    When the Mellin parameter (beta) is 1/2, it is also known as the scale transform. [#]_</span>
<span class="sd">    The scale transform can be useful for audio analysis because its magnitude is invariant</span>
<span class="sd">    to scaling of the domain (e.g., time stretching or compression).  This is analogous</span>
<span class="sd">    to the magnitude of the Fourier transform being invariant to shifts in the input domain.</span>

<span class="sd">    .. [#] De Sena, Antonio, and Davide Rocchesso.</span>
<span class="sd">        &quot;A fast Mellin and scale transform.&quot;</span>
<span class="sd">        EURASIP Journal on Applied Signal Processing 2007.1 (2007): 75-75.</span>

<span class="sd">    .. [#] Cohen, L.</span>
<span class="sd">        &quot;The scale representation.&quot;</span>
<span class="sd">        IEEE Transactions on Signal Processing 41, no. 12 (1993): 3275-3292.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray, real-valued</span>
<span class="sd">        The input signal(s).  Can be multidimensional.</span>
<span class="sd">        The target axis must contain at least 3 samples.</span>

<span class="sd">    t_min : float &gt; 0</span>
<span class="sd">        The minimum time spacing (in samples).</span>
<span class="sd">        This value should generally be less than 1 to preserve as much information as</span>
<span class="sd">        possible.</span>

<span class="sd">    n_fmt : int &gt; 2 or None</span>
<span class="sd">        The number of scale transform bins to use.</span>
<span class="sd">        If None, then ``n_bins = over_sample * ceil(n * log((n-1)/t_min))`` is taken,</span>
<span class="sd">        where ``n = y.shape[axis]``</span>

<span class="sd">    kind : str</span>
<span class="sd">        The type of interpolation to use when re-sampling the input.</span>
<span class="sd">        See `scipy.interpolate.interp1d` for possible values.</span>

<span class="sd">        Note that the default is to use high-precision (cubic) interpolation.</span>
<span class="sd">        This can be slow in practice; if speed is preferred over accuracy,</span>
<span class="sd">        then consider using ``kind=&#39;linear&#39;``.</span>

<span class="sd">    beta : float</span>
<span class="sd">        The Mellin parameter.  ``beta=0.5`` provides the scale transform.</span>

<span class="sd">    over_sample : float &gt;= 1</span>
<span class="sd">        Over-sampling factor for exponential resampling.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to transform ``y``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_scale : np.ndarray [dtype=complex]</span>
<span class="sd">        The scale transform of ``y`` along the ``axis`` dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if ``n_fmt &lt; 2`` or ``t_min &lt;= 0``</span>
<span class="sd">        or if ``y`` is not finite</span>
<span class="sd">        or if ``y.shape[axis] &lt; 3``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a signal and time-stretch it (with energy normalization)</span>
<span class="sd">    &gt;&gt;&gt; scale = 1.25</span>
<span class="sd">    &gt;&gt;&gt; freq = 3.0</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.linspace(0, 1, num=1024, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.linspace(0, 1, num=int(scale * len(x1)), endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y1 = np.sin(2 * np.pi * freq * x1)</span>
<span class="sd">    &gt;&gt;&gt; y2 = np.sin(2 * np.pi * freq * x2) / np.sqrt(scale)</span>
<span class="sd">    &gt;&gt;&gt; # Verify that the two signals have the same energy</span>
<span class="sd">    &gt;&gt;&gt; np.sum(np.abs(y1)**2), np.sum(np.abs(y2)**2)</span>
<span class="sd">        (255.99999999999997, 255.99999999999969)</span>
<span class="sd">    &gt;&gt;&gt; scale1 = librosa.fmt(y1, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; scale2 = librosa.fmt(y2, n_fmt=512)</span>

<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(y1, label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(y2, linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(xlabel=&#39;time (samples)&#39;, title=&#39;Input signals&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[1].semilogy(np.abs(scale1), label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].semilogy(np.abs(scale2), linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(xlabel=&#39;scale coefficients&#39;, title=&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].legend()</span>

<span class="sd">    &gt;&gt;&gt; # Plot the scale transform of an onset strength autocorrelation</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;choice&#39;))</span>
<span class="sd">    &gt;&gt;&gt; odf = librosa.onset.onset_strength(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Auto-correlate with up to 10 seconds lag</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.autocorrelate(odf, max_size=10 * sr // 512)</span>
<span class="sd">    &gt;&gt;&gt; # Normalize</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.util.normalize(odf_ac, norm=np.inf)</span>
<span class="sd">    &gt;&gt;&gt; # Compute the scale transform</span>
<span class="sd">    &gt;&gt;&gt; odf_ac_scale = librosa.fmt(librosa.util.normalize(odf_ac), n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # Plot the results</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=3)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(odf, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(xlabel=&#39;Time (frames)&#39;, title=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(odf_ac, label=&#39;Onset autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(xlabel=&#39;Lag (frames)&#39;, title=&#39;Onset autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[2].semilogy(np.abs(odf_ac_scale), label=&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set(xlabel=&#39;scale coefficients&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;y.shape[</span><span class="si">{:}</span><span class="s2">]==</span><span class="si">{:}</span><span class="s2"> &lt; 3&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;t_min must be a positive number&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">over_sample</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;over_sample must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="c1"># The base is the maximum ratio between adjacent samples</span>
        <span class="c1"># Since the sample spacing is increasing, this is simply the</span>
        <span class="c1"># ratio between the positions of the last two samples: (n-1)/(n-2)</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_fmt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">n_fmt</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_fmt==</span><span class="si">{:}</span><span class="s2"> &lt; 3&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_fmt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">over_sample</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;y must be finite everywhere&quot;</span><span class="p">)</span>

    <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_base</span><span class="p">)</span>
    <span class="c1"># original grid: signal covers [0, 1).  This range is arbitrary, but convenient.</span>
    <span class="c1"># The final sample is positioned at (n-1)/n, so we omit the endpoint</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># build the interpolator</span>
    <span class="n">f_interp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># build the new sampling grid</span>
    <span class="c1"># exponentially spaced between t_min/n and 1 (exclusive)</span>
    <span class="c1"># we&#39;ll go one past where we need, and drop the last sample</span>
    <span class="c1"># When over-sampling, the last input sample contributions n_over samples.</span>
    <span class="c1"># To keep the spacing consistent, we over-sample by n_over, and then</span>
    <span class="c1"># trim the final samples.</span>
    <span class="n">n_over</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span><span class="p">))</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">num</span><span class="o">=</span><span class="n">n_fmt</span> <span class="o">+</span> <span class="n">n_over</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
    <span class="p">)[:</span><span class="o">-</span><span class="n">n_over</span><span class="p">]</span>

    <span class="c1"># Clean up any rounding errors at the boundaries of the interpolation</span>
    <span class="c1"># The interpolator gets angry if we try to extrapolate, so clipping is necessary here.</span>
    <span class="k">if</span> <span class="n">x_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_min</span> <span class="ow">or</span> <span class="n">x_exp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x_exp</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Make sure that all sample points are unique</span>
    <span class="c1"># This should never happen!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_exp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_exp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Redundant sample positions in Mellin transform&quot;</span><span class="p">)</span>

    <span class="c1"># Resample the signal</span>
    <span class="n">y_res</span> <span class="o">=</span> <span class="n">f_interp</span><span class="p">(</span><span class="n">x_exp</span><span class="p">)</span>

    <span class="c1"># Broadcast the window correctly</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_res</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Apply the window and fft</span>
    <span class="c1"># Normalization is absorbed into the window here for expedience</span>
    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span>
        <span class="n">y_res</span> <span class="o">*</span> <span class="p">((</span><span class="n">x_exp</span> <span class="o">**</span> <span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_fmt</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="pcen"><a class="viewcode-back" href="../../../generated/librosa.pcen.html#librosa.pcen">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pcen</span><span class="p">(</span>
    <span class="n">S</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">gain</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span>
    <span class="n">bias</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">power</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">time_constant</span><span class="o">=</span><span class="mf">0.400</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">max_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_zf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Per-channel energy normalization (PCEN)</span>

<span class="sd">    This function normalizes a time-frequency representation ``S`` by</span>
<span class="sd">    performing automatic gain control, followed by nonlinear compression [#]_ ::</span>

<span class="sd">        P[f, t] = (S / (eps + M[f, t])**gain + bias)**power - bias**power</span>

<span class="sd">    IMPORTANT: the default values of eps, gain, bias, and power match the</span>
<span class="sd">    original publication, in which ``S`` is a 40-band mel-frequency</span>
<span class="sd">    spectrogram with 25 ms windowing, 10 ms frame shift, and raw audio values</span>
<span class="sd">    in the interval [-2**31; 2**31-1[. If you use these default values, we</span>
<span class="sd">    recommend to make sure that the raw audio is properly scaled to this</span>
<span class="sd">    interval, and not to [-1, 1[ as is most often the case.</span>

<span class="sd">    The matrix ``M`` is the result of applying a low-pass, temporal IIR filter</span>
<span class="sd">    to ``S``::</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * S[f, t]</span>

<span class="sd">    If ``b`` is not provided, it is calculated as::</span>

<span class="sd">        b = (sqrt(1 + 4* T**2) - 1) / (2 * T**2)</span>

<span class="sd">    where ``T = time_constant * sr / hop_length``. [#]_</span>

<span class="sd">    This normalization is designed to suppress background noise and</span>
<span class="sd">    emphasize foreground signals, and can be used as an alternative to</span>
<span class="sd">    decibel scaling (`amplitude_to_db`).</span>

<span class="sd">    This implementation also supports smoothing across frequency bins</span>
<span class="sd">    by specifying ``max_size &gt; 1``.  If this option is used, the filtered</span>
<span class="sd">    spectrogram ``M`` is computed as::</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * R[f, t]</span>

<span class="sd">    where ``R`` has been max-filtered along the frequency axis, similar to</span>
<span class="sd">    the SuperFlux algorithm implemented in `onset.onset_strength`::</span>

<span class="sd">        R[f, t] = max(S[f - max_size//2: f + max_size//2, t])</span>

<span class="sd">    This can be used to perform automatic gain control on signals that cross</span>
<span class="sd">    or span multiple frequency bans, which may be desirable for spectrograms</span>
<span class="sd">    with high frequency resolution.</span>

<span class="sd">    .. [#] Wang, Y., Getreuer, P., Hughes, T., Lyon, R. F., &amp; Saurous, R. A.</span>
<span class="sd">       (2017, March). Trainable frontend for robust and far-field keyword spotting.</span>
<span class="sd">       In Acoustics, Speech and Signal Processing (ICASSP), 2017</span>
<span class="sd">       IEEE International Conference on (pp. 5670-5674). IEEE.</span>

<span class="sd">    .. [#] Lostanlen, V., Salamon, J., McFee, B., Cartwright, M., Farnsworth, A.,</span>
<span class="sd">       Kelling, S., and Bello, J. P. Per-Channel Energy Normalization: Why and How.</span>
<span class="sd">       IEEE Signal Processing Letters, 26(1), 39-43.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray (non-negative)</span>
<span class="sd">        The input (magnitude) spectrogram</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        The audio sampling rate</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        The hop length of ``S``, expressed in samples</span>

<span class="sd">    gain : number &gt;= 0 [scalar]</span>
<span class="sd">        The gain factor.  Typical values should be slightly less than 1.</span>

<span class="sd">    bias : number &gt;= 0 [scalar]</span>
<span class="sd">        The bias point of the nonlinear compression (default: 2)</span>

<span class="sd">    power : number &gt;= 0 [scalar]</span>
<span class="sd">        The compression exponent.  Typical values should be between 0 and 0.5.</span>
<span class="sd">        Smaller values of ``power`` result in stronger compression.</span>
<span class="sd">        At the limit ``power=0``, polynomial compression becomes logarithmic.</span>

<span class="sd">    time_constant : number &gt; 0 [scalar]</span>
<span class="sd">        The time constant for IIR filtering, measured in seconds.</span>

<span class="sd">    eps : number &gt; 0 [scalar]</span>
<span class="sd">        A small constant used to ensure numerical stability of the filter.</span>

<span class="sd">    b : number in [0, 1]  [scalar]</span>
<span class="sd">        The filter coefficient for the low-pass filter.</span>
<span class="sd">        If not provided, it will be inferred from ``time_constant``.</span>

<span class="sd">    max_size : int &gt; 0 [scalar]</span>
<span class="sd">        The width of the max filter applied to the frequency axis.</span>
<span class="sd">        If left as `1`, no filtering is performed.</span>

<span class="sd">    ref : None or np.ndarray (shape=S.shape)</span>
<span class="sd">        An optional pre-computed reference spectrum (``R`` in the above).</span>
<span class="sd">        If not provided it will be computed from ``S``.</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The (time) axis of the input spectrogram.</span>

<span class="sd">    max_axis : None or int [scalar]</span>
<span class="sd">        The frequency axis of the input spectrogram.</span>
<span class="sd">        If `None`, and ``S`` is two-dimensional, it will be inferred</span>
<span class="sd">        as the opposite from ``axis``.</span>
<span class="sd">        If ``S`` is not two-dimensional, and ``max_size &gt; 1``, an error</span>
<span class="sd">        will be raised.</span>

<span class="sd">    zi : np.ndarray</span>
<span class="sd">        The initial filter delay values.</span>

<span class="sd">        This may be the ``zf`` (final delay values) of a previous call to ``pcen``, or</span>
<span class="sd">        computed by `scipy.signal.lfilter_zi`.</span>

<span class="sd">    return_zf : bool</span>
<span class="sd">        If ``True``, return the final filter delay values along with the PCEN output ``P``.</span>
<span class="sd">        This is primarily useful in streaming contexts, where the final state of one</span>
<span class="sd">        block of processing should be used to initialize the next block.</span>

<span class="sd">        If ``False`` (default) only the PCEN values ``P`` are returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.ndarray, non-negative [shape=(n, m)]</span>
<span class="sd">        The per-channel energy normalized version of ``S``.</span>
<span class="sd">    zf : np.ndarray (optional)</span>
<span class="sd">        The final filter delay values.  Only returned if ``return_zf=True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    librosa.onset.onset_strength</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare PCEN to log amplitude (dB) scaling on Mel spectra</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;robin&#39;))</span>

<span class="sd">    &gt;&gt;&gt; # We recommend scaling y to the range [-2**31, 2**31[ before applying</span>
<span class="sd">    &gt;&gt;&gt; # PCEN&#39;s default parameters. Furthermore, we use power=1 to get a</span>
<span class="sd">    &gt;&gt;&gt; # magnitude spectrum instead of a power spectrum.</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, power=1)</span>
<span class="sd">    &gt;&gt;&gt; log_S = librosa.amplitude_to_db(S, ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; pcen_S = librosa.pcen(S * (2**31))</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(log_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;log amplitude (dB)&#39;, xlabel=None)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgpcen = librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Per-channel energy normalization&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax[0], format=&quot;%+2.0f dB&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgpcen, ax=ax[1])</span>

<span class="sd">    Compare PCEN with and without max-filtering</span>

<span class="sd">    &gt;&gt;&gt; pcen_max = librosa.pcen(S * (2**31), max_size=3)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Per-channel energy normalization (no max-filter)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(pcen_max, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Per-channel energy normalization (max_size=3)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;power=</span><span class="si">{}</span><span class="s2"> must be nonnegative&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">power</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">gain</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;gain=</span><span class="si">{}</span><span class="s2"> must be non-negative&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gain</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">bias</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;bias=</span><span class="si">{}</span><span class="s2"> must be non-negative&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bias</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;eps=</span><span class="si">{}</span><span class="s2"> must be strictly positive&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">time_constant</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;time_constant=</span><span class="si">{}</span><span class="s2"> must be strictly positive&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_constant</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;max_size=</span><span class="si">{}</span><span class="s2"> must be a positive integer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_frames</span> <span class="o">=</span> <span class="n">time_constant</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">)</span>
        <span class="c1"># By default, this solves the equation for b:</span>
        <span class="c1">#   b**2  + (1 - b) / t_frames  - 2 = 0</span>
        <span class="c1"># which approximates the full-width half-max of the</span>
        <span class="c1"># squared frequency response of the IIR low-pass filter</span>

        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">t_frames</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t_frames</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;b=</span><span class="si">{}</span><span class="s2"> must be between 0 and 1&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;pcen was called on complex input so phase &quot;</span>
            <span class="s2">&quot;information will be discarded. To suppress this warning, &quot;</span>
            <span class="s2">&quot;call pcen(np.abs(D)) instead.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">elif</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Max-filtering cannot be applied to 1-dimensional input&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                        <span class="s2">&quot;Max-filtering a </span><span class="si">{:d}</span><span class="s2">-dimensional spectrogram &quot;</span>
                        <span class="s2">&quot;requires you to specify max_axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="c1"># if axis = 0, max_axis=1</span>
                <span class="c1"># if axis = +- 1, max_axis = 0</span>
                <span class="n">max_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">maximum_filter1d</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">max_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Make sure zi matches dimension to input</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">zi</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter_zi</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[:]</span>

    <span class="c1"># Temporal integration</span>
    <span class="n">S_smooth</span><span class="p">,</span> <span class="n">zf</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ref</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Adaptive gain control</span>
    <span class="c1"># Working in log-space gives us some stability, and a slight speedup</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S_smooth</span> <span class="o">/</span> <span class="n">eps</span><span class="p">)))</span>

    <span class="c1"># Dynamic range compression</span>
    <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">smooth</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">smooth</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">bias</span> <span class="o">**</span> <span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">smooth</span> <span class="o">/</span> <span class="n">bias</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">return_zf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S_out</span><span class="p">,</span> <span class="n">zf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S_out</span></div>


<div class="viewcode-block" id="griffinlim"><a class="viewcode-back" href="../../../generated/librosa.griffinlim.html#librosa.griffinlim">[docs]</a><span class="nd">@deprecate_positional_args</span>
<span class="k">def</span> <span class="nf">griffinlim</span><span class="p">(</span>
    <span class="n">S</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">momentum</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>
    <span class="n">init</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Approximate magnitude spectrogram inversion using the &quot;fast&quot; Griffin-Lim algorithm.</span>

<span class="sd">    Given a short-time Fourier transform magnitude matrix (``S``), the algorithm randomly</span>
<span class="sd">    initializes phase estimates, and then alternates forward- and inverse-STFT</span>
<span class="sd">    operations. [#]_</span>

<span class="sd">    Note that this assumes reconstruction of a real-valued time-domain signal, and</span>
<span class="sd">    that ``S`` contains only the non-negative frequencies (as computed by</span>
<span class="sd">    `stft`).</span>

<span class="sd">    The &quot;fast&quot; GL method [#]_ uses a momentum parameter to accelerate convergence.</span>

<span class="sd">    .. [#] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    .. [#] Perraudin, N., Balazs, P., &amp; Søndergaard, P. L.</span>
<span class="sd">        &quot;A fast Griffin-Lim algorithm,&quot;</span>
<span class="sd">        IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (pp. 1-4),</span>
<span class="sd">        Oct. 2013.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(..., n_fft // 2 + 1, t), non-negative]</span>
<span class="sd">        An array of short-time Fourier transform magnitudes as produced by</span>
<span class="sd">        `stft`.</span>

<span class="sd">    n_iter : int &gt; 0</span>
<span class="sd">        The number of iterations to run</span>

<span class="sd">    hop_length : None or int &gt; 0</span>
<span class="sd">        The hop length of the STFT.  If not provided, it will default to ``n_fft // 4``</span>

<span class="sd">    win_length : None or int &gt; 0</span>
<span class="sd">        The window length of the STFT.  By default, it will equal ``n_fft``</span>

<span class="sd">    n_fft : None or int &gt; 0</span>
<span class="sd">        The number of samples per frame.</span>
<span class="sd">        By default, this will be inferred from the shape of ``S`` as an even number.</span>
<span class="sd">        However, if an odd frame length was used, you can explicitly set ``n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        A window specification as supported by `stft` or `istft`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        If ``True``, the STFT is assumed to use centered frames.</span>
<span class="sd">        If ``False``, the STFT is assumed to use left-aligned frames.</span>

<span class="sd">    dtype : np.dtype</span>
<span class="sd">        Real numeric type for the time-domain signal.  Default is inferred</span>
<span class="sd">        to match the precision of the input spectrogram.</span>

<span class="sd">    length : None or int &gt; 0</span>
<span class="sd">        If provided, the output ``y`` is zero-padded or clipped to exactly ``length``</span>
<span class="sd">        samples.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    momentum : number &gt;= 0</span>
<span class="sd">        The momentum parameter for fast Griffin-Lim.</span>
<span class="sd">        Setting this to 0 recovers the original Griffin-Lim method [1]_.</span>
<span class="sd">        Values near 1 can lead to faster convergence, but above 1 may not converge.</span>

<span class="sd">    init : None or &#39;random&#39; [default]</span>
<span class="sd">        If &#39;random&#39; (the default), then phase values are initialized randomly</span>
<span class="sd">        according to ``random_state``.  This is recommended when the input ``S`` is</span>
<span class="sd">        a magnitude spectrogram with no initial phase estimates.</span>

<span class="sd">        If `None`, then the phase is initialized from ``S``.  This is useful when</span>
<span class="sd">        an initial guess for phase can be provided, or when you want to resume</span>
<span class="sd">        Griffin-Lim from a previous output.</span>

<span class="sd">    random_state : None, int, or np.random.RandomState</span>
<span class="sd">        If int, random_state is the seed used by the random number generator</span>
<span class="sd">        for phase initialization.</span>

<span class="sd">        If `np.random.RandomState` instance, the random number</span>
<span class="sd">        generator itself.</span>

<span class="sd">        If `None`, defaults to the current `np.random` object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)]</span>
<span class="sd">        time-domain signal reconstructed from ``S``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft</span>
<span class="sd">    istft</span>
<span class="sd">    magphase</span>
<span class="sd">    filters.get_window</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A basic STFT inverse example</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; # Get the magnitude spectrogram</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; # Invert using Griffin-Lim</span>
<span class="sd">    &gt;&gt;&gt; y_inv = librosa.griffinlim(S)</span>
<span class="sd">    &gt;&gt;&gt; # Invert without estimating phase</span>
<span class="sd">    &gt;&gt;&gt; y_istft = librosa.istft(S)</span>

<span class="sd">    Wave-plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=3, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveshow(y, sr=sr, color=&#39;b&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Original&#39;, xlabel=None)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveshow(y_inv, sr=sr, color=&#39;g&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Griffin-Lim reconstruction&#39;, xlabel=None)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveshow(y_istft, sr=sr, color=&#39;r&#39;, ax=ax[2])</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set_title(&#39;Magnitude-only istft reconstruction&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">random_state</span>

    <span class="k">if</span> <span class="n">momentum</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Griffin-Lim with momentum=</span><span class="si">{}</span><span class="s2"> &gt; 1 can be unstable. &quot;</span>
            <span class="s2">&quot;Proceed with caution!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">momentum</span><span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;griffinlim() called with momentum=</span><span class="si">{}</span><span class="s2"> &lt; 0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">momentum</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Infer n_fft from the spectrogram shape</span>
    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># using complex64 will keep the result to minimal necessary precision</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">tiny</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="c1"># randomly initialize the phase</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Initialize an all ones complex matrix</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;init=</span><span class="si">{}</span><span class="s2"> must either None or &#39;random&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init</span><span class="p">))</span>

    <span class="c1"># And initialize the previous iterate to 0</span>
    <span class="n">rebuilt</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
        <span class="c1"># Store the previous iterate</span>
        <span class="n">tprev</span> <span class="o">=</span> <span class="n">rebuilt</span>

        <span class="c1"># Invert with our current estimate of the phases</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">istft</span><span class="p">(</span>
            <span class="n">S</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Rebuild the spectrogram</span>
        <span class="n">rebuilt</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">inverse</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update our phase estimates</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">rebuilt</span> <span class="o">-</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">momentum</span><span class="p">))</span> <span class="o">*</span> <span class="n">tprev</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>

    <span class="c1"># Return the final phase estimates</span>
    <span class="k">return</span> <span class="n">istft</span><span class="p">(</span>
        <span class="n">S</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_spectrogram</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to retrieve a magnitude spectrogram.</span>

<span class="sd">    This is primarily used in feature extraction functions that can operate on</span>
<span class="sd">    either audio time-series or spectrogram input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : None or np.ndarray</span>
<span class="sd">        If provided, an audio time series</span>

<span class="sd">    S : None or np.ndarray</span>
<span class="sd">        Spectrogram input, optional</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        STFT window size</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        STFT hop length</span>

<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by ``window``.</span>
<span class="sd">        The window will be of length ``win_length`` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If ``True``, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If ``False``, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray [dtype=np.float]</span>
<span class="sd">        - If ``S`` is provided as input, then ``S_out == S``</span>
<span class="sd">        - Else, ``S_out = |stft(y, ...)|**power``</span>
<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        - If ``S`` is provided, then ``n_fft`` is inferred from ``S``</span>
<span class="sd">        - Else, copied from input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Infer n_fft from spectrogram shape, but only if it mismatches</span>
        <span class="k">if</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute a magnitude spectrogram from input</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">stft</span><span class="p">(</span>
                    <span class="n">y</span><span class="p">,</span>
                    <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                    <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                    <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                    <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                    <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">**</span> <span class="n">power</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span>
</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: main
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Releases</dt>
      <dd><a href="../../../../0.7.2/index.html">0.7.2</a></dd>
      <dd><a href="../../../../0.8.1/index.html">0.8.1</a></dd>
      <dd><a href="../../../../0.9.0/index.html">0.9.0</a></dd>
      <dd><a href="../../../../0.9.1/index.html">0.9.1</a></dd>
    </dl>
    <dl>
      <dt>Development versions</dt>
      <dd><a href="spectrum.html">main</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>