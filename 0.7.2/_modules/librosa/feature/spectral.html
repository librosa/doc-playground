<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.feature.spectral &mdash; librosa 0.7.2 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html">
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>librosa.feature.spectral</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             

<div class="admonition danger">
    <p class="admonition-title"> Caution </p>
  <p>
    
        
            You're reading an old version of this documentation.
            If you want up-to-date information, please have a look at <a href="../../../../0.9.1/index.html">0.9.1</a>.
        
    
  </p>
</div>


  <h1>Source code for librosa.feature.spectral</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Spectral feature extraction&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>

<span class="kn">from</span> <span class="nn">..core.time_frequency</span> <span class="kn">import</span> <span class="n">fft_frequencies</span>
<span class="kn">from</span> <span class="nn">..core.audio</span> <span class="kn">import</span> <span class="n">zero_crossings</span><span class="p">,</span> <span class="n">to_mono</span>
<span class="kn">from</span> <span class="nn">..core.spectrum</span> <span class="kn">import</span> <span class="n">power_to_db</span><span class="p">,</span> <span class="n">_spectrogram</span>
<span class="kn">from</span> <span class="nn">..core.constantq</span> <span class="kn">import</span> <span class="n">cqt</span><span class="p">,</span> <span class="n">hybrid_cqt</span>
<span class="kn">from</span> <span class="nn">..core.pitch</span> <span class="kn">import</span> <span class="n">estimate_tuning</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spectral_centroid&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_bandwidth&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_contrast&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_rolloff&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_flatness&#39;</span><span class="p">,</span>
           <span class="s1">&#39;poly_features&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rms&#39;</span><span class="p">,</span>
           <span class="s1">&#39;zero_crossing_rate&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_stft&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_cqt&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_cens&#39;</span><span class="p">,</span>
           <span class="s1">&#39;melspectrogram&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mfcc&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tonnetz&#39;</span><span class="p">]</span>


<span class="c1"># -- Spectral features -- #</span>
<div class="viewcode-block" id="spectral_centroid"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_centroid.html#librosa.feature.spectral_centroid">[docs]</a><span class="k">def</span> <span class="nf">spectral_centroid</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                      <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the spectral centroid.</span>

<span class="sd">    Each frame of a magnitude spectrogram is normalized and treated as a</span>
<span class="sd">    distribution over frequency bins, from which the mean (centroid) is</span>
<span class="sd">    extracted per frame.</span>

<span class="sd">    More precisely, the centroid at frame `t` is defined as [1]_:</span>

<span class="sd">        ``centroid[t] = sum_k S[k, t] * freq[k] / (sum_j S[j, t])``</span>

<span class="sd">    where `S` is a magnitude spectrogram, and `freq` is the array of</span>
<span class="sd">    frequencies (e.g., FFT frequencies in Hz) of the rows of `S`.</span>

<span class="sd">    .. [1] Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing</span>
<span class="sd">        methods for music transcription, chapter 5. </span>
<span class="sd">        Springer Science &amp; Business Media.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centroid : np.ndarray [shape=(1, t)]</span>
<span class="sd">        centroid frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.core.stft</span>
<span class="sd">        Short-time Fourier Transform</span>

<span class="sd">    librosa.core.ifgram</span>
<span class="sd">        Instantaneous-frequency spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; cent = librosa.feature.spectral_centroid(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; cent</span>
<span class="sd">    array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>

<span class="sd">    From spectrogram input:</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=S)</span>
<span class="sd">    array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>

<span class="sd">    Using variable bin center frequencies:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; if_gram, D = librosa.ifgram(y)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=np.abs(D), freq=if_gram)</span>
<span class="sd">    array([[ 4420.719,   625.769, ...,  5011.86 ,  5221.492]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(cent.T, label=&#39;Spectral centroid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, cent.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral centroid is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral centroid is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_bandwidth"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_bandwidth.html#librosa.feature.spectral_bandwidth">[docs]</a><span class="k">def</span> <span class="nf">spectral_bandwidth</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                       <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                       <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute p&#39;th-order spectral bandwidth.</span>

<span class="sd">       The spectral bandwidth [1]_ at frame `t` is computed by</span>

<span class="sd">        (sum_k S[k, t] * (freq[k, t] - centroid[t])**p)**(1/p)</span>

<span class="sd">    .. [1] Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing</span>
<span class="sd">        methods for music transcription, chapter 5.</span>
<span class="sd">        Springer Science &amp; Business Media.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    centroid : None or np.ndarray [shape=(1, t)]</span>
<span class="sd">        pre-computed centroid frequencies</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize per-frame spectral energy (sum to one)</span>

<span class="sd">    p : float &gt; 0</span>
<span class="sd">        Power to raise deviation from spectral centroid.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bandwidth : np.ndarray [shape=(1, t)]</span>
<span class="sd">        frequency bandwidth for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; spec_bw = librosa.feature.spectral_bandwidth(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; spec_bw</span>
<span class="sd">    array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=S)</span>
<span class="sd">    array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>

<span class="sd">    Using variable bin center frequencies</span>

<span class="sd">    &gt;&gt;&gt; if_gram, D = librosa.ifgram(y)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=np.abs(D), freq=if_gram)</span>
<span class="sd">    array([[ 3380.011,  1429.11 , ...,  3235.22 ,  3080.148]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(spec_bw.T, label=&#39;Spectral bandwidth&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, spec_bw.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral bandwidth is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral bandwidth is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">spectral_centroid</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
                                     <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                     <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                     <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">deviation</span><span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_contrast"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_contrast.html#librosa.feature.spectral_contrast">[docs]</a><span class="k">def</span> <span class="nf">spectral_contrast</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                      <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                      <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span> <span class="n">n_bands</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
                      <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute spectral contrast [1]_</span>

<span class="sd">    Each frame of a spectrogram `S` is divided into sub-bands.</span>
<span class="sd">    For each sub-band, the energy contrast is estimated by comparing</span>
<span class="sd">    the mean energy in the top quantile (peak energy) to that of the </span>
<span class="sd">    bottom quantile (valley energy).  High contrast values generally</span>
<span class="sd">    correspond to clear, narrow-band signals, while low contrast values</span>
<span class="sd">    correspond to broad-band noise.</span>

<span class="sd">    .. [1] Jiang, Dan-Ning, Lie Lu, Hong-Jiang Zhang, Jian-Hua Tao,</span>
<span class="sd">           and Lian-Hong Cai.</span>
<span class="sd">           &quot;Music type classification by spectral contrast feature.&quot;</span>
<span class="sd">           In Multimedia and Expo, 2002. ICME&#39;02. Proceedings.</span>
<span class="sd">           2002 IEEE International Conference on, vol. 1, pp. 113-116.</span>
<span class="sd">           IEEE, 2002.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number  &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies.</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        Frequency cutoff for the first bin `[0, fmin]`</span>
<span class="sd">        Subsequent bins will cover `[fmin, 2*fmin]`, `[2*fmin, 4*fmin]`, etc.</span>

<span class="sd">    n_bands : int &gt; 1</span>
<span class="sd">        number of frequency bands</span>

<span class="sd">    quantile : float in (0, 1)</span>
<span class="sd">        quantile for determining peaks and valleys</span>

<span class="sd">    linear : bool</span>
<span class="sd">        If `True`, return the linear difference of magnitudes:</span>
<span class="sd">        `peaks - valleys`.</span>

<span class="sd">        If `False`, return the logarithmic difference:</span>
<span class="sd">        `log(peaks) - log(valleys)`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contrast : np.ndarray [shape=(n_bands + 1, t)]</span>
<span class="sd">        each row of spectral contrast values corresponds to a given</span>
<span class="sd">        octave-based frequency</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; contrast = librosa.feature.spectral_contrast(S=S, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(contrast, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency bands&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Spectral contrast&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;freq.shape mismatch: expected &#39;</span>
                             <span class="s1">&#39;(</span><span class="si">{:d}</span><span class="s1">,)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">n_bands</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_bands</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_bands must be a positive integer&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;quantile must lie in the range (0, 1)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;fmin must be a positive number&#39;</span><span class="p">)</span>

    <span class="n">octa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Frequency band exceeds Nyquist. &#39;</span>
                             <span class="s1">&#39;Reduce either fmin or n_bands.&#39;</span><span class="p">)</span>

    <span class="n">valley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="n">current_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">f_low</span><span class="p">,</span> <span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">f_high</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">current_band</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sub_band</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">current_band</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">sub_band</span> <span class="o">=</span> <span class="n">sub_band</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Always take at least one bin from each side</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">quantile</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_band</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">sortedr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_band</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">valley</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">peak</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">valley</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="o">-</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_rolloff"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_rolloff.html#librosa.feature.spectral_rolloff">[docs]</a><span class="k">def</span> <span class="nf">spectral_rolloff</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                     <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                     <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">roll_percent</span><span class="o">=</span><span class="mf">0.85</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute roll-off frequency.</span>

<span class="sd">    The roll-off frequency is defined for each frame as the center frequency</span>
<span class="sd">    for a spectrogram bin such that at least roll_percent (0.85 by default)</span>
<span class="sd">    of the energy of the spectrum in this frame is contained in this bin and</span>
<span class="sd">    the bins below. This can be used to, e.g., approximate the maximum (or</span>
<span class="sd">    minimum) frequency by setting roll_percent to a value close to 1 (or 0).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>

<span class="sd">        .. note:: `freq` is assumed to be sorted in increasing order</span>

<span class="sd">    roll_percent : float [0 &lt; roll_percent &lt; 1]</span>
<span class="sd">        Roll-off percentage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rolloff : np.ndarray [shape=(1, t)]</span>
<span class="sd">        roll-off frequency for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; # Approximate maximum frequencies with roll_percent=0.85 (default)</span>
<span class="sd">    &gt;&gt;&gt; rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; rolloff</span>
<span class="sd">    array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>
<span class="sd">    &gt;&gt;&gt; # Approximate minimum frequencies with roll_percent=0.1</span>
<span class="sd">    &gt;&gt;&gt; rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.1)</span>
<span class="sd">    &gt;&gt;&gt; rolloff</span>
<span class="sd">    array([[ 75.36621094,  64.59960938,  64.59960938, ...,  75.36621094,</span>
<span class="sd">         75.36621094,  64.59960938]])</span>


<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(S=S, sr=sr)</span>
<span class="sd">    array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>

<span class="sd">    &gt;&gt;&gt; # With a higher roll percentage:</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.95)</span>
<span class="sd">    array([[ 10012.939,   3003.882, ...,  10034.473,  10077.539]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(rolloff.T, label=&#39;Roll-off frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, rolloff.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">roll_percent</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;roll_percent must lie in the range (0, 1)&#39;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral rolloff is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral rolloff is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Make sure that frequency can be broadcast</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">total_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">roll_percent</span> <span class="o">*</span> <span class="n">total_energy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_energy</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">ind</span> <span class="o">*</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_flatness"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_flatness.html#librosa.feature.spectral_flatness">[docs]</a><span class="k">def</span> <span class="nf">spectral_flatness</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                      <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                      <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute spectral flatness</span>

<span class="sd">    Spectral flatness (or tonality coefficient) is a measure to</span>
<span class="sd">    quantify how much noise-like a sound is, as opposed to being</span>
<span class="sd">    tone-like [1]_. A high spectral flatness (closer to 1.0)</span>
<span class="sd">    indicates the spectrum is similar to white noise.</span>
<span class="sd">    It is often converted to decibel.</span>

<span class="sd">    .. [1] Dubnov, Shlomo  &quot;Generalization of spectral flatness</span>
<span class="sd">           measure for non-gaussian linear processes&quot;</span>
<span class="sd">           IEEE Signal Processing Letters, 2004, Vol. 11.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) pre-computed spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for `S` (=added noise floor for numerical stability)</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the magnitude spectrogram.</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>
<span class="sd">        Power spectrogram is usually used for computing spectral flatness.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flatness : np.ndarray [shape=(1, t)]</span>
<span class="sd">        spectral flatness for each frame.</span>
<span class="sd">        The returned value is in [0, 1] and often converted to dB scale.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; flatness = librosa.feature.spectral_flatness(y=y)</span>
<span class="sd">    &gt;&gt;&gt; flatness</span>
<span class="sd">    array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="sd">          1.00000e+00,   1.00000e+00]], dtype=float32)</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_flatness(S=S)</span>
<span class="sd">    array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="sd">          1.00000e+00,   1.00000e+00]], dtype=float32)</span>

<span class="sd">    From power spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; S_power = S ** 2</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_flatness(S=S_power, power=1.0)</span>
<span class="sd">    array([[  1.00000e+00,   5.82299e-03,   5.64624e-04, ...,   9.99063e-01,</span>
<span class="sd">          1.00000e+00,   1.00000e+00]], dtype=float32)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;amin must be strictly positive&#39;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">power</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral flatness is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral flatness is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="n">S_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">S</span> <span class="o">**</span> <span class="n">power</span><span class="p">)</span>
    <span class="n">gmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">amean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gmean</span> <span class="o">/</span> <span class="n">amean</span></div>


<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../../../generated/librosa.feature.rms.html#librosa.feature.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute root-mean-square (RMS) value for each frame, either from the</span>
<span class="sd">    audio samples `y` or from a spectrogram `S`.</span>

<span class="sd">    Computing the RMS value from audio samples is faster as it doesn&#39;t require</span>
<span class="sd">    a STFT calculation. However, using a spectrogram will give a more accurate</span>
<span class="sd">    representation of energy over time because its frames can be windowed,</span>
<span class="sd">    thus prefer using `S` if it&#39;s already available.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        (optional) audio time series. Required if `S` is not input.</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude. Required if `y` is not input.</span>

<span class="sd">    frame_length : int &gt; 0 [scalar]</span>
<span class="sd">        length of analysis frame (in samples) for energy calculation</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True` and operating on time-domain input (`y`), pad the signal</span>
<span class="sd">        by `frame_length//2` on either side.</span>

<span class="sd">        If operating on spectrogram input, this has no effect.</span>

<span class="sd">    pad_mode : str</span>
<span class="sd">        Padding mode for centered analysis.  See `np.pad` for valid</span>
<span class="sd">        values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : np.ndarray [shape=(1, t)]</span>
<span class="sd">        RMS value for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rms(y=y)</span>
<span class="sd">    array([[ 0.   ,  0.056, ...,  0.   ,  0.   ]], dtype=float32)</span>

<span class="sd">    Or from spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; rms = librosa.feature.rms(S=S)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(rms.T, label=&#39;RMS Energy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, rms.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    Use a STFT window of constant ones and no frame centering to get consistent</span>
<span class="sd">    results with the RMS computed from the audio samples `y`</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rms(S=S)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either `y` or `S` should be input.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">to_mono</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span>
                       <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span>
                       <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check the frame length</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                    <span class="s1">&#39;Since S.shape[0] is </span><span class="si">{}</span><span class="s1">, &#39;</span>
                    <span class="s1">&#39;frame_length is expected to be </span><span class="si">{}</span><span class="s1"> or </span><span class="si">{}</span><span class="s1">; &#39;</span>
                    <span class="s1">&#39;found </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">frame_length</span><span class="p">))</span>

        <span class="c1"># power spectrogram</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Adjust the DC and sr/2 component</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="n">frame_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_length</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either `y` or `S` must be input.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">power</span><span class="p">)</span></div>


<div class="viewcode-block" id="poly_features"><a class="viewcode-back" href="../../../generated/librosa.feature.poly_features.html#librosa.feature.poly_features">[docs]</a><span class="k">def</span> <span class="nf">poly_features</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                  <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                  <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Get coefficients of fitting an nth-order polynomial to the columns</span>
<span class="sd">    of a spectrogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    order : int &gt; 0</span>
<span class="sd">        order of the polynomial to fit</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients : np.ndarray [shape=(order+1, t)]</span>
<span class="sd">        polynomial coefficients for each frame.</span>

<span class="sd">        `coeffecients[0]` corresponds to the highest degree (`order`),</span>

<span class="sd">        `coefficients[1]` corresponds to the next highest degree (`order-1`),</span>

<span class="sd">        down to the constant term `coefficients[order]`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>

<span class="sd">    Fit a degree-0 polynomial (constant) to each frame</span>

<span class="sd">    &gt;&gt;&gt; p0 = librosa.feature.poly_features(S=S, order=0)</span>

<span class="sd">    Fit a linear polynomial to each frame</span>

<span class="sd">    &gt;&gt;&gt; p1 = librosa.feature.poly_features(S=S, order=1)</span>

<span class="sd">    Fit a quadratic to each frame</span>

<span class="sd">    &gt;&gt;&gt; p2 = librosa.feature.poly_features(S=S, order=2)</span>

<span class="sd">    Plot the results for comparison</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 8))</span>
<span class="sd">    &gt;&gt;&gt; ax = plt.subplot(4,1,1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[2], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p1[1], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p0[0], label=&#39;order=0&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Constant&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,2, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[1], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p1[0], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Linear&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,3, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[0], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Quadratic&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,4, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># If frequencies are constant over frames, then we only need to fit once</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, fit each frame independently and stack the results</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">)]</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">coefficients</span></div>


<div class="viewcode-block" id="zero_crossing_rate"><a class="viewcode-back" href="../../../generated/librosa.feature.zero_crossing_rate.html#librosa.feature.zero_crossing_rate">[docs]</a><span class="k">def</span> <span class="nf">zero_crossing_rate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the zero-crossing rate of an audio time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        Audio time series</span>

<span class="sd">    frame_length : int &gt; 0</span>
<span class="sd">        Length of the frame over which to compute zero crossing rates</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        Number of samples to advance for each frame</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True`, frames are centered by padding the edges of `y`.</span>
<span class="sd">        This is similar to the padding in `librosa.core.stft`,</span>
<span class="sd">        but uses edge-value copies instead of reflection.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        See `librosa.core.zero_crossings`</span>

<span class="sd">        .. note:: By default, the `pad` parameter is set to `False`, which</span>
<span class="sd">            differs from the default specified by</span>
<span class="sd">            `librosa.core.zero_crossings`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zcr : np.ndarray [shape=(1, t)]</span>
<span class="sd">        `zcr[0, i]` is the fraction of zero crossings in the</span>
<span class="sd">        `i` th frame</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.core.zero_crossings</span>
<span class="sd">        Compute zero-crossings in a time-series</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.zero_crossing_rate(y)</span>
<span class="sd">    array([[ 0.134,  0.139, ...,  0.387,  0.322]])</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="n">y_framed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">crossings</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">(</span><span class="n">y_framed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1"># -- Chroma --#</span>
<div class="viewcode-block" id="chroma_stft"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_stft.html#librosa.feature.chroma_stft">[docs]</a><span class="k">def</span> <span class="nf">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a chromagram from a waveform or power spectrogram.</span>

<span class="sd">    This implementation is derived from `chromagram_E` [1]_</span>

<span class="sd">    .. [1] Ellis, Daniel P.W.  &quot;Chroma feature analysis and synthesis&quot;</span>
<span class="sd">           2007/04/21</span>
<span class="sd">           http://labrosa.ee.columbia.edu/matlab/chroma-ansyn/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        power spectrogram</span>

<span class="sd">    norm : float or None</span>
<span class="sd">        Column-wise normalization.</span>
<span class="sd">        See `librosa.util.normalize` for details.</span>

<span class="sd">        If `None`, no normalization is performed.</span>

<span class="sd">    n_fft : int  &gt; 0 [scalar]</span>
<span class="sd">        FFT window size if provided `y, sr` instead of `S`</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length if provided `y, sr` instead of `S`</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    tuning : float [scalar] or None.</span>
<span class="sd">        Deviation from A440 tuning in fractional chroma bins.</span>
<span class="sd">        If `None`, it is automatically estimated.</span>

<span class="sd">    n_chroma : int &gt; 0 [scalar]</span>
<span class="sd">        Number of chroma bins to produce (12 by default).</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to parameterize chroma filters.</span>
<span class="sd">        See `librosa.filters.chroma` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.chroma</span>
<span class="sd">        Chroma filter bank construction</span>
<span class="sd">    librosa.util.normalize</span>
<span class="sd">        Vector normalization</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.chroma_stft(y=y, sr=sr)</span>
<span class="sd">    array([[ 0.974,  0.881, ...,  0.925,  1.   ],</span>
<span class="sd">           [ 1.   ,  0.841, ...,  0.882,  0.878],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.658,  0.985, ...,  0.878,  0.764],</span>
<span class="sd">           [ 0.969,  0.92 , ...,  0.974,  0.915]])</span>

<span class="sd">    Use an energy (magnitude) spectrum instead of power spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[ 0.884,  0.91 , ...,  0.861,  0.858],</span>
<span class="sd">           [ 0.963,  0.785, ...,  0.968,  0.896],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.871,  1.   , ...,  0.928,  0.829],</span>
<span class="sd">           [ 1.   ,  0.982, ...,  0.93 ,  0.878]])</span>

<span class="sd">    Use a pre-computed power spectrogram with a larger frame</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y, n_fft=4096))**2</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[ 0.685,  0.477, ...,  0.961,  0.986],</span>
<span class="sd">           [ 0.674,  0.452, ...,  0.952,  0.926],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.844,  0.575, ...,  0.934,  0.869],</span>
<span class="sd">           [ 0.793,  0.663, ...,  0.964,  0.972]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chromagram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tuning</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tuning</span> <span class="o">=</span> <span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">)</span>

    <span class="c1"># Get the filter bank</span>
    <span class="n">chromafb</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Compute raw chroma</span>
    <span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chromafb</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

    <span class="c1"># Compute normalization factor for each frame</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">raw_chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="chroma_cqt"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cqt.html#librosa.feature.chroma_cqt">[docs]</a><span class="k">def</span> <span class="nf">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
               <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cqt_mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Constant-Q chromagram</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    C : np.ndarray [shape=(d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>
<span class="sd">        Default: &#39;C1&#39; ~= 32.7 Hz</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    threshold : float</span>
<span class="sd">        Pre-normalization energy threshold.  Values below the</span>
<span class="sd">        threshold are discarded, resulting in a sparse chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in fractions of a CQT bin) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above `fmin`</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave in the CQT.</span>
<span class="sd">        Default: matches `n_chroma`</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        The output chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.util.normalize</span>
<span class="sd">    librosa.core.cqt</span>
<span class="sd">    librosa.core.hybrid_cqt</span>
<span class="sd">    chroma_stft</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare a long-window STFT chromagram to the CQT chromagram</span>


<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_stft = librosa.feature.chroma_stft(y=y, sr=sr,</span>
<span class="sd">    ...                                           n_chroma=12, n_fft=4096)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_stft, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_stft&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cqt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">cqt_func</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="n">cqt</span><span class="p">,</span> <span class="s1">&#39;hybrid&#39;</span><span class="p">:</span> <span class="n">hybrid_cqt</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">bins_per_octave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bins_per_octave</span> <span class="o">=</span> <span class="n">n_chroma</span>

    <span class="c1"># Build the CQT if we don&#39;t have one already</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cqt_func</span><span class="p">[</span><span class="n">cqt_mode</span><span class="p">](</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
                                      <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                      <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                      <span class="n">n_bins</span><span class="o">=</span><span class="n">n_octaves</span> <span class="o">*</span> <span class="n">bins_per_octave</span><span class="p">,</span>
                                      <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                                      <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">))</span>

    <span class="c1"># Map to chroma</span>
    <span class="n">cq_to_chr</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">cq_to_chroma</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                                     <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
                                     <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">cq_to_chr</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span><span class="p">[</span><span class="n">chroma</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chroma</span></div>


<div class="viewcode-block" id="chroma_cens"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cens.html#librosa.feature.chroma_cens">[docs]</a><span class="k">def</span> <span class="nf">chroma_cens</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cqt_mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">win_len_smooth</span><span class="o">=</span><span class="mi">41</span><span class="p">,</span> <span class="n">smoothing_window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Computes the chroma variant &quot;Chroma Energy Normalized&quot; (CENS), following [1]_.</span>

<span class="sd">    To compute CENS features, following steps are taken after obtaining chroma vectors using `chroma_cqt`:</span>
<span class="sd">    1. L-1 normalization of each chroma vector</span>
<span class="sd">    2. Quantization of amplitude based on &quot;log-like&quot; amplitude thresholds</span>
<span class="sd">    3. (optional) Smoothing with sliding window. Default window length = 41 frames</span>
<span class="sd">    4. (not implemented) Downsampling</span>

<span class="sd">    CENS features are robust to dynamics, timbre and articulation, thus these are commonly used in audio</span>
<span class="sd">    matching and retrieval applications.</span>

<span class="sd">    .. [1] Meinard Müller and Sebastian Ewert</span>
<span class="sd">           &quot;Chroma Toolbox: MATLAB implementations for extracting variants of chroma-based audio features&quot;</span>
<span class="sd">           In Proceedings of the International Conference on Music Information Retrieval (ISMIR), 2011.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    C : np.ndarray [shape=(d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>
<span class="sd">        Default: &#39;C1&#39; ~= 32.7 Hz</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in fractions of a CQT bin) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above `fmin`</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave in the CQT.</span>
<span class="sd">        Default: matches `n_chroma`</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    win_len_smooth : int &gt; 0 or None</span>
<span class="sd">        Length of temporal smoothing window. `None` disables temporal smoothing.</span>
<span class="sd">        Default: 41</span>

<span class="sd">    smoothing_window : str, float or tuple</span>
<span class="sd">        Type of window function for temporal smoothing. See `filters.get_window` for possible inputs.</span>
<span class="sd">        Default: &#39;hann&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chroma_cens : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        The output cens-chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt</span>
<span class="sd">        Compute a chromagram from a constant-Q transform.</span>

<span class="sd">    chroma_stft</span>
<span class="sd">        Compute a chromagram from an STFT spectrogram or waveform.</span>

<span class="sd">    filters.get_window</span>
<span class="sd">        Compute a window function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare standard cqt chroma to CENS.</span>


<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cens = librosa.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cq&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cens, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cens&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">win_len_smooth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">win_len_smooth</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">win_len_smooth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;win_len_smooth=</span><span class="si">{}</span><span class="s1"> must be a positive integer or None&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">win_len_smooth</span><span class="p">))</span>

    <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
                        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
                        <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
                        <span class="n">n_octaves</span><span class="o">=</span><span class="n">n_octaves</span><span class="p">,</span>
                        <span class="n">cqt_mode</span><span class="o">=</span><span class="n">cqt_mode</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># L1-Normalization</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Quantize amplitudes</span>
    <span class="n">QUANT_STEPS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="n">QUANT_WEIGHTS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>

    <span class="n">chroma_quant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">chroma</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_quant_step_idx</span><span class="p">,</span> <span class="n">cur_quant_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">QUANT_STEPS</span><span class="p">):</span>
        <span class="n">chroma_quant</span> <span class="o">+=</span> <span class="p">(</span><span class="n">chroma</span> <span class="o">&gt;</span> <span class="n">cur_quant_step</span><span class="p">)</span> <span class="o">*</span> <span class="n">QUANT_WEIGHTS</span><span class="p">[</span><span class="n">cur_quant_step_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">win_len_smooth</span><span class="p">:</span>
        <span class="c1"># Apply temporal smoothing</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">get_window</span><span class="p">(</span><span class="n">smoothing_window</span><span class="p">,</span> <span class="n">win_len_smooth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>

        <span class="n">cens</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">chroma_quant</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cens</span> <span class="o">=</span> <span class="n">chroma_quant</span>

    <span class="c1"># L2-Normalization</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cens</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="tonnetz"><a class="viewcode-back" href="../../../generated/librosa.feature.tonnetz.html#librosa.feature.tonnetz">[docs]</a><span class="k">def</span> <span class="nf">tonnetz</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">chroma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes the tonal centroid features (tonnetz), following the method of</span>
<span class="sd">    [1]_.</span>

<span class="sd">    .. [1] Harte, C., Sandler, M., &amp; Gasser, M. (2006). &quot;Detecting Harmonic</span>
<span class="sd">           Change in Musical Audio.&quot; In Proceedings of the 1st ACM Workshop</span>
<span class="sd">           on Audio and Music Computing Multimedia (pp. 21-26).</span>
<span class="sd">           Santa Barbara, CA, USA: ACM Press. doi:10.1145/1178723.1178727.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        Audio time series.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    chroma : np.ndarray [shape=(n_chroma, t)] or None</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">        If `None`, a cqt chromagram is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tonnetz : np.ndarray [shape(6, t)]</span>
<span class="sd">        Tonal centroid features for each frame.</span>

<span class="sd">        Tonnetz dimensions:</span>
<span class="sd">            - 0: Fifth x-axis</span>
<span class="sd">            - 1: Fifth y-axis</span>
<span class="sd">            - 2: Minor x-axis</span>
<span class="sd">            - 3: Minor y-axis</span>
<span class="sd">            - 4: Major x-axis</span>
<span class="sd">            - 5: Major y-axis</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt</span>
<span class="sd">        Compute a chromagram from a constant-Q transform.</span>

<span class="sd">    chroma_stft</span>
<span class="sd">        Compute a chromagram from an STFT spectrogram or waveform.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute tonnetz features from the harmonic component of a song</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; y = librosa.effects.harmonic(y)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz = librosa.feature.tonnetz(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz</span>
<span class="sd">    array([[-0.073, -0.053, ..., -0.054, -0.073],</span>
<span class="sd">           [ 0.001,  0.001, ..., -0.054, -0.062],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.039,  0.034, ...,  0.044,  0.064],</span>
<span class="sd">           [ 0.005,  0.002, ...,  0.011,  0.017]])</span>

<span class="sd">    Compare the tonnetz features to `chroma_cqt`</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(tonnetz, y_axis=&#39;tonnetz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Tonal Centroids (Tonnetz)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.feature.chroma_cqt(y, sr=sr),</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Either the audio samples or the chromagram must be &#39;</span>
                             <span class="s1">&#39;passed as an argument.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>

    <span class="c1"># Generate Transformation matrix</span>
    <span class="n">dim_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">chroma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">7.</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">7.</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span>
                        <span class="mf">3.</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mf">2.</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">/</span> <span class="mi">3</span><span class="p">])</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dim_map</span><span class="p">)</span>

    <span class="c1"># Even rows compute sin()</span>
    <span class="n">V</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>         <span class="c1"># Fifths</span>
                  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>         <span class="c1"># Minor</span>
                  <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>    <span class="c1"># Major</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span>

    <span class="c1"># Do the transform to tonnetz</span>
    <span class="k">return</span> <span class="n">phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div>


<span class="c1"># -- Mel spectrogram and MFCCs -- #</span>
<div class="viewcode-block" id="mfcc"><a class="viewcode-back" href="../../../generated/librosa.feature.mfcc.html#librosa.feature.mfcc">[docs]</a><span class="k">def</span> <span class="nf">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dct_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">,</span> <span class="n">lifter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mel-frequency cepstral coefficients (MFCCs)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        log-power Mel spectrogram</span>

<span class="sd">    n_mfcc: int &gt; 0 [scalar]</span>
<span class="sd">        number of MFCCs to return</span>

<span class="sd">    dct_type : {1, 2, 3}</span>
<span class="sd">        Discrete cosine transform (DCT) type.</span>
<span class="sd">        By default, DCT type-2 is used.</span>

<span class="sd">    norm : None or &#39;ortho&#39;</span>
<span class="sd">        If `dct_type` is `2 or 3`, setting `norm=&#39;ortho&#39;` uses an ortho-normal</span>
<span class="sd">        DCT basis.</span>

<span class="sd">        Normalization is not supported for `dct_type=1`.</span>

<span class="sd">    lifter : number &gt;= 0</span>
<span class="sd">        If `lifter&gt;0`, apply *liftering* (cepstral filtering) to the MFCCs:</span>

<span class="sd">        `M[n, :] &lt;- M[n, :] * (1 + sin(pi * (n + 1) / lifter)) * lifter / 2`</span>

<span class="sd">        Setting `lifter &gt;= 2 * n_mfcc` emphasizes the higher-order coefficients.</span>
<span class="sd">        As `lifter` increases, the coefficient weighting becomes approximately linear.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to `melspectrogram`, if operating</span>
<span class="sd">        on time series input</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : np.ndarray [shape=(n_mfcc, t)]</span>
<span class="sd">        MFCC sequence</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    melspectrogram</span>
<span class="sd">    scipy.fftpack.dct</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate mfccs from a time series</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), offset=30, duration=5)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    array([[ -5.229e+02,  -4.944e+02, ...,  -5.229e+02,  -5.229e+02],</span>
<span class="sd">           [  7.105e-15,   3.787e+01, ...,  -7.105e-15,  -7.105e-15],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.066e-14,  -7.500e+00, ...,   1.421e-14,   1.421e-14],</span>
<span class="sd">           [  3.109e-14,  -5.058e+00, ...,   2.931e-14,   2.931e-14]])</span>

<span class="sd">    Using a different hop length and HTK-style Mel frequencies</span>

<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(y=y, sr=sr, hop_length=1024, htk=True)</span>
<span class="sd">    array([[-1.628e+02, -8.903e+01, -1.409e+02, ..., -1.078e+02,</span>
<span class="sd">        -2.504e+02, -2.393e+02],</span>
<span class="sd">       [ 1.275e+02,  9.532e+01,  1.019e+02, ...,  1.152e+02,</span>
<span class="sd">         2.224e+02,  1.750e+02],</span>
<span class="sd">       [ 1.139e+01,  6.155e+00,  1.266e+01, ...,  4.557e+01,</span>
<span class="sd">         4.585e+01,  3.985e+01],</span>
<span class="sd">       ...,</span>
<span class="sd">       [ 3.462e+00,  4.032e+00, -5.694e-01, ..., -6.677e+00,</span>
<span class="sd">        -1.183e-01,  1.485e+00],</span>
<span class="sd">       [ 9.569e-01,  1.069e+00, -6.865e+00, ..., -9.598e+00,</span>
<span class="sd">        -1.611e+00, -6.716e+00],</span>
<span class="sd">       [ 8.457e+00,  3.582e+00, -1.156e-01, ..., -3.018e+00,</span>
<span class="sd">        -1.456e+01, -6.991e+00]], dtype=float32)</span>

<span class="sd">    Use a pre-computed log-power Mel spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                    fmax=8000)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(S=librosa.power_to_db(S))</span>
<span class="sd">    array([[ -5.207e+02,  -4.898e+02, ...,  -5.207e+02,  -5.207e+02],</span>
<span class="sd">           [ -2.576e-14,   4.054e+01, ...,  -3.997e-14,  -3.997e-14],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  7.105e-15,  -3.534e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="sd">           [  3.020e-14,  -2.613e+00, ...,   3.553e-14,   3.553e-14]])</span>

<span class="sd">    Get more components</span>

<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=40)</span>

<span class="sd">    Visualize the MFCC series</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(mfccs, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;MFCC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Compare different DCT bases</span>

<span class="sd">    &gt;&gt;&gt; m_slaney = librosa.feature.mfcc(y=y, sr=sr, dct_type=2)</span>
<span class="sd">    &gt;&gt;&gt; m_htk = librosa.feature.mfcc(y=y, sr=sr, dct_type=3)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 6))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(m_slaney, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;RASTAMAT / Auditory toolbox (dct_type=2)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(m_htk, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;HTK-style (dct_type=3)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">dct_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)[:</span><span class="n">n_mfcc</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">lifter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">lifter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_mfcc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">lifter</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">lifter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;MFCC lifter=</span><span class="si">{}</span><span class="s1"> must be a non-negative number&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lifter</span><span class="p">))</span></div>


<div class="viewcode-block" id="melspectrogram"><a class="viewcode-back" href="../../../generated/librosa.feature.melspectrogram.html#librosa.feature.melspectrogram">[docs]</a><span class="k">def</span> <span class="nf">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                   <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                   <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a mel-scaled spectrogram.</span>

<span class="sd">    If a spectrogram input `S` is provided, then it is mapped directly onto</span>
<span class="sd">    the mel basis `mel_f` by `mel_f.dot(S)`.</span>

<span class="sd">    If a time-series input `y, sr` is provided, then its magnitude spectrogram</span>
<span class="sd">    `S` is first computed, and then mapped onto the mel scale by</span>
<span class="sd">    `mel_f.dot(S**power)`.  By default, `power=2` operates on a power spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time-series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        spectrogram</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        length of the FFT window</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames.</span>
<span class="sd">        See `librosa.core.stft`</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the magnitude melspectrogram.</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">      Mel filter bank parameters.</span>
<span class="sd">      See `librosa.filters.mel` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray [shape=(n_mels, t)]</span>
<span class="sd">        Mel spectrogram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.mel</span>
<span class="sd">        Mel filter bank construction</span>

<span class="sd">    librosa.core.stft</span>
<span class="sd">        Short-time Fourier Transform</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.melspectrogram(y=y, sr=sr)</span>
<span class="sd">    array([[  2.891e-07,   2.548e-03, ...,   8.116e-09,   5.633e-09],</span>
<span class="sd">           [  1.986e-07,   1.162e-02, ...,   9.332e-08,   6.716e-09],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  3.668e-09,   2.029e-08, ...,   3.208e-09,   2.864e-09],</span>
<span class="sd">           [  2.561e-10,   2.096e-09, ...,   7.543e-10,   6.101e-10]])</span>

<span class="sd">    Using a pre-computed power spectrogram would give the same result:</span>

<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))**2</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(S=D, sr=sr)</span>
<span class="sd">    </span>
<span class="sd">    Display of mel-frequency spectrogram coefficients, with custom</span>
<span class="sd">    arguments for mel filterbank construction (default is fmax=sr/2):</span>

<span class="sd">    &gt;&gt;&gt; # Passing through arguments to the Mel filters</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                     fmax=8000)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; S_dB = librosa.power_to_db(S, ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(S_dB, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          y_axis=&#39;mel&#39;, sr=sr,</span>
<span class="sd">    ...                          fmax=8000)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Mel-frequency spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
                            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># Build a Mel filter</span>
    <span class="n">mel_basis</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mel_basis</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span></div>
</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.7.2
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Releases</dt>
      <dd><a href="spectral.html">0.7.2</a></dd>
      <dd><a href="../../../../0.8.1/index.html">0.8.1</a></dd>
      <dd><a href="../../../../0.9.0/index.html">0.9.0</a></dd>
      <dd><a href="../../../../0.9.1/index.html">0.9.1</a></dd>
    </dl>
    <dl>
      <dt>Development versions</dt>
      <dd><a href="../../../../main/index.html">main</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>