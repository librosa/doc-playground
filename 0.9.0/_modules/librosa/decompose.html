<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.decompose &mdash; librosa 0.9.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../index.html">
            <img src="../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../multichannel.html">Multi-channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>librosa.decompose</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             

<div class="admonition danger">
    <p class="admonition-title"> Caution </p>
  <p>
    
        
            You're reading an old version of this documentation.
            If you want up-to-date information, please have a look at <a href="../../../0.9.1/index.html">0.9.1</a>.
        
    
  </p>
</div>


  <h1>Source code for librosa.decompose</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spectrogram decomposition</span>
<span class="sd">=========================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    decompose</span>
<span class="sd">    hpss</span>
<span class="sd">    nn_filter</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">median_filter</span>

<span class="kn">import</span> <span class="nn">sklearn.decomposition</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">._cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">segment</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;decompose&quot;</span><span class="p">,</span> <span class="s2">&quot;hpss&quot;</span><span class="p">,</span> <span class="s2">&quot;nn_filter&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="decompose"><a class="viewcode-back" href="../../generated/librosa.decompose.decompose.html#librosa.decompose.decompose">[docs]</a><span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span>
    <span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decompose a feature matrix.</span>

<span class="sd">    Given a spectrogram ``S``, produce a decomposition into ``components``</span>
<span class="sd">    and ``activations`` such that ``S ~= components.dot(activations)``.</span>

<span class="sd">    By default, this is done with with non-negative matrix factorization (NMF),</span>
<span class="sd">    but any `sklearn.decomposition`-type object will work.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(..., n_features, n_samples), dtype=float]</span>
<span class="sd">        The input feature matrix (e.g., magnitude spectrogram)</span>

<span class="sd">        If the input has multiple channels (leading dimensions), they will be automatically</span>
<span class="sd">        flattened prior to decomposition.</span>

<span class="sd">        If the input is multi-channel, channels and features are automatically flattened into</span>
<span class="sd">        a single axis before the decomposition.</span>
<span class="sd">        For example, a stereo input `S` with shape `(2, n_features, n_samples)` is</span>
<span class="sd">        automatically reshaped to `(2 * n_features, n_samples)`.</span>

<span class="sd">    n_components : int &gt; 0 [scalar] or None</span>
<span class="sd">        number of desired components</span>

<span class="sd">        if None, then ``n_features`` components are used</span>

<span class="sd">    transformer : None or object</span>
<span class="sd">        If None, use `sklearn.decomposition.NMF`</span>

<span class="sd">        Otherwise, any object with a similar interface to NMF should work.</span>
<span class="sd">        ``transformer`` must follow the scikit-learn convention, where</span>
<span class="sd">        input data is ``(n_samples, n_features)``.</span>

<span class="sd">        `transformer.fit_transform()` will be run on ``S.T`` (not ``S``),</span>
<span class="sd">        the return value of which is stored (transposed) as ``activations``</span>

<span class="sd">        The components will be retrieved as ``transformer.components_.T``::</span>

<span class="sd">            S ~= np.dot(activations, transformer.components_).T</span>

<span class="sd">        or equivalently::</span>

<span class="sd">            S ~= np.dot(transformer.components_.T, activations.T)</span>

<span class="sd">    sort : bool</span>
<span class="sd">        If ``True``, components are sorted by ascending peak frequency.</span>

<span class="sd">        .. note:: If used with ``transformer``, sorting is applied to copies</span>
<span class="sd">            of the decomposition parameters, and not to ``transformer``</span>
<span class="sd">            internal parameters.</span>

<span class="sd">        .. warning:: If the input array has more than two dimensions</span>
<span class="sd">            (e.g., if it&#39;s a multi-channel spectrogram), then axis sorting</span>
<span class="sd">            is not supported and a `ParameterError` exception is raised.</span>

<span class="sd">    fit : bool</span>
<span class="sd">        If `True`, components are estimated from the input ``S``.</span>

<span class="sd">        If `False`, components are assumed to be pre-computed and stored</span>
<span class="sd">        in ``transformer``, and are not changed.</span>

<span class="sd">    **kwargs : Additional keyword arguments to the default transformer</span>
<span class="sd">        `sklearn.decomposition.NMF`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    components: np.ndarray [shape=(..., n_features, n_components)]</span>
<span class="sd">        matrix of components (basis elements).</span>
<span class="sd">    activations: np.ndarray [shape=(n_components, n_samples)]</span>
<span class="sd">        transformed matrix/activation matrix</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if ``fit`` is False and no ``transformer`` object is provided.</span>

<span class="sd">        if the input array is multi-channel and ``sort=True`` is specified.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.decomposition : SciKit-Learn matrix decomposition modules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Decompose a magnitude spectrogram into 16 components with NMF</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;pistachio&#39;), duration=5)</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; comps, acts = librosa.decompose.decompose(S, n_components=16)</span>

<span class="sd">    Sort components by ascending peak frequency</span>

<span class="sd">    &gt;&gt;&gt; comps, acts = librosa.decompose.decompose(S, n_components=16,</span>
<span class="sd">    ...                                           sort=True)</span>

<span class="sd">    Or with sparse dictionary learning</span>

<span class="sd">    &gt;&gt;&gt; import sklearn.decomposition</span>
<span class="sd">    &gt;&gt;&gt; T = sklearn.decomposition.MiniBatchDictionaryLearning(n_components=16)</span>
<span class="sd">    &gt;&gt;&gt; scomps, sacts = librosa.decompose.decompose(S, transformer=T, sort=True)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; layout = [list(&quot;.AAAA&quot;), list(&quot;BCCCC&quot;), list(&quot;.DDDD&quot;)]</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplot_mosaic(layout, constrained_layout=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[&#39;A&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;A&#39;].set(title=&#39;Input spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;A&#39;].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(comps,</span>
<span class="sd">    &gt;&gt;&gt;                                                  ref=np.max),</span>
<span class="sd">    &gt;&gt;&gt;                          y_axis=&#39;log&#39;, ax=ax[&#39;B&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;B&#39;].set(title=&#39;Components&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;B&#39;].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;B&#39;].sharey(ax[&#39;A&#39;])</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(acts, x_axis=&#39;time&#39;, ax=ax[&#39;C&#39;], cmap=&#39;gray_r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;C&#39;].set(ylabel=&#39;Components&#39;, title=&#39;Activations&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;C&#39;].sharex(ax[&#39;A&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;C&#39;].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; S_approx = comps.dot(acts)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(S_approx,</span>
<span class="sd">    &gt;&gt;&gt;                                                        ref=np.max),</span>
<span class="sd">    &gt;&gt;&gt;                                y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[&#39;D&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;D&#39;].set(title=&#39;Reconstructed spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;D&#39;].sharex(ax[&#39;A&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;D&#39;].sharey(ax[&#39;A&#39;])</span>
<span class="sd">    &gt;&gt;&gt; ax[&#39;D&#39;].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=list(ax.values()), format=&quot;%+2.f dB&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Do a swapaxes and unroll</span>
    <span class="n">orig_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sort</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Parameter sort=True is unsupported for input with more than two dimensions&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Transpose S and unroll feature dimensions</span>
    <span class="c1"># Use order=&#39;F&#39; here to preserve the temporal ordering</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;fit must be True if transformer is None&quot;</span><span class="p">)</span>

        <span class="n">transformer</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">decomposition</span><span class="o">.</span><span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">components</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">components_</span>
    <span class="n">component_shape</span> <span class="o">=</span> <span class="n">orig_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># use order=&#39;F&#39; here to preserve component ordering</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">component_shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">components</span><span class="p">,</span> <span class="n">activations</span></div>


<div class="viewcode-block" id="hpss"><a class="viewcode-back" href="../../generated/librosa.decompose.hpss.html#librosa.decompose.hpss">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hpss</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">31</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Median-filtering harmonic percussive source separation (HPSS).</span>

<span class="sd">    If ``margin = 1.0``, decomposes an input spectrogram ``S = H + P``</span>
<span class="sd">    where ``H`` contains the harmonic components,</span>
<span class="sd">    and ``P`` contains the percussive components.</span>

<span class="sd">    If ``margin &gt; 1.0``, decomposes an input spectrogram ``S = H + P + R``</span>
<span class="sd">    where ``R`` contains residual components not included in ``H`` or ``P``.</span>

<span class="sd">    This implementation is based upon the algorithm described by [#]_ and [#]_.</span>

<span class="sd">    .. [#] Fitzgerald, Derry.</span>
<span class="sd">        &quot;Harmonic/percussive separation using median filtering.&quot;</span>
<span class="sd">        13th International Conference on Digital Audio Effects (DAFX10),</span>
<span class="sd">        Graz, Austria, 2010.</span>

<span class="sd">    .. [#] Driedger, MÃ¼ller, Disch.</span>
<span class="sd">        &quot;Extending harmonic-percussive separation of audio.&quot;</span>
<span class="sd">        15th International Society for Music Information Retrieval Conference (ISMIR 2014),</span>
<span class="sd">        Taipei, Taiwan, 2014.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(..., d, n)]</span>
<span class="sd">        input spectrogram. May be real (magnitude) or complex.</span>
<span class="sd">        Multi-channel is supported.</span>

<span class="sd">    kernel_size : int or tuple (kernel_harmonic, kernel_percussive)</span>
<span class="sd">        kernel size(s) for the median filters.</span>

<span class="sd">        - If scalar, the same size is used for both harmonic and percussive.</span>
<span class="sd">        - If tuple, the first value specifies the width of the</span>
<span class="sd">          harmonic filter, and the second value specifies the width</span>
<span class="sd">          of the percussive filter.</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the Wiener filter when constructing soft mask matrices.</span>

<span class="sd">    mask : bool</span>
<span class="sd">        Return the masking matrices instead of components.</span>

<span class="sd">        Masking matrices contain non-negative real values that</span>
<span class="sd">        can be used to measure the assignment of energy from ``S``</span>
<span class="sd">        into harmonic or percussive components.</span>

<span class="sd">        Components can be recovered by multiplying ``S * mask_H``</span>
<span class="sd">        or ``S * mask_P``.</span>

<span class="sd">    margin : float or tuple (margin_harmonic, margin_percussive)</span>
<span class="sd">        margin size(s) for the masks (as described in [2]_)</span>

<span class="sd">        - If scalar, the same size is used for both harmonic and percussive.</span>
<span class="sd">        - If tuple, the first value specifies the margin of the</span>
<span class="sd">          harmonic mask, and the second value specifies the margin</span>
<span class="sd">          of the percussive mask.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    harmonic : np.ndarray [shape=(..., d, n)]</span>
<span class="sd">        harmonic component (or mask)</span>
<span class="sd">    percussive : np.ndarray [shape=(..., d, n)]</span>
<span class="sd">        percussive component (or mask)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.util.softmask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Separate into harmonic and percussive</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;choice&#39;), duration=5)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=3, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(np.abs(D),</span>
<span class="sd">    ...                                                        ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Full power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(np.abs(H),</span>
<span class="sd">    ...                                                  ref=np.max(np.abs(D))),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Harmonic power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(np.abs(P),</span>
<span class="sd">    ...                                                  ref=np.max(np.abs(D))),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[2])</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set(title=&#39;Percussive power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax, format=&#39;%+2.0f dB&#39;)</span>

<span class="sd">    Or with a narrower horizontal filter</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, kernel_size=(13, 31))</span>

<span class="sd">    Just get harmonic/percussive masks, not the spectra</span>

<span class="sd">    &gt;&gt;&gt; mask_H, mask_P = librosa.decompose.hpss(D, mask=True)</span>
<span class="sd">    &gt;&gt;&gt; mask_H</span>
<span class="sd">    array([[1.853e-03, 1.701e-04, ..., 9.922e-01, 1.000e+00],</span>
<span class="sd">           [2.316e-03, 2.127e-04, ..., 9.989e-01, 1.000e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [8.195e-05, 6.939e-05, ..., 3.105e-04, 4.231e-04],</span>
<span class="sd">           [3.159e-05, 4.156e-05, ..., 6.216e-04, 6.188e-04]],</span>
<span class="sd">          dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; mask_P</span>
<span class="sd">    array([[9.981e-01, 9.998e-01, ..., 7.759e-03, 3.201e-05],</span>
<span class="sd">           [9.977e-01, 9.998e-01, ..., 1.122e-03, 4.451e-06],</span>
<span class="sd">           ...,</span>
<span class="sd">           [9.999e-01, 9.999e-01, ..., 9.997e-01, 9.996e-01],</span>
<span class="sd">           [1.000e+00, 1.000e+00, ..., 9.994e-01, 9.994e-01]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Separate into harmonic/percussive/residual components by using a margin &gt; 1.0</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, margin=3.0)</span>
<span class="sd">    &gt;&gt;&gt; R = D - (H+P)</span>
<span class="sd">    &gt;&gt;&gt; y_harm = librosa.istft(H)</span>
<span class="sd">    &gt;&gt;&gt; y_perc = librosa.istft(P)</span>
<span class="sd">    &gt;&gt;&gt; y_resi = librosa.istft(R)</span>

<span class="sd">    Get a more isolated percussive component by widening its margin</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, margin=(1.0,5.0))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">):</span>
        <span class="n">win_harm</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="n">win_perc</span> <span class="o">=</span> <span class="n">kernel_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">win_harm</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">win_perc</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">margin</span><span class="p">):</span>
        <span class="n">margin_harm</span> <span class="o">=</span> <span class="n">margin</span>
        <span class="n">margin_perc</span> <span class="o">=</span> <span class="n">margin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">margin_harm</span> <span class="o">=</span> <span class="n">margin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">margin_perc</span> <span class="o">=</span> <span class="n">margin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># margin minimum is 1.0</span>
    <span class="k">if</span> <span class="n">margin_harm</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">margin_perc</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Margins must be &gt;= 1.0. &quot;</span> <span class="s2">&quot;A typical range is between 1 and 10.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># shape for kernels</span>
    <span class="n">harm_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">harm_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_harm</span>

    <span class="n">perc_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">perc_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_perc</span>

    <span class="c1"># Compute median filters. Pre-allocation here preserves memory layout.</span>
    <span class="n">harm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">harm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">harm_shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>

    <span class="n">perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">perc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">perc_shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>

    <span class="n">split_zeros</span> <span class="o">=</span> <span class="n">margin_harm</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">margin_perc</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">mask_harm</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">softmask</span><span class="p">(</span>
        <span class="n">harm</span><span class="p">,</span> <span class="n">perc</span> <span class="o">*</span> <span class="n">margin_harm</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">split_zeros</span><span class="o">=</span><span class="n">split_zeros</span>
    <span class="p">)</span>

    <span class="n">mask_perc</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">softmask</span><span class="p">(</span>
        <span class="n">perc</span><span class="p">,</span> <span class="n">harm</span> <span class="o">*</span> <span class="n">margin_perc</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">split_zeros</span><span class="o">=</span><span class="n">split_zeros</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask_harm</span><span class="p">,</span> <span class="n">mask_perc</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">S</span> <span class="o">*</span> <span class="n">mask_harm</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">mask_perc</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span></div>


<div class="viewcode-block" id="nn_filter"><a class="viewcode-back" href="../../generated/librosa.decompose.nn_filter.html#librosa.decompose.nn_filter">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nn_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filtering by nearest-neighbors.</span>

<span class="sd">    Each data point (e.g, spectrogram column) is replaced</span>
<span class="sd">    by aggregating its nearest neighbors in feature space.</span>

<span class="sd">    This can be useful for de-noising a spectrogram or feature matrix.</span>

<span class="sd">    The non-local means method [#]_ can be recovered by providing a</span>
<span class="sd">    weighted recurrence matrix as input and specifying ``aggregate=np.average``.</span>

<span class="sd">    Similarly, setting ``aggregate=np.median`` produces sparse de-noising</span>
<span class="sd">    as in REPET-SIM [#]_.</span>

<span class="sd">    .. [#] Buades, A., Coll, B., &amp; Morel, J. M.</span>
<span class="sd">        (2005, June). A non-local algorithm for image denoising.</span>
<span class="sd">        In Computer Vision and Pattern Recognition, 2005.</span>
<span class="sd">        CVPR 2005. IEEE Computer Society Conference on (Vol. 2, pp. 60-65). IEEE.</span>

<span class="sd">    .. [#] Rafii, Z., &amp; Pardo, B.</span>
<span class="sd">        (2012, October).  &quot;Music/Voice Separation Using the Similarity Matrix.&quot;</span>
<span class="sd">        International Society for Music Information Retrieval Conference, 2012.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The input data (spectrogram) to filter. Multi-channel is supported.</span>

<span class="sd">    rec : (optional) scipy.sparse.spmatrix or np.ndarray</span>
<span class="sd">        Optionally, a pre-computed nearest-neighbor matrix</span>
<span class="sd">        as provided by `librosa.segment.recurrence_matrix`</span>

<span class="sd">    aggregate : function</span>
<span class="sd">        aggregation function (default: `np.mean`)</span>

<span class="sd">        If ``aggregate=np.average``, then a weighted average is</span>
<span class="sd">        computed according to the (per-row) weights in ``rec``.</span>

<span class="sd">        For all other aggregation functions, all neighbors</span>
<span class="sd">        are treated equally.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to filter (by default, columns)</span>

<span class="sd">    **kwargs</span>
<span class="sd">        Additional keyword arguments provided to</span>
<span class="sd">        `librosa.segment.recurrence_matrix` if ``rec`` is not provided</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_filtered : np.ndarray</span>
<span class="sd">        The filtered data, with shape equivalent to the input ``S``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if ``rec`` is provided and its shape is incompatible with ``S``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decompose</span>
<span class="sd">    hpss</span>
<span class="sd">    librosa.segment.recurrence_matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    De-noise a chromagram by non-local median filtering.</span>
<span class="sd">    By default this would use euclidean distance to select neighbors,</span>
<span class="sd">    but this can be overridden directly by setting the ``metric`` parameter.</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;brahms&#39;),</span>
<span class="sd">    ...                      offset=30, duration=10)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma_med = librosa.decompose.nn_filter(chroma,</span>
<span class="sd">    ...                                          aggregate=np.median,</span>
<span class="sd">    ...                                          metric=&#39;cosine&#39;)</span>

<span class="sd">    To use non-local means, provide an affinity matrix and ``aggregate=np.average``.</span>

<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(chroma, mode=&#39;affinity&#39;,</span>
<span class="sd">    ...                                         metric=&#39;cosine&#39;, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; chroma_nlm = librosa.decompose.nn_filter(chroma, rec=rec,</span>
<span class="sd">    ...                                          aggregate=np.average)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=5, sharex=True, sharey=True, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Unfiltered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_med, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Median-filtered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgc = librosa.display.specshow(chroma_nlm, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[2])</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set(title=&#39;Non-local means&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[2].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgr1 = librosa.display.specshow(chroma - chroma_med,</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[3])</span>
<span class="sd">    &gt;&gt;&gt; ax[3].set(title=&#39;Original - median&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[3].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; imgr2 = librosa.display.specshow(chroma - chroma_nlm,</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[4])</span>
<span class="sd">    &gt;&gt;&gt; ax[4].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; ax[4].set(title=&#39;Original - NLM&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgc, ax=ax[:3])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgr1, ax=[ax[3]])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(imgr2, ax=[ax[4]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>

    <span class="k">if</span> <span class="n">rec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sparse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid self-similarity matrix shape &quot;</span>
            <span class="s2">&quot;rec.shape=</span><span class="si">{}</span><span class="s2"> for S.shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">__nn_filter_helper</span><span class="p">(</span>
        <span class="n">rec</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aggregate</span>
    <span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">__nn_filter_helper</span><span class="p">(</span><span class="n">R_data</span><span class="p">,</span> <span class="n">R_indices</span><span class="p">,</span> <span class="n">R_ptr</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nearest-neighbor filter helper function.</span>

<span class="sd">    This is an internal function, not for use outside of the decompose module.</span>

<span class="sd">    It applies the nearest-neighbor filter to S, assuming that the first index</span>
<span class="sd">    corresponds to observations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R_data, R_indices, R_ptr : np.ndarrays</span>
<span class="sd">        The ``data``, ``indices``, and ``indptr`` of a scipy.sparse matrix</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The observation data to filter</span>
<span class="sd">    aggregate : callable</span>
<span class="sd">        The aggregation operator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray like S</span>
<span class="sd">        The filtered data array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_ptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

        <span class="c1"># Get the non-zeros out of the recurrence matrix</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">R_indices</span><span class="p">[</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">R_data</span><span class="p">[</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">s_out</span>
</pre></div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.9.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Releases</dt>
      <dd><a href="decompose.html">0.9.0</a></dd>
      <dd><a href="../../../0.9.1/index.html">0.9.1</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>