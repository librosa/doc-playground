<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>librosa.feature.spectral &mdash; librosa 0.9.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html">
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../multichannel.html">Multi-channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>librosa.feature.spectral</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for librosa.feature.spectral</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Spectral feature extraction&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>

<span class="kn">from</span> <span class="nn">..core.convert</span> <span class="kn">import</span> <span class="n">fft_frequencies</span>
<span class="kn">from</span> <span class="nn">..core.audio</span> <span class="kn">import</span> <span class="n">zero_crossings</span>
<span class="kn">from</span> <span class="nn">..core.spectrum</span> <span class="kn">import</span> <span class="n">power_to_db</span><span class="p">,</span> <span class="n">_spectrogram</span>
<span class="kn">from</span> <span class="nn">..core.constantq</span> <span class="kn">import</span> <span class="n">cqt</span><span class="p">,</span> <span class="n">hybrid_cqt</span>
<span class="kn">from</span> <span class="nn">..core.pitch</span> <span class="kn">import</span> <span class="n">estimate_tuning</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;spectral_centroid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_bandwidth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_contrast&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_rolloff&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_flatness&quot;</span><span class="p">,</span>
    <span class="s2">&quot;poly_features&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;zero_crossing_rate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_stft&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_cqt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_cens&quot;</span><span class="p">,</span>
    <span class="s2">&quot;melspectrogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mfcc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tonnetz&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1"># -- Spectral features -- #</span>
<div class="viewcode-block" id="spectral_centroid"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_centroid.html#librosa.feature.spectral_centroid">[docs]</a><span class="k">def</span> <span class="nf">spectral_centroid</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the spectral centroid.</span>

<span class="sd">    Each frame of a magnitude spectrogram is normalized and treated as a</span>
<span class="sd">    distribution over frequency bins, from which the mean (centroid) is</span>
<span class="sd">    extracted per frame.</span>

<span class="sd">    More precisely, the centroid at frame ``t`` is defined as [#]_::</span>

<span class="sd">        centroid[t] = sum_k S[k, t] * freq[k] / (sum_j S[j, t])</span>

<span class="sd">    where ``S`` is a magnitude spectrogram, and ``freq`` is the array of</span>
<span class="sd">    frequencies (e.g., FFT frequencies in Hz) of the rows of ``S``.</span>

<span class="sd">    .. [#] Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing</span>
<span class="sd">        methods for music transcription, chapter 5.</span>
<span class="sd">        Springer Science &amp; Business Media.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>

<span class="sd">        Otherwise, it can be a single array of ``d`` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.reassigned_spectrogram`</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length ``win_length`` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          `t` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centroid : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        centroid frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.stft : Short-time Fourier Transform</span>
<span class="sd">    librosa.reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; cent = librosa.feature.spectral_centroid(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; cent</span>
<span class="sd">    array([[1768.888, 1921.774, ..., 5663.477, 5813.683]])</span>

<span class="sd">    From spectrogram input:</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=S)</span>
<span class="sd">    array([[1768.888, 1921.774, ..., 5663.477, 5813.683]])</span>

<span class="sd">    Using variable bin center frequencies:</span>

<span class="sd">    &gt;&gt;&gt; freqs, times, D = librosa.reassigned_spectrogram(y, fill_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=np.abs(D), freq=freqs)</span>
<span class="sd">    array([[1768.838, 1921.801, ..., 5663.513, 5813.747]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(cent)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(times, cent.T, label=&#39;Spectral centroid&#39;, color=&#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend(loc=&#39;upper right&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(title=&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># input is time domain:y or spectrogam:s</span>
    <span class="c1">#</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral centroid is only defined &quot;</span> <span class="s2">&quot;with real-valued input&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral centroid is only defined &quot;</span> <span class="s2">&quot;with non-negative energies&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># reshape for broadcasting</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_bandwidth"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_bandwidth.html#librosa.feature.spectral_bandwidth">[docs]</a><span class="k">def</span> <span class="nf">spectral_bandwidth</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute p&#39;th-order spectral bandwidth.</span>

<span class="sd">       The spectral bandwidth [#]_ at frame ``t`` is computed by::</span>

<span class="sd">        (sum_k S[k, t] * (freq[k, t] - centroid[t])**p)**(1/p)</span>

<span class="sd">    .. [#] Klapuri, A., &amp; Davy, M. (Eds.). (2007). Signal processing</span>
<span class="sd">        methods for music transcription, chapter 5.</span>
<span class="sd">        Springer Science &amp; Business Media.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length ``win_length`` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If ``False``, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(..., d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>

<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of ``d`` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.reassigned_spectrogram`</span>

<span class="sd">    centroid : None or np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        pre-computed centroid frequencies</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize per-frame spectral energy (sum to one)</span>

<span class="sd">    p : float &gt; 0</span>
<span class="sd">        Power to raise deviation from spectral centroid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bandwidth : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        frequency bandwidth for each frame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; spec_bw = librosa.feature.spectral_bandwidth(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; spec_bw</span>
<span class="sd">    array([[1273.836, 1228.873, ..., 2952.357, 3013.68 ]])</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=S)</span>
<span class="sd">    array([[1273.836, 1228.873, ..., 2952.357, 3013.68 ]])</span>

<span class="sd">    Using variable bin center frequencies</span>

<span class="sd">    &gt;&gt;&gt; freqs, times, D = librosa.reassigned_spectrogram(y, fill_nan=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=np.abs(D), freq=freqs)</span>
<span class="sd">    array([[1274.637, 1228.786, ..., 2952.4  , 3013.735]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(spec_bw)</span>
<span class="sd">    &gt;&gt;&gt; centroid = librosa.feature.spectral_centroid(S=S)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].semilogy(times, spec_bw[0], label=&#39;Spectral bandwidth&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(ylabel=&#39;Hz&#39;, xticks=[], xlim=[times.min(), times.max()])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].fill_between(times, np.maximum(0, centroid[0] - spec_bw[0]),</span>
<span class="sd">    ...                 np.minimum(centroid[0] + spec_bw[0], sr/2),</span>
<span class="sd">    ...                 alpha=0.5, label=&#39;Centroid +- bandwidth&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(times, centroid[0], label=&#39;Spectral centroid&#39;, color=&#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].legend(loc=&#39;lower right&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral bandwidth is only defined &quot;</span> <span class="s2">&quot;with real-valued input&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral bandwidth is only defined &quot;</span> <span class="s2">&quot;with non-negative energies&quot;</span>
        <span class="p">)</span>

    <span class="c1"># centroid or center?</span>
    <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">spectral_centroid</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span>
        <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">)</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">deviation</span> <span class="o">**</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_contrast"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_contrast.html#librosa.feature.spectral_contrast">[docs]</a><span class="k">def</span> <span class="nf">spectral_contrast</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fmin</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
    <span class="n">n_bands</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">quantile</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spectral contrast</span>

<span class="sd">    Each frame of a spectrogram ``S`` is divided into sub-bands.</span>
<span class="sd">    For each sub-band, the energy contrast is estimated by comparing</span>
<span class="sd">    the mean energy in the top quantile (peak energy) to that of the</span>
<span class="sd">    bottom quantile (valley energy).  High contrast values generally</span>
<span class="sd">    correspond to clear, narrow-band signals, while low contrast values</span>
<span class="sd">    correspond to broad-band noise. [#]_</span>

<span class="sd">    .. [#] Jiang, Dan-Ning, Lie Lu, Hong-Jiang Zhang, Jian-Hua Tao,</span>
<span class="sd">           and Lian-Hong Cai.</span>
<span class="sd">           &quot;Music type classification by spectral contrast feature.&quot;</span>
<span class="sd">           In Multimedia and Expo, 2002. ICME&#39;02. Proceedings.</span>
<span class="sd">           2002 IEEE International Conference on, vol. 1, pp. 113-116.</span>
<span class="sd">           IEEE, 2002.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number  &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>

<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of ``d`` center frequencies.</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        Frequency cutoff for the first bin ``[0, fmin]``</span>
<span class="sd">        Subsequent bins will cover ``[fmin, 2*fmin]`, `[2*fmin, 4*fmin]``, etc.</span>

<span class="sd">    n_bands : int &gt; 1</span>
<span class="sd">        number of frequency bands</span>

<span class="sd">    quantile : float in (0, 1)</span>
<span class="sd">        quantile for determining peaks and valleys</span>

<span class="sd">    linear : bool</span>
<span class="sd">        If `True`, return the linear difference of magnitudes:</span>
<span class="sd">        ``peaks - valleys``.</span>

<span class="sd">        If `False`, return the logarithmic difference:</span>
<span class="sd">        ``log(peaks) - log(valleys)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contrast : np.ndarray [shape=(..., n_bands + 1, t)]</span>
<span class="sd">        each row of spectral contrast values corresponds to a given</span>
<span class="sd">        octave-based frequency</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; contrast = librosa.feature.spectral_contrast(S=S, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; img1 = librosa.display.specshow(librosa.amplitude_to_db(S,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img1, ax=[ax[0]], format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img2 = librosa.display.specshow(contrast, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img2, ax=[ax[1]])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(ylabel=&#39;Frequency bands&#39;, title=&#39;Spectral contrast&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;freq.shape mismatch: expected &quot;</span> <span class="s2">&quot;(</span><span class="si">{:d}</span><span class="s2">,)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_bands</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_bands</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_bands must be a positive integer&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;quantile must lie in the range (0, 1)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;fmin must be a positive number&quot;</span><span class="p">)</span>

    <span class="n">octa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Frequency band exceeds Nyquist. &quot;</span> <span class="s2">&quot;Reduce either fmin or n_bands.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># shape of valleys and peaks based on spectrogram</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">valley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="n">current_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">f_low</span><span class="p">,</span> <span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">f_high</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">current_band</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sub_band</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">sub_band</span> <span class="o">=</span> <span class="n">sub_band</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Always take at least one bin from each side</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">quantile</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_band</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">sortedr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_band</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">valley</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">peak</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">idx</span><span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">valley</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="o">-</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_rolloff"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_rolloff.html#librosa.feature.spectral_rolloff">[docs]</a><span class="k">def</span> <span class="nf">spectral_rolloff</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">roll_percent</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute roll-off frequency.</span>

<span class="sd">    The roll-off frequency is defined for each frame as the center frequency</span>
<span class="sd">    for a spectrogram bin such that at least roll_percent (0.85 by default)</span>
<span class="sd">    of the energy of the spectrum in this frame is contained in this bin and</span>
<span class="sd">    the bins below. This can be used to, e.g., approximate the maximum (or</span>
<span class="sd">    minimum) frequency by setting roll_percent to a value close to 1 (or 0).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(..., d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of ``d`` center frequencies,</span>

<span class="sd">        .. note:: ``freq`` is assumed to be sorted in increasing order</span>

<span class="sd">    roll_percent : float [0 &lt; roll_percent &lt; 1]</span>
<span class="sd">        Roll-off percentage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rolloff : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        roll-off frequency for each frame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; # Approximate maximum frequencies with roll_percent=0.85 (default)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(y=y, sr=sr)</span>
<span class="sd">    array([[2583.984, 3036.182, ..., 9173.145, 9248.511]])</span>
<span class="sd">    &gt;&gt;&gt; # Approximate maximum frequencies with roll_percent=0.99</span>
<span class="sd">    &gt;&gt;&gt; rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.99)</span>
<span class="sd">    &gt;&gt;&gt; rolloff</span>
<span class="sd">    array([[ 7192.09 ,  6739.893, ..., 10960.4  , 10992.7  ]])</span>
<span class="sd">    &gt;&gt;&gt; # Approximate minimum frequencies with roll_percent=0.01</span>
<span class="sd">    &gt;&gt;&gt; rolloff_min = librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.01)</span>
<span class="sd">    &gt;&gt;&gt; rolloff_min</span>
<span class="sd">    array([[516.797, 538.33 , ..., 764.429, 764.429]])</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(S=S, sr=sr)</span>
<span class="sd">    array([[2583.984, 3036.182, ..., 9173.145, 9248.511]])</span>

<span class="sd">    &gt;&gt;&gt; # With a higher roll percentage:</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.95)</span>
<span class="sd">    array([[ 3919.043,  3994.409, ..., 10443.604, 10594.336]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(librosa.times_like(rolloff), rolloff[0], label=&#39;Roll-off frequency (0.99)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(librosa.times_like(rolloff), rolloff_min[0], color=&#39;w&#39;,</span>
<span class="sd">    ...         label=&#39;Roll-off frequency (0.01)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend(loc=&#39;lower right&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(title=&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">roll_percent</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;roll_percent must lie in the range (0, 1)&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral rolloff is only defined &quot;</span> <span class="s2">&quot;with real-valued input&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral rolloff is only defined &quot;</span> <span class="s2">&quot;with non-negative energies&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Make sure that frequency can be broadcast</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># reshape for broadcasting</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">total_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># (channels,freq,frames)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">roll_percent</span> <span class="o">*</span> <span class="n">total_energy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># reshape threshold for broadcasting</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_energy</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">ind</span> <span class="o">*</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_flatness"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_flatness.html#librosa.feature.spectral_flatness">[docs]</a><span class="k">def</span> <span class="nf">spectral_flatness</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spectral flatness</span>

<span class="sd">    Spectral flatness (or tonality coefficient) is a measure to</span>
<span class="sd">    quantify how much noise-like a sound is, as opposed to being</span>
<span class="sd">    tone-like [#]_. A high spectral flatness (closer to 1.0)</span>
<span class="sd">    indicates the spectrum is similar to white noise.</span>
<span class="sd">    It is often converted to decibel.</span>

<span class="sd">    .. [#] Dubnov, Shlomo  &quot;Generalization of spectral flatness</span>
<span class="sd">           measure for non-gaussian linear processes&quot;</span>
<span class="sd">           IEEE Signal Processing Letters, 2004, Vol. 11.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) pre-computed spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame `t` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for ``S`` (=added noise floor for numerical stability)</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the magnitude spectrogram.</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>
<span class="sd">        Power spectrogram is usually used for computing spectral flatness.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flatness : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        spectral flatness for each frame.</span>
<span class="sd">        The returned value is in [0, 1] and often converted to dB scale.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; flatness = librosa.feature.spectral_flatness(y=y)</span>
<span class="sd">    &gt;&gt;&gt; flatness</span>
<span class="sd">    array([[0.001, 0.   , ..., 0.218, 0.184]], dtype=float32)</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_flatness(S=S)</span>
<span class="sd">    array([[0.001, 0.   , ..., 0.218, 0.184]], dtype=float32)</span>

<span class="sd">    From power spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; S_power = S ** 2</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_flatness(S=S_power, power=1.0)</span>
<span class="sd">    array([[0.001, 0.   , ..., 0.218, 0.184]], dtype=float32)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;amin must be strictly positive&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">power</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral flatness is only defined &quot;</span> <span class="s2">&quot;with real-valued input&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Spectral flatness is only defined &quot;</span> <span class="s2">&quot;with non-negative energies&quot;</span>
        <span class="p">)</span>

    <span class="n">S_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">S</span> <span class="o">**</span> <span class="n">power</span><span class="p">)</span>
    <span class="n">gmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">amean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gmean</span> <span class="o">/</span> <span class="n">amean</span></div>


<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../../../generated/librosa.feature.rms.html#librosa.feature.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute root-mean-square (RMS) value for each frame, either from the</span>
<span class="sd">    audio samples ``y`` or from a spectrogram ``S``.</span>

<span class="sd">    Computing the RMS value from audio samples is faster as it doesn&#39;t require</span>
<span class="sd">    a STFT calculation. However, using a spectrogram will give a more accurate</span>
<span class="sd">    representation of energy over time because its frames can be windowed,</span>
<span class="sd">    thus prefer using ``S`` if it&#39;s already available.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        (optional) audio time series. Required if ``S`` is not input.</span>
<span class="sd">        Multi-channel is supported.</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude. Required if ``y`` is not input.</span>

<span class="sd">    frame_length : int &gt; 0 [scalar]</span>
<span class="sd">        length of analysis frame (in samples) for energy calculation</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True` and operating on time-domain input (``y``), pad the signal</span>
<span class="sd">        by ``frame_length//2`` on either side.</span>

<span class="sd">        If operating on spectrogram input, this has no effect.</span>

<span class="sd">    pad_mode : str</span>
<span class="sd">        Padding mode for centered analysis.  See `numpy.pad` for valid</span>
<span class="sd">        values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        RMS value for each frame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rms(y=y)</span>
<span class="sd">    array([[1.248e-01, 1.259e-01, ..., 1.845e-05, 1.796e-05]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Or from spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; rms = librosa.feature.rms(S=S)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(rms)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].semilogy(times, rms[0], label=&#39;RMS Energy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(xticks=[])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;log Power spectrogram&#39;)</span>

<span class="sd">    Use a STFT window of constant ones and no frame centering to get consistent</span>
<span class="sd">    results with the RMS computed from the audio samples ``y``</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rms(S=S)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
            <span class="n">padding</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check the frame length</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                <span class="s2">&quot;Since S.shape[-2] is </span><span class="si">{}</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;frame_length is expected to be </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2">; &quot;</span>
                <span class="s2">&quot;found </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame_length</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># power spectrogram</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Adjust the DC and sr/2 component</span>
        <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="n">frame_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_length</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Either `y` or `S` must be input.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">power</span><span class="p">)</span></div>


<div class="viewcode-block" id="poly_features"><a class="viewcode-back" href="../../../generated/librosa.feature.poly_features.html#librosa.feature.poly_features">[docs]</a><span class="k">def</span> <span class="nf">poly_features</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get coefficients of fitting an nth-order polynomial to the columns</span>
<span class="sd">    of a spectrogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.stft` for details.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          `t` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    order : int &gt; 0</span>
<span class="sd">        order of the polynomial to fit</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(..., d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of ``d`` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.reassigned_spectrogram`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients : np.ndarray [shape=(..., order+1, t)]</span>
<span class="sd">        polynomial coefficients for each frame.</span>

<span class="sd">        ``coeffecients[..., 0, :]`` corresponds to the highest degree (``order``),</span>

<span class="sd">        ``coefficients[..., 1, :]`` corresponds to the next highest degree (``order-1``),</span>

<span class="sd">        down to the constant term ``coefficients[..., order, :]``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>

<span class="sd">    Fit a degree-0 polynomial (constant) to each frame</span>

<span class="sd">    &gt;&gt;&gt; p0 = librosa.feature.poly_features(S=S, order=0)</span>

<span class="sd">    Fit a linear polynomial to each frame</span>

<span class="sd">    &gt;&gt;&gt; p1 = librosa.feature.poly_features(S=S, order=1)</span>

<span class="sd">    Fit a quadratic to each frame</span>

<span class="sd">    &gt;&gt;&gt; p2 = librosa.feature.poly_features(S=S, order=2)</span>

<span class="sd">    Plot the results for comparison</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=4, sharex=True, figsize=(8, 8))</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(p0)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(times, p0[0], label=&#39;order=0&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(times, p1[1], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(times, p2[2], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(ylabel=&#39;Constant term &#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(times, p1[0], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(times, p2[1], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(ylabel=&#39;Linear term&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; ax[1].legend()</span>
<span class="sd">    &gt;&gt;&gt; ax[2].plot(times, p2[0], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set(ylabel=&#39;Quadratic term&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[2].legend()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[3])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># If frequencies are constant over frames, then we only need to fit once</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span> <span class="n">signature</span><span class="o">=</span><span class="s2">&quot;(f,t)-&gt;(d,t)&quot;</span>
        <span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, we have variable frequencies, and need to fit independently</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span> <span class="n">signature</span><span class="o">=</span><span class="s2">&quot;(f),(f)-&gt;(d)&quot;</span>
        <span class="p">)</span>

        <span class="c1"># We have to do some axis swapping to preserve layout</span>
        <span class="c1"># otherwise, the new dimension gets put at the end instead of the penultimate position</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">coefficients</span></div>


<div class="viewcode-block" id="zero_crossing_rate"><a class="viewcode-back" href="../../../generated/librosa.feature.zero_crossing_rate.html#librosa.feature.zero_crossing_rate">[docs]</a><span class="k">def</span> <span class="nf">zero_crossing_rate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the zero-crossing rate of an audio time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)]</span>
<span class="sd">        Audio time series. Multi-channel is supported.</span>

<span class="sd">    frame_length : int &gt; 0</span>
<span class="sd">        Length of the frame over which to compute zero crossing rates</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        Number of samples to advance for each frame</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True`, frames are centered by padding the edges of ``y``.</span>
<span class="sd">        This is similar to the padding in `librosa.stft`,</span>
<span class="sd">        but uses edge-value copies instead of zero-padding.</span>

<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        See `librosa.zero_crossings`</span>

<span class="sd">        .. note:: By default, the ``pad`` parameter is set to `False`, which</span>
<span class="sd">            differs from the default specified by</span>
<span class="sd">            `librosa.zero_crossings`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zcr : np.ndarray [shape=(..., 1, t)]</span>
<span class="sd">        ``zcr[..., 0, i]`` is the fraction of zero crossings in frame ``i``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.zero_crossings : Compute zero-crossings in a time-series</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.zero_crossing_rate(y)</span>
<span class="sd">    array([[0.044, 0.074, ..., 0.488, 0.355]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check if audio is valid</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">padding</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>

    <span class="n">y_framed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">crossings</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">(</span><span class="n">y_framed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1"># -- Chroma --#</span>
<div class="viewcode-block" id="chroma_stft"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_stft.html#librosa.feature.chroma_stft">[docs]</a><span class="k">def</span> <span class="nf">chroma_stft</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a chromagram from a waveform or power spectrogram.</span>

<span class="sd">    This implementation is derived from ``chromagram_E`` [#]_</span>

<span class="sd">    .. [#] Ellis, Daniel P.W.  &quot;Chroma feature analysis and synthesis&quot;</span>
<span class="sd">           2007/04/21</span>
<span class="sd">           http://labrosa.ee.columbia.edu/matlab/chroma-ansyn/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        power spectrogram</span>

<span class="sd">    norm : float or None</span>
<span class="sd">        Column-wise normalization.</span>
<span class="sd">        See `librosa.util.normalize` for details.</span>

<span class="sd">        If `None`, no normalization is performed.</span>

<span class="sd">    n_fft : int  &gt; 0 [scalar]</span>
<span class="sd">        FFT window size if provided ``y, sr`` instead of ``S``</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length if provided ``y, sr`` instead of ``S``</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    tuning : float [scalar] or None.</span>
<span class="sd">        Deviation from A440 tuning in fractional chroma bins.</span>
<span class="sd">        If `None`, it is automatically estimated.</span>

<span class="sd">    n_chroma : int &gt; 0 [scalar]</span>
<span class="sd">        Number of chroma bins to produce (12 by default).</span>

<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to parameterize chroma filters.</span>
<span class="sd">        See `librosa.filters.chroma` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram : np.ndarray [shape=(..., n_chroma, t)]</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.chroma : Chroma filter bank construction</span>
<span class="sd">    librosa.util.normalize : Vector normalization</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.chroma_stft(y=y, sr=sr)</span>
<span class="sd">    array([[1.   , 0.962, ..., 0.143, 0.278],</span>
<span class="sd">           [0.688, 0.745, ..., 0.103, 0.162],</span>
<span class="sd">           ...,</span>
<span class="sd">           [0.468, 0.598, ..., 0.18 , 0.342],</span>
<span class="sd">           [0.681, 0.702, ..., 0.553, 1.   ]], dtype=float32)</span>

<span class="sd">    Use an energy (magnitude) spectrum instead of power spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[1.   , 0.973, ..., 0.527, 0.569],</span>
<span class="sd">           [0.774, 0.81 , ..., 0.518, 0.506],</span>
<span class="sd">           ...,</span>
<span class="sd">           [0.624, 0.73 , ..., 0.611, 0.644],</span>
<span class="sd">           [0.766, 0.822, ..., 0.92 , 1.   ]], dtype=float32)</span>

<span class="sd">    Use a pre-computed power spectrogram with a larger frame</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y, n_fft=4096))**2</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[0.994, 0.873, ..., 0.169, 0.227],</span>
<span class="sd">           [0.735, 0.64 , ..., 0.141, 0.135],</span>
<span class="sd">           ...,</span>
<span class="sd">           [0.6  , 0.937, ..., 0.214, 0.257],</span>
<span class="sd">           [0.743, 0.937, ..., 0.684, 0.815]], dtype=float32)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                                y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=[ax[0]])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(chroma, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=[ax[1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">tuning</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tuning</span> <span class="o">=</span> <span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">)</span>

    <span class="c1"># Get the filter bank</span>
    <span class="n">chromafb</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Compute raw chroma</span>
    <span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;cf,...ft-&gt;...ct&quot;</span><span class="p">,</span> <span class="n">chromafb</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute normalization factor for each frame</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">raw_chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="chroma_cqt"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cqt.html#librosa.feature.chroma_cqt">[docs]</a><span class="k">def</span> <span class="nf">chroma_cqt</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span>
    <span class="n">cqt_mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constant-Q chromagram</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)]</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    C : np.ndarray [shape=(..., d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>

<span class="sd">        Default: `C1 ~= 32.7 Hz`</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    threshold : float</span>
<span class="sd">        Pre-normalization energy threshold.  Values below the</span>
<span class="sd">        threshold are discarded, resulting in a sparse chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in fractions of a CQT bin) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above ``fmin``</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0, optional</span>
<span class="sd">        Number of bins per octave in the CQT.</span>
<span class="sd">        Must be an integer multiple of ``n_chroma``.</span>
<span class="sd">        Default: 36 (3 bins per semitone)</span>

<span class="sd">        If `None`, it will match ``n_chroma``.</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram : np.ndarray [shape=(..., n_chroma, t)]</span>
<span class="sd">        The output chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.util.normalize</span>
<span class="sd">    librosa.cqt</span>
<span class="sd">    librosa.hybrid_cqt</span>
<span class="sd">    chroma_stft</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare a long-window STFT chromagram to the CQT chromagram</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_stft = librosa.feature.chroma_stft(y=y, sr=sr,</span>
<span class="sd">    ...                                           n_chroma=12, n_fft=4096)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_stft, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;chroma_stft&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;chroma_cqt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cqt_func</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="n">cqt</span><span class="p">,</span> <span class="s2">&quot;hybrid&quot;</span><span class="p">:</span> <span class="n">hybrid_cqt</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">bins_per_octave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bins_per_octave</span> <span class="o">=</span> <span class="n">n_chroma</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">,</span> <span class="n">n_chroma</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;bins_per_octave=</span><span class="si">{}</span><span class="s2"> must be an integer &quot;</span>
            <span class="s2">&quot;multiple of n_chroma=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">,</span> <span class="n">n_chroma</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Build the CQT if we don&#39;t have one already</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">cqt_func</span><span class="p">[</span><span class="n">cqt_mode</span><span class="p">](</span>
                <span class="n">y</span><span class="p">,</span>
                <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
                <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                <span class="n">n_bins</span><span class="o">=</span><span class="n">n_octaves</span> <span class="o">*</span> <span class="n">bins_per_octave</span><span class="p">,</span>
                <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Map to chroma</span>
    <span class="n">cq_to_chr</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">cq_to_chroma</span><span class="p">(</span>
        <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">chroma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;cf,...ft-&gt;...ct&quot;</span><span class="p">,</span> <span class="n">cq_to_chr</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span><span class="p">[</span><span class="n">chroma</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chroma</span></div>


<div class="viewcode-block" id="chroma_cens"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cens.html#librosa.feature.chroma_cens">[docs]</a><span class="k">def</span> <span class="nf">chroma_cens</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span>
    <span class="n">cqt_mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">win_len_smooth</span><span class="o">=</span><span class="mi">41</span><span class="p">,</span>
    <span class="n">smoothing_window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the chroma variant &quot;Chroma Energy Normalized&quot; (CENS)</span>

<span class="sd">    To compute CENS features, following steps are taken after obtaining chroma vectors</span>
<span class="sd">    using `chroma_cqt`: [#]_.</span>

<span class="sd">        1. L-1 normalization of each chroma vector</span>
<span class="sd">        2. Quantization of amplitude based on &quot;log-like&quot; amplitude thresholds</span>
<span class="sd">        3. (optional) Smoothing with sliding window. Default window length = 41 frames</span>
<span class="sd">        4. (not implemented) Downsampling</span>

<span class="sd">    CENS features are robust to dynamics, timbre and articulation, thus these are commonly used in audio</span>
<span class="sd">    matching and retrieval applications.</span>

<span class="sd">    .. [#] Meinard Müller and Sebastian Ewert</span>
<span class="sd">           &quot;Chroma Toolbox: MATLAB implementations for extracting variants of chroma-based audio features&quot;</span>
<span class="sd">           In Proceedings of the International Conference on Music Information Retrieval (ISMIR), 2011.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)]</span>
<span class="sd">        audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    C : np.ndarray [shape=(d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>
<span class="sd">        Default: `C1 ~= 32.7 Hz`</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in fractions of a CQT bin) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above ``fmin``</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave in the CQT.</span>

<span class="sd">        Default: 36</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    win_len_smooth : int &gt; 0 or None</span>
<span class="sd">        Length of temporal smoothing window. `None` disables temporal smoothing.</span>
<span class="sd">        Default: 41</span>

<span class="sd">    smoothing_window : str, float or tuple</span>
<span class="sd">        Type of window function for temporal smoothing. See `librosa.filters.get_window` for possible inputs.</span>
<span class="sd">        Default: &#39;hann&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cens : np.ndarray [shape=(..., n_chroma, t)]</span>
<span class="sd">        The output cens-chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt : Compute a chromagram from a constant-Q transform.</span>
<span class="sd">    chroma_stft : Compute a chromagram from an STFT spectrogram or waveform.</span>
<span class="sd">    librosa.filters.get_window : Compute a window function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare standard cqt chroma to CENS.</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cens = librosa.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;chroma_cq&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cens, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;chroma_cens&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">win_len_smooth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">win_len_smooth</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="n">win_len_smooth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;win_len_smooth=</span><span class="si">{}</span><span class="s2"> must be a positive integer or None&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">win_len_smooth</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
        <span class="n">n_octaves</span><span class="o">=</span><span class="n">n_octaves</span><span class="p">,</span>
        <span class="n">cqt_mode</span><span class="o">=</span><span class="n">cqt_mode</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># L1-Normalization</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Quantize amplitudes</span>
    <span class="n">QUANT_STEPS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="n">QUANT_WEIGHTS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>

    <span class="n">chroma_quant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">chroma</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_quant_step_idx</span><span class="p">,</span> <span class="n">cur_quant_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">QUANT_STEPS</span><span class="p">):</span>
        <span class="n">chroma_quant</span> <span class="o">+=</span> <span class="p">(</span><span class="n">chroma</span> <span class="o">&gt;</span> <span class="n">cur_quant_step</span><span class="p">)</span> <span class="o">*</span> <span class="n">QUANT_WEIGHTS</span><span class="p">[</span><span class="n">cur_quant_step_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">win_len_smooth</span><span class="p">:</span>
        <span class="c1"># Apply temporal smoothing</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">get_window</span><span class="p">(</span><span class="n">smoothing_window</span><span class="p">,</span> <span class="n">win_len_smooth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>

        <span class="c1"># reshape for broadcasting</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">chroma_quant</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cens</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">chroma_quant</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cens</span> <span class="o">=</span> <span class="n">chroma_quant</span>

    <span class="c1"># L2-Normalization</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cens</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="tonnetz"><a class="viewcode-back" href="../../../generated/librosa.feature.tonnetz.html#librosa.feature.tonnetz">[docs]</a><span class="k">def</span> <span class="nf">tonnetz</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">chroma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the tonal centroid features (tonnetz)</span>

<span class="sd">    This representation uses the method of [#]_ to project chroma features</span>
<span class="sd">    onto a 6-dimensional basis representing the perfect fifth, minor third,</span>
<span class="sd">    and major third each as two-dimensional coordinates.</span>

<span class="sd">    .. [#] Harte, C., Sandler, M., &amp; Gasser, M. (2006). &quot;Detecting Harmonic</span>
<span class="sd">           Change in Musical Audio.&quot; In Proceedings of the 1st ACM Workshop</span>
<span class="sd">           on Audio and Music Computing Multimedia (pp. 21-26).</span>
<span class="sd">           Santa Barbara, CA, USA: ACM Press. doi:10.1145/1178723.1178727.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)] or None</span>
<span class="sd">        Audio time series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    chroma : np.ndarray [shape=(n_chroma, t)] or None</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">        If `None`, a cqt chromagram is performed.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        Additional keyword arguments to `chroma_cqt`, if ``chroma`` is not</span>
<span class="sd">        pre-computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tonnetz : np.ndarray [shape(..., 6, t)]</span>
<span class="sd">        Tonal centroid features for each frame.</span>

<span class="sd">        Tonnetz dimensions:</span>
<span class="sd">            - 0: Fifth x-axis</span>
<span class="sd">            - 1: Fifth y-axis</span>
<span class="sd">            - 2: Minor x-axis</span>
<span class="sd">            - 3: Minor y-axis</span>
<span class="sd">            - 4: Major x-axis</span>
<span class="sd">            - 5: Major y-axis</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt : Compute a chromagram from a constant-Q transform.</span>
<span class="sd">    chroma_stft : Compute a chromagram from an STFT spectrogram or waveform.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute tonnetz features from the harmonic component of a song</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;nutcracker&#39;), duration=10, offset=10)</span>
<span class="sd">    &gt;&gt;&gt; y = librosa.effects.harmonic(y)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz = librosa.feature.tonnetz(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz</span>
<span class="sd">    array([[ 0.007, -0.026, ...,  0.055,  0.056],</span>
<span class="sd">           [-0.01 , -0.009, ..., -0.012, -0.017],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.006, -0.021, ..., -0.012, -0.01 ],</span>
<span class="sd">           [-0.009,  0.031, ..., -0.05 , -0.037]])</span>

<span class="sd">    Compare the tonnetz features to `chroma_cqt`</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; img1 = librosa.display.specshow(tonnetz,</span>
<span class="sd">    ...                                 y_axis=&#39;tonnetz&#39;, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Tonal Centroids (Tonnetz)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img2 = librosa.display.specshow(librosa.feature.chroma_cqt(y=y, sr=sr),</span>
<span class="sd">    ...                                 y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img1, ax=[ax[0]])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img2, ax=[ax[1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Either the audio samples or the chromagram must be &quot;</span>
            <span class="s2">&quot;passed as an argument.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Generate Transformation matrix</span>
    <span class="n">dim_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">chroma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">7.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">])</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dim_map</span><span class="p">)</span>

    <span class="c1"># Even rows compute sin()</span>
    <span class="n">V</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>  <span class="c1"># Fifths  # Minor  # Major</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span>

    <span class="c1"># Do the transform to tonnetz</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
        <span class="s2">&quot;pc,...ci-&gt;...pi&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">),</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span></div>


<span class="c1"># -- Mel spectrogram and MFCCs -- #</span>
<div class="viewcode-block" id="mfcc"><a class="viewcode-back" href="../../../generated/librosa.feature.mfcc.html#librosa.feature.mfcc">[docs]</a><span class="k">def</span> <span class="nf">mfcc</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dct_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;ortho&quot;</span><span class="p">,</span> <span class="n">lifter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mel-frequency cepstral coefficients (MFCCs)</span>

<span class="sd">    .. warning:: If multi-channel audio input ``y`` is provided, the MFCC</span>
<span class="sd">        calculation will depend on the peak loudness (in decibels) across</span>
<span class="sd">        all channels.  The result may differ from independent MFCC calculation</span>
<span class="sd">        of each channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n,)] or None</span>
<span class="sd">        audio time series. Multi-channel is supported..</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)] or None</span>
<span class="sd">        log-power Mel spectrogram</span>

<span class="sd">    n_mfcc : int &gt; 0 [scalar]</span>
<span class="sd">        number of MFCCs to return</span>

<span class="sd">    dct_type : {1, 2, 3}</span>
<span class="sd">        Discrete cosine transform (DCT) type.</span>
<span class="sd">        By default, DCT type-2 is used.</span>

<span class="sd">    norm : None or &#39;ortho&#39;</span>
<span class="sd">        If ``dct_type`` is `2 or 3`, setting ``norm=&#39;ortho&#39;`` uses an ortho-normal</span>
<span class="sd">        DCT basis.</span>

<span class="sd">        Normalization is not supported for ``dct_type=1``.</span>

<span class="sd">    lifter : number &gt;= 0</span>
<span class="sd">        If ``lifter&gt;0``, apply *liftering* (cepstral filtering) to the MFCCs::</span>

<span class="sd">            M[n, :] &lt;- M[n, :] * (1 + sin(pi * (n + 1) / lifter) * lifter / 2)</span>

<span class="sd">        Setting ``lifter &gt;= 2 * n_mfcc`` emphasizes the higher-order coefficients.</span>
<span class="sd">        As ``lifter`` increases, the coefficient weighting becomes approximately linear.</span>

<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to `melspectrogram`, if operating</span>
<span class="sd">        on time series input</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : np.ndarray [shape=(..., n_mfcc, t)]</span>
<span class="sd">        MFCC sequence</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    melspectrogram</span>
<span class="sd">    scipy.fftpack.dct</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate mfccs from a time series</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;libri1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    array([[-565.919, -564.288, ..., -426.484, -434.668],</span>
<span class="sd">           [  10.305,   12.509, ...,   88.43 ,   90.12 ],</span>
<span class="sd">           ...,</span>
<span class="sd">           [   2.807,    2.068, ...,   -6.725,   -5.159],</span>
<span class="sd">           [   2.822,    2.244, ...,   -6.198,   -6.177]], dtype=float32)</span>

<span class="sd">    Using a different hop length and HTK-style Mel frequencies</span>

<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(y=y, sr=sr, hop_length=1024, htk=True)</span>
<span class="sd">    array([[-5.471e+02, -5.464e+02, ..., -4.446e+02, -4.200e+02],</span>
<span class="sd">           [ 1.361e+01,  1.402e+01, ...,  9.764e+01,  9.869e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 4.097e-01, -2.029e+00, ..., -1.051e+01, -1.130e+01],</span>
<span class="sd">           [-1.119e-01, -1.688e+00, ..., -3.442e+00, -4.687e+00]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Use a pre-computed log-power Mel spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                    fmax=8000)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(S=librosa.power_to_db(S))</span>
<span class="sd">    array([[-559.974, -558.449, ..., -411.96 , -420.458],</span>
<span class="sd">           [  11.018,   13.046, ...,   76.972,   80.888],</span>
<span class="sd">           ...,</span>
<span class="sd">           [   2.713,    2.379, ...,    1.464,   -2.835],</span>
<span class="sd">           [   2.712,    2.619, ...,    2.209,    0.648]], dtype=float32)</span>

<span class="sd">    Get more components</span>

<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=40)</span>

<span class="sd">    Visualize the MFCC series</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(librosa.power_to_db(S, ref=np.max),</span>
<span class="sd">    ...                                x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;, fmax=8000,</span>
<span class="sd">    ...                                ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=[ax[0]])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;Mel spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(mfccs, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=[ax[1]])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;MFCC&#39;)</span>

<span class="sd">    Compare different DCT bases</span>

<span class="sd">    &gt;&gt;&gt; m_slaney = librosa.feature.mfcc(y=y, sr=sr, dct_type=2)</span>
<span class="sd">    &gt;&gt;&gt; m_htk = librosa.feature.mfcc(y=y, sr=sr, dct_type=3)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; img1 = librosa.display.specshow(m_slaney, x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;RASTAMAT / Auditory toolbox (dct_type=2)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=[ax[0]])</span>
<span class="sd">    &gt;&gt;&gt; img2 = librosa.display.specshow(m_htk, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;HTK-style (dct_type=3)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img2, ax=[ax[1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># multichannel behavior may be different due to relative noise floor differences between channels</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">dct_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">n_mfcc</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">if</span> <span class="n">lifter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># shape lifter for broadcasting</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_mfcc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">lifter</span><span class="p">)</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">expand_to</span><span class="p">(</span><span class="n">LI</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">M</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">lifter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">LI</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">lifter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;MFCC lifter=</span><span class="si">{}</span><span class="s2"> must be a non-negative number&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lifter</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="melspectrogram"><a class="viewcode-back" href="../../../generated/librosa.feature.melspectrogram.html#librosa.feature.melspectrogram">[docs]</a><span class="k">def</span> <span class="nf">melspectrogram</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a mel-scaled spectrogram.</span>

<span class="sd">    If a spectrogram input ``S`` is provided, then it is mapped directly onto</span>
<span class="sd">    the mel basis by ``mel_f.dot(S)``.</span>

<span class="sd">    If a time-series input ``y, sr`` is provided, then its magnitude spectrogram</span>
<span class="sd">    ``S`` is first computed, and then mapped onto the mel scale by</span>
<span class="sd">    ``mel_f.dot(S**power)``.</span>

<span class="sd">    By default, ``power=2`` operates on a power spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(..., n)] or None</span>
<span class="sd">        audio time-series. Multi-channel is supported.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of ``y``</span>

<span class="sd">    S : np.ndarray [shape=(..., d, t)]</span>
<span class="sd">        spectrogram</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        length of the FFT window</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames.</span>
<span class="sd">        See `librosa.stft`</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match ``n_fft``.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.windows.hann`</span>
<span class="sd">        - a vector or array of length ``n_fft``</span>

<span class="sd">        .. see also:: `librosa.filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal ``y`` is padded so that frame</span>
<span class="sd">          ``t`` is centered at ``y[t * hop_length]``.</span>
<span class="sd">        - If `False`, then frame ``t`` begins at ``y[t * hop_length]``</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If ``center=True``, the padding mode to use at the edges of the signal.</span>

<span class="sd">        By default, STFT uses zero padding.</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the magnitude melspectrogram.</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Mel filter bank parameters.</span>

<span class="sd">        See `librosa.filters.mel` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray [shape=(..., n_mels, t)]</span>
<span class="sd">        Mel spectrogram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.mel : Mel filter bank construction</span>
<span class="sd">    librosa.stft : Short-time Fourier Transform</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.melspectrogram(y=y, sr=sr)</span>
<span class="sd">    array([[3.837e-06, 1.451e-06, ..., 8.352e-14, 1.296e-11],</span>
<span class="sd">           [2.213e-05, 7.866e-06, ..., 8.532e-14, 1.329e-11],</span>
<span class="sd">           ...,</span>
<span class="sd">           [1.115e-05, 5.192e-06, ..., 3.675e-08, 2.470e-08],</span>
<span class="sd">           [6.473e-07, 4.402e-07, ..., 1.794e-08, 2.908e-08]],</span>
<span class="sd">          dtype=float32)</span>

<span class="sd">    Using a pre-computed power spectrogram would give the same result:</span>

<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))**2</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(S=D, sr=sr)</span>

<span class="sd">    Display of mel-frequency spectrogram coefficients, with custom</span>
<span class="sd">    arguments for mel filterbank construction (default is fmax=sr/2):</span>

<span class="sd">    &gt;&gt;&gt; # Passing through arguments to the Mel filters</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                     fmax=8000)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; S_dB = librosa.power_to_db(S, ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; img = librosa.display.specshow(S_dB, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          y_axis=&#39;mel&#39;, sr=sr,</span>
<span class="sd">    ...                          fmax=8000, ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img, ax=ax, format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set(title=&#39;Mel-frequency spectrogram&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Build a Mel filter</span>
    <span class="n">mel_basis</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ft,mf-&gt;...mt&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">mel_basis</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013--2022, librosa development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.9.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="spectral.html">0.9.0</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171031946-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171031946-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>