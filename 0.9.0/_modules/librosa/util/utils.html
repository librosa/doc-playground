

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>librosa.util.utils &mdash; librosa 0.9.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/librosa_logo_text.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.9.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../multichannel.html">Multi-channel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../recordings.html">Example files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.util.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.util.utils</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Utility functions&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">as_strided</span>

<span class="kn">from</span> <span class="nn">.._cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">.deprecation</span> <span class="kn">import</span> <span class="n">Deprecated</span>

<span class="c1"># Constrain STFT block sizes to 256 KB</span>
<span class="n">MAX_MEM_BLOCK</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;MAX_MEM_BLOCK&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frame&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pad_center&quot;</span><span class="p">,</span>
    <span class="s2">&quot;expand_to&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fix_length&quot;</span><span class="p">,</span>
    <span class="s2">&quot;valid_audio&quot;</span><span class="p">,</span>
    <span class="s2">&quot;valid_int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;valid_intervals&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fix_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;axis_sort&quot;</span><span class="p">,</span>
    <span class="s2">&quot;localmax&quot;</span><span class="p">,</span>
    <span class="s2">&quot;localmin&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize&quot;</span><span class="p">,</span>
    <span class="s2">&quot;peak_pick&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sparsify_rows&quot;</span><span class="p">,</span>
    <span class="s2">&quot;shear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;stack&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fill_off_diagonal&quot;</span><span class="p">,</span>
    <span class="s2">&quot;index_to_slice&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sync&quot;</span><span class="p">,</span>
    <span class="s2">&quot;softmask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;buf_to_float&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tiny&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cyclic_gradient&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dtype_r2c&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dtype_c2r&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count_unique&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_unique&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="frame"><a class="viewcode-back" href="../../../generated/librosa.util.frame.html#librosa.util.frame">[docs]</a><span class="k">def</span> <span class="nf">frame</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">writeable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slice a data array into (overlapping) frames.</span>

<span class="sd">    This implementation uses low-level stride manipulation to avoid</span>
<span class="sd">    making a copy of the data.  The resulting frame representation</span>
<span class="sd">    is a new view of the same input data.</span>

<span class="sd">    For example, a one-dimensional input ``x = [0, 1, 2, 3, 4, 5, 6]``</span>
<span class="sd">    can be framed with frame length 3 and hop length 2 in two ways.</span>
<span class="sd">    The first (``axis=-1``), results in the array ``x_frames``::</span>

<span class="sd">        [[0, 2, 4],</span>
<span class="sd">         [1, 3, 5],</span>
<span class="sd">         [2, 4, 6]]</span>

<span class="sd">    where each column ``x_frames[:, i]`` contains a contiguous slice of</span>
<span class="sd">    the input ``x[i * hop_length : i * hop_length + frame_length]``.</span>

<span class="sd">    The second way (``axis=0``) results in the array ``x_frames``::</span>

<span class="sd">        [[0, 1, 2],</span>
<span class="sd">         [2, 3, 4],</span>
<span class="sd">         [4, 5, 6]]</span>

<span class="sd">    where each row ``x_frames[i]`` contains a contiguous slice of the input.</span>

<span class="sd">    This generalizes to higher dimensional inputs, as shown in the examples below.</span>
<span class="sd">    In general, the framing operation increments by 1 the number of dimensions,</span>
<span class="sd">    adding a new &quot;frame axis&quot; either before the framing axis (if ``axis &lt; 0``)</span>
<span class="sd">    or after the framing axis (if ``axis &gt;= 0``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Array to frame</span>
<span class="sd">    frame_length : int &gt; 0 [scalar]</span>
<span class="sd">        Length of the frame</span>
<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Number of steps to advance between frames</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to frame.</span>
<span class="sd">    writeable : bool</span>
<span class="sd">        If ``True``, then the framed view of ``x`` is read-only.</span>
<span class="sd">        If ``False``, then the framed view is read-write.  Note that writing to the framed view</span>
<span class="sd">        will also write to the input array ``x`` in this case.</span>
<span class="sd">    subok : bool</span>
<span class="sd">        If True, sub-classes will be passed-through, otherwise the returned array will be</span>
<span class="sd">        forced to be a base-class array (default).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_frames : np.ndarray [shape=(..., frame_length, N_FRAMES, ...)]</span>
<span class="sd">        A framed view of ``x``, for example with ``axis=-1`` (framing on the last dimension)::</span>

<span class="sd">            x_frames[..., j] == x[..., j * hop_length : j * hop_length + frame_length]</span>

<span class="sd">        If ``axis=0`` (framing on the first dimension), then::</span>

<span class="sd">            x_frames[j] = x[j * hop_length : j * hop_length + frame_length]</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``x.shape[axis] &lt; frame_length``, there is not enough data to fill one frame.</span>

<span class="sd">        If ``hop_length &lt; 1``, frames cannot advance.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.lib.stride_tricks.as_strided</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Extract 2048-sample frames from monophonic signal with a hop of 64 samples per frame</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; frames = librosa.util.frame(y, frame_length=2048, hop_length=64)</span>
<span class="sd">    &gt;&gt;&gt; frames</span>
<span class="sd">    array([[-1.407e-03, -2.604e-02, ..., -1.795e-05, -8.108e-06],</span>
<span class="sd">           [-4.461e-04, -3.721e-02, ..., -1.573e-05, -1.652e-05],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 7.960e-02, -2.335e-01, ..., -6.815e-06,  1.266e-05],</span>
<span class="sd">           [ 9.568e-02, -1.252e-01, ...,  7.397e-06, -1.921e-05]],</span>
<span class="sd">          dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; y.shape</span>
<span class="sd">    (117601,)</span>

<span class="sd">    &gt;&gt;&gt; frames.shape</span>
<span class="sd">    (2048, 1806)</span>

<span class="sd">    Or frame along the first axis instead of the last:</span>

<span class="sd">    &gt;&gt;&gt; frames = librosa.util.frame(y, frame_length=2048, hop_length=64, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; frames.shape</span>
<span class="sd">    (1806, 2048)</span>

<span class="sd">    Frame a stereo signal:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;, hq=True), mono=False)</span>
<span class="sd">    &gt;&gt;&gt; y.shape</span>
<span class="sd">    (2, 117601)</span>
<span class="sd">    &gt;&gt;&gt; frames = librosa.util.frame(y, frame_length=2048, hop_length=64)</span>
<span class="sd">    (2, 2048, 1806)</span>

<span class="sd">    Carve an STFT into fixed-length patches of 32 frames with 50% overlap</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; S.shape</span>
<span class="sd">    (1025, 230)</span>
<span class="sd">    &gt;&gt;&gt; S_patch = librosa.util.frame(S, frame_length=32, hop_length=16)</span>
<span class="sd">    &gt;&gt;&gt; S_patch.shape</span>
<span class="sd">    (1025, 32, 13)</span>
<span class="sd">    &gt;&gt;&gt; # The first patch contains the first 32 frames of S</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(S_patch[:, :, 0], S[:, :32])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # The second patch contains frames 16 to 16+32=48, and so on</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(S_patch[:, :, 1], S[:, 16:48])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This implementation is derived from numpy.lib.stride_tricks.sliding_window_view (1.20.0)</span>
    <span class="c1"># https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.sliding_window_view.html</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">frame_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Input is too short (n=</span><span class="si">{:d}</span><span class="s2">)&quot;</span>
            <span class="s2">&quot; for frame_length=</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">frame_length</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Invalid hop_length: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hop_length</span><span class="p">))</span>

    <span class="c1"># put our new within-frame axis at the end for now</span>
    <span class="n">out_strides</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]])</span>

    <span class="c1"># Reduce the shape on the framing axis</span>
    <span class="n">x_shape_trimmed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_shape_trimmed</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">frame_length</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x_shape_trimmed</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">frame_length</span><span class="p">])</span>
    <span class="n">xw</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">out_strides</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">writeable</span><span class="o">=</span><span class="n">writeable</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">target_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">xw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">xw</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target_axis</span><span class="p">)</span>

    <span class="c1"># Downsample along the target axis</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">xw</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xw</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span></div>


<div class="viewcode-block" id="valid_audio"><a class="viewcode-back" href="../../../generated/librosa.util.valid_audio.html#librosa.util.valid_audio">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="n">Deprecated</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether a variable contains valid audio data.</span>

<span class="sd">    The following conditions must be satisfied:</span>

<span class="sd">    - ``type(y)`` is ``np.ndarray``</span>
<span class="sd">    - ``y.dtype`` is floating-point</span>
<span class="sd">    - ``y.ndim != 0`` (must have at least one dimension)</span>
<span class="sd">    - ``np.isfinite(y).all()`` samples must be all finite values</span>

<span class="sd">    If ``mono`` is specified, then we additionally require</span>
<span class="sd">    - ``y.ndim == 1``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        The input data to validate</span>

<span class="sd">    mono : bool</span>
<span class="sd">        Whether or not to require monophonic audio</span>

<span class="sd">        .. warning:: The ``mono`` parameter is deprecated in version 0.9 and will be</span>
<span class="sd">          removed in 0.10.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if all tests pass</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        In any of the conditions specified above fails</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 20.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # By default, valid_audio allows only mono signals</span>
<span class="sd">    &gt;&gt;&gt; filepath = librosa.ex(&#39;trumpet&#39;, hq=True)</span>
<span class="sd">    &gt;&gt;&gt; y_mono, sr = librosa.load(filepath, mono=True)</span>
<span class="sd">    &gt;&gt;&gt; y_stereo, _ = librosa.load(filepath, mono=False)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.valid_audio(y_mono), librosa.util.valid_audio(y_stereo)</span>
<span class="sd">    True, False</span>

<span class="sd">    &gt;&gt;&gt; # To allow stereo signals, set mono=False</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.valid_audio(y_stereo, mono=False)</span>
<span class="sd">    True</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.float32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Audio data must be of type numpy.ndarray&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Audio data must be floating-point&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Audio data must be at least one-dimensional, given y.shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mono</span><span class="p">,</span> <span class="n">Deprecated</span><span class="p">):</span>
        <span class="n">mono</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">mono</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid shape for monophonic audio: &quot;</span>
            <span class="s2">&quot;ndim=</span><span class="si">{:d}</span><span class="s2">, shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Audio buffer is not finite everywhere&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="valid_int"><a class="viewcode-back" href="../../../generated/librosa.util.valid_int.html#librosa.util.valid_int">[docs]</a><span class="k">def</span> <span class="nf">valid_int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure that an input value is integer-typed.</span>
<span class="sd">    This is primarily useful for ensuring integrable-valued</span>
<span class="sd">    array indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : number</span>
<span class="sd">        A scalar value to be cast to int</span>
<span class="sd">    cast : function [optional]</span>
<span class="sd">        A function to modify ``x`` before casting.</span>
<span class="sd">        Default: `np.floor`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_int : int</span>
<span class="sd">        ``x_int = int(cast(x))``</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``cast`` is provided and is not callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">cast</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;cast parameter must be callable&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<div class="viewcode-block" id="valid_intervals"><a class="viewcode-back" href="../../../generated/librosa.util.valid_intervals.html#librosa.util.valid_intervals">[docs]</a><span class="k">def</span> <span class="nf">valid_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure that an array is a valid representation of time intervals:</span>

<span class="sd">        - intervals.ndim == 2</span>
<span class="sd">        - intervals.shape[1] == 2</span>
<span class="sd">        - intervals[i, 0] &lt;= intervals[i, 1] for all i</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals : np.ndarray [shape=(n, 2)]</span>
<span class="sd">        set of time intervals</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if ``intervals`` passes validation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">intervals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;intervals must have shape (n, 2)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;intervals=</span><span class="si">{}</span><span class="s2"> must have non-negative durations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="pad_center"><a class="viewcode-back" href="../../../generated/librosa.util.pad_center.html#librosa.util.pad_center">[docs]</a><span class="k">def</span> <span class="nf">pad_center</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pad an array to a target length along a target axis.</span>

<span class="sd">    This differs from `np.pad` by centering the data prior to padding,</span>
<span class="sd">    analogous to `str.center`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a vector</span>
<span class="sd">    &gt;&gt;&gt; data = np.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, size=10, mode=&#39;constant&#39;)</span>
<span class="sd">    array([ 0.,  0.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.])</span>

<span class="sd">    &gt;&gt;&gt; # Pad a matrix along its first dimension</span>
<span class="sd">    &gt;&gt;&gt; data = np.ones((3, 5))</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, size=7, axis=0)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; # Or its second dimension</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, size=7, axis=1)</span>
<span class="sd">    array([[ 0.,  1.,  1.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  1.,  1.,  0.]])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Vector to be padded and centered</span>
<span class="sd">    size : int &gt;= len(data) [scalar]</span>
<span class="sd">        Length to pad ``data``</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad and center the data</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        arguments passed to `np.pad`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_padded : np.ndarray</span>
<span class="sd">        ``data`` centered and padded to length ``size`` along the</span>
<span class="sd">        specified axis</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``size &lt; data.shape[axis]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.pad</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="n">lpad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">lengths</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lpad</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">lpad</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">lpad</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Target size (</span><span class="si">{:d}</span><span class="s2">) must be &quot;</span> <span class="s2">&quot;at least input size (</span><span class="si">{:d}</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="expand_to"><a class="viewcode-back" href="../../../generated/librosa.util.expand_to.html#librosa.util.expand_to">[docs]</a><span class="k">def</span> <span class="nf">expand_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Expand the dimensions of an input array with</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        The input array</span>
<span class="sd">    ndim : int</span>
<span class="sd">        The number of dimensions to expand to.  Must be at least ``x.ndim``</span>
<span class="sd">    axes : int or slice</span>
<span class="sd">        The target axis or axes to preserve from x.</span>
<span class="sd">        All other axes will have length 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_exp : np.ndarray</span>
<span class="sd">        The expanded version of ``x``, satisfying the following:</span>
<span class="sd">            ``x_exp[axes] == x``</span>
<span class="sd">            ``x_exp.ndim == ndim``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    np.expand_dims</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Expand a 1d array into an (n, 1) shape</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.expand_to(x, ndim=2, axes=0)</span>
<span class="sd">    array([[0],</span>
<span class="sd">       [1],</span>
<span class="sd">       [2]])</span>

<span class="sd">    Expand a 1d array into a (1, n) shape</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.expand_to(x, ndim=2, axes=1)</span>
<span class="sd">    array([[0, 1, 2]])</span>

<span class="sd">    Expand a 2d array into (1, n, m, 1) shape</span>

<span class="sd">    &gt;&gt;&gt; x = np.vander(np.arange(3))</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.expand_to(x, ndim=4, axes=[1,2]).shape</span>
<span class="sd">    (1, 3, 3, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Force axes into a tuple</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">axes</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Shape mismatch between axes=</span><span class="si">{}</span><span class="s2"> and input x.shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot expand x.shape=</span><span class="si">{}</span><span class="s2"> to fewer dimensions ndim=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">axi</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="fix_length"><a class="viewcode-back" href="../../../generated/librosa.util.fix_length.html#librosa.util.fix_length">[docs]</a><span class="k">def</span> <span class="nf">fix_length</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fix the length an array ``data`` to exactly ``size`` along a target axis.</span>

<span class="sd">    If ``data.shape[axis] &lt; n``, pad according to the provided kwargs.</span>
<span class="sd">    By default, ``data`` is padded with trailing zeros.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y = np.arange(7)</span>
<span class="sd">    &gt;&gt;&gt; # Default: pad with zeros</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, size=10)</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; # Trim to a desired length</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, size=5)</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; # Use edge-padding instead of zeros</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, size=10, mode=&#39;edge&#39;)</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 6, 6, 6])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        array to be length-adjusted</span>
<span class="sd">    size : int &gt;= 0 [scalar]</span>
<span class="sd">        desired length of the array</span>
<span class="sd">    axis : int, &lt;= data.ndim</span>
<span class="sd">        axis along which to fix length</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Parameters to ``np.pad``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_fixed : np.ndarray [shape=data.shape]</span>
<span class="sd">        ``data`` either trimmed or padded to length ``size``</span>
<span class="sd">        along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.pad</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">lengths</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="fix_frames"><a class="viewcode-back" href="../../../generated/librosa.util.fix_frames.html#librosa.util.fix_frames">[docs]</a><span class="k">def</span> <span class="nf">fix_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fix a list of frames to lie within [x_min, x_max]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a list of frame indices</span>
<span class="sd">    &gt;&gt;&gt; frames = np.arange(0, 1000.0, 50)</span>
<span class="sd">    &gt;&gt;&gt; frames</span>
<span class="sd">    array([   0.,   50.,  100.,  150.,  200.,  250.,  300.,  350.,</span>
<span class="sd">            400.,  450.,  500.,  550.,  600.,  650.,  700.,  750.,</span>
<span class="sd">            800.,  850.,  900.,  950.])</span>
<span class="sd">    &gt;&gt;&gt; # Clip to span at most 250</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=250)</span>
<span class="sd">    array([  0,  50, 100, 150, 200, 250])</span>
<span class="sd">    &gt;&gt;&gt; # Or pad to span up to 2500</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=2500)</span>
<span class="sd">    array([   0,   50,  100,  150,  200,  250,  300,  350,  400,</span>
<span class="sd">            450,  500,  550,  600,  650,  700,  750,  800,  850,</span>
<span class="sd">            900,  950, 2500])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=2500, pad=False)</span>
<span class="sd">    array([  0,  50, 100, 150, 200, 250, 300, 350, 400, 450, 500,</span>
<span class="sd">           550, 600, 650, 700, 750, 800, 850, 900, 950])</span>

<span class="sd">    &gt;&gt;&gt; # Or starting away from zero</span>
<span class="sd">    &gt;&gt;&gt; frames = np.arange(200, 500, 33)</span>
<span class="sd">    &gt;&gt;&gt; frames</span>
<span class="sd">    array([200, 233, 266, 299, 332, 365, 398, 431, 464, 497])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames)</span>
<span class="sd">    array([  0, 200, 233, 266, 299, 332, 365, 398, 431, 464, 497])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=500)</span>
<span class="sd">    array([  0, 200, 233, 266, 299, 332, 365, 398, 431, 464, 497,</span>
<span class="sd">           500])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frames : np.ndarray [shape=(n_frames,)]</span>
<span class="sd">        List of non-negative frame indices</span>
<span class="sd">    x_min : int &gt;= 0 or None</span>
<span class="sd">        Minimum allowed frame index</span>
<span class="sd">    x_max : int &gt;= 0 or None</span>
<span class="sd">        Maximum allowed frame index</span>
<span class="sd">    pad : boolean</span>
<span class="sd">        If ``True``, then ``frames`` is expanded to span the full range</span>
<span class="sd">        ``[x_min, x_max]``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fixed_frames : np.ndarray [shape=(n_fixed_frames,), dtype=int]</span>
<span class="sd">        Fixed frame indices, flattened and sorted</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``frames`` contains negative values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">frames</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Negative frame index detected&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">pad_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pad_data</span><span class="p">,</span> <span class="n">frames</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frames</span> <span class="o">&gt;=</span> <span class="n">x_min</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frames</span> <span class="o">&lt;=</span> <span class="n">x_max</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="axis_sort"><a class="viewcode-back" href="../../../generated/librosa.util.axis_sort.html#librosa.util.axis_sort">[docs]</a><span class="k">def</span> <span class="nf">axis_sort</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort an array along its rows or columns.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Visualize NMF output for a spectrogram S</span>

<span class="sd">    &gt;&gt;&gt; # Sort the columns of W by peak frequency bin</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; W, H = librosa.decompose.decompose(S, n_components=64)</span>
<span class="sd">    &gt;&gt;&gt; W_sort = librosa.util.axis_sort(W)</span>

<span class="sd">    Or sort by the lowest frequency bin</span>

<span class="sd">    &gt;&gt;&gt; W_sort = librosa.util.axis_sort(W, value=np.argmin)</span>

<span class="sd">    Or sort the rows instead of the columns</span>

<span class="sd">    &gt;&gt;&gt; W_sort_rows = librosa.util.axis_sort(W, axis=0)</span>

<span class="sd">    Get the sorting index also, and use it to permute the rows of H</span>

<span class="sd">    &gt;&gt;&gt; W_sort, idx = librosa.util.axis_sort(W, index=True)</span>
<span class="sd">    &gt;&gt;&gt; H_sort = H[idx, :]</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, ncols=2)</span>
<span class="sd">    &gt;&gt;&gt; img_w = librosa.display.specshow(librosa.amplitude_to_db(W, ref=np.max),</span>
<span class="sd">    ...                                  y_axis=&#39;log&#39;, ax=ax[0, 0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0, 0].set(title=&#39;W&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0, 0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; img_act = librosa.display.specshow(H, x_axis=&#39;time&#39;, ax=ax[0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ax[0, 1].set(title=&#39;H&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0, 1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(W_sort,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, ax=ax[1, 0])</span>
<span class="sd">    &gt;&gt;&gt; ax[1, 0].set(title=&#39;W sorted&#39;)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(H_sort, x_axis=&#39;time&#39;, ax=ax[1, 1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1, 1].set(title=&#39;H sorted&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1, 1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img_w, ax=ax[:, 0], orientation=&#39;horizontal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.colorbar(img_act, ax=ax[:, 1], orientation=&#39;horizontal&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, n)]</span>
<span class="sd">        Array to be sorted</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The axis along which to compute the sorting values</span>

<span class="sd">        - ``axis=0`` to sort rows by peak column index</span>
<span class="sd">        - ``axis=1`` to sort columns by peak row index</span>

<span class="sd">    index : boolean [scalar]</span>
<span class="sd">        If true, returns the index array as well as the permuted data.</span>

<span class="sd">    value : function</span>
<span class="sd">        function to return the index corresponding to the sort order.</span>
<span class="sd">        Default: `np.argmax`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_sort : np.ndarray [shape=(d, n)]</span>
<span class="sd">        ``S`` with the columns or rows permuted in sorting order</span>
<span class="sd">    idx : np.ndarray (optional) [shape=(d,) or (n,)]</span>
<span class="sd">        If ``index == True``, the sorting index used to permute ``S``.</span>
<span class="sd">        Length of ``idx`` corresponds to the selected ``axis``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``S`` does not have exactly 2 dimensions (``S.ndim != 2``)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span>

    <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;axis_sort is only defined for 2D arrays&quot;</span><span class="p">)</span>

    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span>

    <span class="n">sort_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">sort_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

    <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sort_slice</span><span class="p">)],</span> <span class="n">idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sort_slice</span><span class="p">)]</span></div>


<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../../generated/librosa.util.normalize.html#librosa.util.normalize">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize an array along a chosen axis.</span>

<span class="sd">    Given a norm (described below) and a target axis, the input</span>
<span class="sd">    array is scaled so that::</span>

<span class="sd">        norm(S, axis=axis) == 1</span>

<span class="sd">    For example, ``axis=0`` normalizes each column of a 2-d array</span>
<span class="sd">    by aggregating over the rows (0-axis).</span>
<span class="sd">    Similarly, ``axis=1`` normalizes each row of a 2-d array.</span>

<span class="sd">    This function also supports thresholding small-norm slices:</span>
<span class="sd">    any slice (i.e., row or column) with norm below a specified</span>
<span class="sd">    ``threshold`` can be left un-normalized, set to all-zeros, or</span>
<span class="sd">    filled with uniform non-zero values that normalize to 1.</span>

<span class="sd">    Note: the semantics of this function differ from</span>
<span class="sd">    `scipy.linalg.norm` in two ways: multi-dimensional arrays</span>
<span class="sd">    are supported, but matrix-norms are not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The array to normalize</span>

<span class="sd">    norm : {np.inf, -np.inf, 0, float &gt; 0, None}</span>
<span class="sd">        - `np.inf`  : maximum absolute value</span>
<span class="sd">        - `-np.inf` : minimum absolute value</span>
<span class="sd">        - `0`    : number of non-zeros (the support)</span>
<span class="sd">        - float  : corresponding l_p norm</span>
<span class="sd">            See `scipy.linalg.norm` for details.</span>
<span class="sd">        - None : no normalization is performed</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        Axis along which to compute the norm.</span>

<span class="sd">    threshold : number &gt; 0 [optional]</span>
<span class="sd">        Only the columns (or rows) with norm at least ``threshold`` are</span>
<span class="sd">        normalized.</span>

<span class="sd">        By default, the threshold is determined from</span>
<span class="sd">        the numerical precision of ``S.dtype``.</span>

<span class="sd">    fill : None or bool</span>
<span class="sd">        If None, then columns (or rows) with norm below ``threshold``</span>
<span class="sd">        are left as is.</span>

<span class="sd">        If False, then columns (rows) with norm below ``threshold``</span>
<span class="sd">        are set to 0.</span>

<span class="sd">        If True, then columns (rows) with norm below ``threshold``</span>
<span class="sd">        are filled uniformly such that the corresponding norm is 1.</span>

<span class="sd">        .. note:: ``fill=True`` is incompatible with ``norm=0`` because</span>
<span class="sd">            no uniform vector exists with l0 &quot;norm&quot; equal to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_norm : np.ndarray [shape=S.shape]</span>
<span class="sd">        Normalized array</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``norm`` is not among the valid types defined above</span>

<span class="sd">        If ``S`` is not finite</span>

<span class="sd">        If ``fill=True`` and ``norm=0``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.linalg.norm</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Construct an example matrix</span>
<span class="sd">    &gt;&gt;&gt; S = np.vander(np.arange(-2.0, 2.0))</span>
<span class="sd">    &gt;&gt;&gt; S</span>
<span class="sd">    array([[-8.,  4., -2.,  1.],</span>
<span class="sd">           [-1.,  1., -1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; # Max (l-infinity)-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Max (l-infinity)-normalize the rows</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, axis=1)</span>
<span class="sd">    array([[-1.   ,  0.5  , -0.25 ,  0.125],</span>
<span class="sd">           [-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 1.   ,  1.   ,  1.   ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # l1-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=1)</span>
<span class="sd">    array([[-0.8  ,  0.667, -0.5  ,  0.25 ],</span>
<span class="sd">           [-0.1  ,  0.167, -0.25 ,  0.25 ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.25 ],</span>
<span class="sd">           [ 0.1  ,  0.167,  0.25 ,  0.25 ]])</span>
<span class="sd">    &gt;&gt;&gt; # l2-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=2)</span>
<span class="sd">    array([[-0.985,  0.943, -0.816,  0.5  ],</span>
<span class="sd">           [-0.123,  0.236, -0.408,  0.5  ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.5  ],</span>
<span class="sd">           [ 0.123,  0.236,  0.408,  0.5  ]])</span>

<span class="sd">    &gt;&gt;&gt; # Thresholding and filling</span>
<span class="sd">    &gt;&gt;&gt; S[:, -1] = 1e-308</span>
<span class="sd">    &gt;&gt;&gt; S</span>
<span class="sd">    array([[ -8.000e+000,   4.000e+000,  -2.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [ -1.000e+000,   1.000e+000,  -1.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  0.000e+000,   0.000e+000,   0.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  1.000e+000,   1.000e+000,   1.000e+000,</span>
<span class="sd">              1.000e-308]])</span>

<span class="sd">    &gt;&gt;&gt; # By default, small-norm columns are left untouched</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S)</span>
<span class="sd">    array([[ -1.000e+000,   1.000e+000,  -1.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [ -1.250e-001,   2.500e-001,  -5.000e-001,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  0.000e+000,   0.000e+000,   0.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  1.250e-001,   2.500e-001,   5.000e-001,</span>
<span class="sd">              1.000e-308]])</span>
<span class="sd">    &gt;&gt;&gt; # Small-norm columns can be zeroed out</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, fill=False)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  0.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  0.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Or set to constant with unit-norm</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, fill=True)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # With an l1 norm instead of max-norm</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=1, fill=True)</span>
<span class="sd">    array([[-0.8  ,  0.667, -0.5  ,  0.25 ],</span>
<span class="sd">           [-0.1  ,  0.167, -0.25 ,  0.25 ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.25 ],</span>
<span class="sd">           [ 0.1  ,  0.167,  0.25 ,  0.25 ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Avoid div-by-zero</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">tiny</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;threshold=</span><span class="si">{}</span><span class="s2"> must be strictly &quot;</span> <span class="s2">&quot;positive&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">fill</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;fill=</span><span class="si">{}</span><span class="s2"> must be None or boolean&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Input must be finite&quot;</span><span class="p">)</span>

    <span class="c1"># All norms only depend on magnitude, let&#39;s do that first</span>
    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># For max/min norms, filling with 1 works</span>
    <span class="n">fill_norm</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Cannot normalize with norm=0 and fill=True&quot;</span><span class="p">)</span>

        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mag</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">norm</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag</span> <span class="o">**</span> <span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_norm</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">size</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_norm</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Unsupported norm: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">norm</span><span class="p">)))</span>

    <span class="c1"># indices where norm is below the threshold</span>
    <span class="n">small_idx</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="n">Snorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Leave small indices un-normalized</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">Snorm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>

    <span class="k">elif</span> <span class="n">fill</span><span class="p">:</span>
        <span class="c1"># If we have a non-zero fill value, we locate those entries by</span>
        <span class="c1"># doing a nan-divide.</span>
        <span class="c1"># If S was finite, then length is finite (except for small positions)</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">Snorm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>
        <span class="n">Snorm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Snorm</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fill_norm</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Set small values to zero by doing an inf-divide.</span>
        <span class="c1"># This is safe (by IEEE-754) as long as S is finite.</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Snorm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>

    <span class="k">return</span> <span class="n">Snorm</span></div>


<div class="viewcode-block" id="localmax"><a class="viewcode-back" href="../../../generated/librosa.util.localmax.html#librosa.util.localmax">[docs]</a><span class="k">def</span> <span class="nf">localmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find local maxima in an array</span>

<span class="sd">    An element ``x[i]`` is considered a local maximum if the following</span>
<span class="sd">    conditions are met:</span>

<span class="sd">    - ``x[i] &gt; x[i-1]``</span>
<span class="sd">    - ``x[i] &gt;= x[i+1]``</span>

<span class="sd">    Note that the first condition is strict, and that the first element</span>
<span class="sd">    ``x[0]`` will never be considered as a local maximum.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 0, 1, 2, -1, 0, -2, 1])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x)</span>
<span class="sd">    array([False, False, False,  True, False,  True, False,  True], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; # Two-dimensional example</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,0,1], [2, -1, 0], [2, 1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x, axis=0)</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [ True, False, False],</span>
<span class="sd">           [False,  True,  True]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x, axis=1)</span>
<span class="sd">    array([[False, False,  True],</span>
<span class="sd">           [False, False,  True],</span>
<span class="sd">           [False, False,  True]], dtype=bool)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [shape=(d1,d2,...)]</span>
<span class="sd">        input vector or array</span>
<span class="sd">    axis : int</span>
<span class="sd">        axis along which to compute local maximality</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : np.ndarray [shape=x.shape, dtype=bool]</span>
<span class="sd">        indicator array of local maximality along ``axis``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    localmin</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">paddings</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">paddings</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">x_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>

    <span class="n">inds1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">inds2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x_pad</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds1</span><span class="p">)])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x_pad</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds2</span><span class="p">)])</span></div>


<div class="viewcode-block" id="localmin"><a class="viewcode-back" href="../../../generated/librosa.util.localmin.html#librosa.util.localmin">[docs]</a><span class="k">def</span> <span class="nf">localmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find local minima in an array</span>

<span class="sd">    An element ``x[i]`` is considered a local minimum if the following</span>
<span class="sd">    conditions are met:</span>

<span class="sd">    - ``x[i] &lt; x[i-1]``</span>
<span class="sd">    - ``x[i] &lt;= x[i+1]``</span>

<span class="sd">    Note that the first condition is strict, and that the first element</span>
<span class="sd">    ``x[0]`` will never be considered as a local minimum.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 0, 1, 2, -1, 0, -2, 1])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmin(x)</span>
<span class="sd">    array([False,  True, False, False,  True, False,  True, False])</span>

<span class="sd">    &gt;&gt;&gt; # Two-dimensional example</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,0,1], [2, -1, 0], [2, 1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmin(x, axis=0)</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [False,  True,  True],</span>
<span class="sd">           [False, False, False]])</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.localmin(x, axis=1)</span>
<span class="sd">    array([[False,  True, False],</span>
<span class="sd">           [False,  True, False],</span>
<span class="sd">           [False,  True, False]])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [shape=(d1,d2,...)]</span>
<span class="sd">        input vector or array</span>
<span class="sd">    axis : int</span>
<span class="sd">        axis along which to compute local minimality</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : np.ndarray [shape=x.shape, dtype=bool]</span>
<span class="sd">        indicator array of local minimality along ``axis``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    localmax</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">paddings</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">paddings</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">x_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>

    <span class="n">inds1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">inds2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x_pad</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds1</span><span class="p">)])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x_pad</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds2</span><span class="p">)])</span></div>


<div class="viewcode-block" id="peak_pick"><a class="viewcode-back" href="../../../generated/librosa.util.peak_pick.html#librosa.util.peak_pick">[docs]</a><span class="k">def</span> <span class="nf">peak_pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">pre_max</span><span class="p">,</span> <span class="n">post_max</span><span class="p">,</span> <span class="n">pre_avg</span><span class="p">,</span> <span class="n">post_avg</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">wait</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses a flexible heuristic to pick peaks in a signal.</span>

<span class="sd">    A sample n is selected as an peak if the corresponding ``x[n]``</span>
<span class="sd">    fulfills the following three conditions:</span>

<span class="sd">    1. ``x[n] == max(x[n - pre_max:n + post_max])``</span>
<span class="sd">    2. ``x[n] &gt;= mean(x[n - pre_avg:n + post_avg]) + delta``</span>
<span class="sd">    3. ``n - previous_n &gt; wait``</span>

<span class="sd">    where ``previous_n`` is the last sample picked as a peak (greedily).</span>

<span class="sd">    This implementation is based on [#]_ and [#]_.</span>

<span class="sd">    .. [#] Boeck, Sebastian, Florian Krebs, and Markus Schedl.</span>
<span class="sd">        &quot;Evaluating the Online Capabilities of Onset Detection Methods.&quot; ISMIR.</span>
<span class="sd">        2012.</span>

<span class="sd">    .. [#] https://github.com/CPJKU/onset_detection/blob/master/onset_program.py</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [shape=(n,)]</span>
<span class="sd">        input signal to peak picks from</span>
<span class="sd">    pre_max : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples before ``n`` over which max is computed</span>
<span class="sd">    post_max : int &gt;= 1 [scalar]</span>
<span class="sd">        number of samples after ``n`` over which max is computed</span>
<span class="sd">    pre_avg : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples before ``n`` over which mean is computed</span>
<span class="sd">    post_avg : int &gt;= 1 [scalar]</span>
<span class="sd">        number of samples after ``n`` over which mean is computed</span>
<span class="sd">    delta : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold offset for mean</span>
<span class="sd">    wait : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples to wait after picking a peak</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    peaks : np.ndarray [shape=(n_peaks,), dtype=int]</span>
<span class="sd">        indices of peaks in ``x``</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If any input lies outside its defined range</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;trumpet&#39;))</span>
<span class="sd">    &gt;&gt;&gt; onset_env = librosa.onset.onset_strength(y=y, sr=sr,</span>
<span class="sd">    ...                                          hop_length=512,</span>
<span class="sd">    ...                                          aggregate=np.median)</span>
<span class="sd">    &gt;&gt;&gt; peaks = librosa.util.peak_pick(onset_env, pre_max=3, post_max=3, pre_avg=3, post_avg=5, delta=0.5, wait=10)</span>
<span class="sd">    &gt;&gt;&gt; peaks</span>
<span class="sd">    array([  3,  27,  40,  61,  72,  88, 103])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(onset_env, sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=2, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(times, onset_env, alpha=0.8, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].vlines(times[peaks], 0,</span>
<span class="sd">    ...              onset_env.max(), color=&#39;r&#39;, alpha=0.8,</span>
<span class="sd">    ...              label=&#39;Selected peaks&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].legend(frameon=True, framealpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">pre_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;pre_max must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pre_avg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;pre_avg must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;delta must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;wait must be non-negative&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">post_max</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;post_max must be positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">post_avg</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;post_avg must be positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;input array must be one-dimensional&quot;</span><span class="p">)</span>

    <span class="c1"># Ensure valid index types</span>
    <span class="n">pre_max</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">pre_max</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">post_max</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">post_max</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">pre_avg</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">pre_avg</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">post_avg</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">post_avg</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">wait</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>

    <span class="c1"># Get the maximum of the signal over a sliding window</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="n">pre_max</span> <span class="o">+</span> <span class="n">post_max</span>
    <span class="n">max_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">pre_max</span> <span class="o">-</span> <span class="n">post_max</span><span class="p">))</span>
    <span class="c1"># Using mode=&#39;constant&#39; and cval=x.min() effectively truncates</span>
    <span class="c1"># the sliding window at the boundaries</span>
    <span class="n">mov_max</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">maximum_filter1d</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_length</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_origin</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Get the mean of the signal over a sliding window</span>
    <span class="n">avg_length</span> <span class="o">=</span> <span class="n">pre_avg</span> <span class="o">+</span> <span class="n">post_avg</span>
    <span class="n">avg_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">pre_avg</span> <span class="o">-</span> <span class="n">post_avg</span><span class="p">))</span>
    <span class="c1"># Here, there is no mode which results in the behavior we want,</span>
    <span class="c1"># so we&#39;ll correct below.</span>
    <span class="n">mov_avg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">uniform_filter1d</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">avg_length</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">avg_origin</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Correct sliding average at the beginning</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Only need to correct in the range where the window needs to be truncated</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># This just explicitly does mean(x[n - pre_avg:n + post_avg])</span>
        <span class="c1"># with truncation</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">mov_avg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">post_avg</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Correct sliding average at the end</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">post_avg</span>
    <span class="c1"># When post_avg &gt; x.shape[0] (weird case), reset to 0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">mov_avg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">post_avg</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># First mask out all entries not equal to the local max</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mov_max</span><span class="p">)</span>

    <span class="c1"># Then mask out all entries less than the thresholded average</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">detections</span> <span class="o">*</span> <span class="p">(</span><span class="n">detections</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">mov_avg</span> <span class="o">+</span> <span class="n">delta</span><span class="p">))</span>

    <span class="c1"># Initialize peaks array, to be filled greedily</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Remove onsets which are close together in time</span>
    <span class="n">last_onset</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">detections</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Only report an onset if the &quot;wait&quot; samples was reported</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">last_onset</span> <span class="o">+</span> <span class="n">wait</span><span class="p">:</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># Save last reported onset</span>
            <span class="n">last_onset</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span></div>


<div class="viewcode-block" id="sparsify_rows"><a class="viewcode-back" href="../../../generated/librosa.util.sparsify_rows.html#librosa.util.sparsify_rows">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sparsify_rows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a row-sparse matrix approximating the input</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [ndim &lt;= 2]</span>
<span class="sd">        The input matrix to sparsify.</span>
<span class="sd">    quantile : float in [0, 1.0)</span>
<span class="sd">        Percentage of magnitude to discard in each row of ``x``</span>
<span class="sd">    dtype : np.dtype, optional</span>
<span class="sd">        The dtype of the output array.</span>
<span class="sd">        If not provided, then ``x.dtype`` will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_sparse : ``scipy.sparse.csr_matrix`` [shape=x.shape]</span>
<span class="sd">        Row-sparsified approximation of ``x``</span>

<span class="sd">        If ``x.ndim == 1``, then ``x`` is interpreted as a row vector,</span>
<span class="sd">        and ``x_sparse.shape == (1, len(x))``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``x.ndim &gt; 2``</span>

<span class="sd">        If ``quantile`` lies outside ``[0, 1.0)``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Construct a Hann window to sparsify</span>
<span class="sd">    &gt;&gt;&gt; x = scipy.signal.hann(32)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 0.   ,  0.01 ,  0.041,  0.09 ,  0.156,  0.236,  0.326,</span>
<span class="sd">            0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">            0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">            0.72 ,  0.625,  0.525,  0.424,  0.326,  0.236,  0.156,</span>
<span class="sd">            0.09 ,  0.041,  0.01 ,  0.   ])</span>
<span class="sd">    &gt;&gt;&gt; # Discard the bottom percentile</span>
<span class="sd">    &gt;&gt;&gt; x_sparse = librosa.util.sparsify_rows(x, quantile=0.01)</span>
<span class="sd">    &gt;&gt;&gt; x_sparse</span>
<span class="sd">    &lt;1x32 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">        with 26 stored elements in Compressed Sparse Row format&gt;</span>
<span class="sd">    &gt;&gt;&gt; x_sparse.todense()</span>
<span class="sd">    matrix([[ 0.   ,  0.   ,  0.   ,  0.09 ,  0.156,  0.236,  0.326,</span>
<span class="sd">              0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">              0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">              0.72 ,  0.625,  0.525,  0.424,  0.326,  0.236,  0.156,</span>
<span class="sd">              0.09 ,  0.   ,  0.   ,  0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Discard up to the bottom 10th percentile</span>
<span class="sd">    &gt;&gt;&gt; x_sparse = librosa.util.sparsify_rows(x, quantile=0.1)</span>
<span class="sd">    &gt;&gt;&gt; x_sparse</span>
<span class="sd">    &lt;1x32 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">        with 20 stored elements in Compressed Sparse Row format&gt;</span>
<span class="sd">    &gt;&gt;&gt; x_sparse.todense()</span>
<span class="sd">    matrix([[ 0.   ,  0.   ,  0.   ,  0.   ,  0.   ,  0.   ,  0.326,</span>
<span class="sd">              0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">              0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">              0.72 ,  0.625,  0.525,  0.424,  0.326,  0.   ,  0.   ,</span>
<span class="sd">              0.   ,  0.   ,  0.   ,  0.   ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Input must have 2 or fewer dimensions. &quot;</span>
            <span class="s2">&quot;Provided x.shape=</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Invalid quantile </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quantile</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">x_sparse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">mag_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cumulative_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mag_sort</span> <span class="o">/</span> <span class="n">norms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">threshold_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cumulative_mag</span> <span class="o">&lt;</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">threshold_idx</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mag_sort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">x_sparse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x_sparse</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span></div>


<div class="viewcode-block" id="buf_to_float"><a class="viewcode-back" href="../../../generated/librosa.util.buf_to_float.html#librosa.util.buf_to_float">[docs]</a><span class="k">def</span> <span class="nf">buf_to_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_bytes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an integer buffer to floating point values.</span>
<span class="sd">    This is primarily useful when loading integer-valued wav data</span>
<span class="sd">    into numpy arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [dtype=int]</span>
<span class="sd">        The integer-valued data buffer</span>
<span class="sd">    n_bytes : int [1, 2, 4]</span>
<span class="sd">        The number of bytes per sample in ``x``</span>
<span class="sd">    dtype : numeric type</span>
<span class="sd">        The target output type (default: 32-bit float)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_float : np.ndarray [dtype=float]</span>
<span class="sd">        The input data buffer cast to floating point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Invert the scale of the data</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="mi">8</span> <span class="o">*</span> <span class="n">n_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Construct the format string</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;&lt;i</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_bytes</span><span class="p">)</span>

    <span class="c1"># Rescale and format the data buffer</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="index_to_slice"><a class="viewcode-back" href="../../../generated/librosa.util.index_to_slice.html#librosa.util.index_to_slice">[docs]</a><span class="k">def</span> <span class="nf">index_to_slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">idx_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a slice array from an index array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idx : list-like</span>
<span class="sd">        Array of index boundaries</span>
<span class="sd">    idx_min, idx_max : None or int</span>
<span class="sd">        Minimum and maximum allowed indices</span>
<span class="sd">    step : None or int</span>
<span class="sd">        Step size for each slice.  If `None`, then the default</span>
<span class="sd">        step of 1 is used.</span>
<span class="sd">    pad : boolean</span>
<span class="sd">        If `True`, pad ``idx`` to span the range ``idx_min:idx_max``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slices : list of slice</span>
<span class="sd">        ``slices[i] = slice(idx[i], idx[i+1], step)``</span>
<span class="sd">        Additional slice objects may be added at the beginning or end,</span>
<span class="sd">        depending on whether ``pad==True`` and the supplied values for</span>
<span class="sd">        ``idx_min`` and ``idx_max``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fix_frames</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate slices from spaced indices</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15))</span>
<span class="sd">    [slice(20, 35, None), slice(35, 50, None), slice(50, 65, None), slice(65, 80, None),</span>
<span class="sd">     slice(80, 95, None)]</span>
<span class="sd">    &gt;&gt;&gt; # Pad to span the range (0, 100)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15),</span>
<span class="sd">    ...                             idx_min=0, idx_max=100)</span>
<span class="sd">    [slice(0, 20, None), slice(20, 35, None), slice(35, 50, None), slice(50, 65, None),</span>
<span class="sd">     slice(65, 80, None), slice(80, 95, None), slice(95, 100, None)]</span>
<span class="sd">    &gt;&gt;&gt; # Use a step of 5 for each slice</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15),</span>
<span class="sd">    ...                             idx_min=0, idx_max=100, step=5)</span>
<span class="sd">    [slice(0, 20, 5), slice(20, 35, 5), slice(35, 50, 5), slice(50, 65, 5), slice(65, 80, 5),</span>
<span class="sd">     slice(80, 95, 5), slice(95, 100, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First, normalize the index set</span>
    <span class="n">idx_fixed</span> <span class="o">=</span> <span class="n">fix_frames</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">idx_min</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">idx_max</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

    <span class="c1"># Now convert the indices to slices</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_fixed</span><span class="p">,</span> <span class="n">idx_fixed</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>


<div class="viewcode-block" id="sync"><a class="viewcode-back" href="../../../generated/librosa.util.sync.html#librosa.util.sync">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Synchronous aggregation of a multi-dimensional array between boundaries</span>

<span class="sd">    .. note::</span>
<span class="sd">        In order to ensure total coverage, boundary points may be added</span>
<span class="sd">        to ``idx``.</span>

<span class="sd">        If synchronizing a feature matrix against beat tracker output, ensure</span>
<span class="sd">        that frame index numbers are properly aligned and use the same hop length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        multi-dimensional array of features</span>
<span class="sd">    idx : iterable of ints or slices</span>
<span class="sd">        Either an ordered array of boundary indices, or</span>
<span class="sd">        an iterable collection of slice objects.</span>
<span class="sd">    aggregate : function</span>
<span class="sd">        aggregation function (default: `np.mean`)</span>
<span class="sd">    pad : boolean</span>
<span class="sd">        If `True`, ``idx`` is padded to span the full range ``[0, data.shape[axis]]``</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to aggregate data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_sync : ndarray</span>
<span class="sd">        ``data_sync`` will have the same dimension as ``data``, except that the ``axis``</span>
<span class="sd">        coordinate will be reduced according to ``idx``.</span>

<span class="sd">        For example, a 2-dimensional ``data`` with ``axis=-1`` should satisfy::</span>

<span class="sd">            data_sync[:, i] = aggregate(data[:, idx[i-1]:idx[i]], axis=-1)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If the index set is not of consistent type (all slices or all integers)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Beat-synchronous CQT spectra</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.ex(&#39;choice&#39;))</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr, trim=False)</span>
<span class="sd">    &gt;&gt;&gt; C = np.abs(librosa.cqt(y=y, sr=sr))</span>
<span class="sd">    &gt;&gt;&gt; beats = librosa.util.fix_frames(beats)</span>

<span class="sd">    By default, use mean aggregation</span>

<span class="sd">    &gt;&gt;&gt; C_avg = librosa.util.sync(C, beats)</span>

<span class="sd">    Use median-aggregation instead of mean</span>

<span class="sd">    &gt;&gt;&gt; C_med = librosa.util.sync(C, beats,</span>
<span class="sd">    ...                              aggregate=np.median)</span>

<span class="sd">    Or sub-beat synchronization</span>

<span class="sd">    &gt;&gt;&gt; sub_beats = librosa.segment.subsegment(C, beats)</span>
<span class="sd">    &gt;&gt;&gt; sub_beats = librosa.util.fix_frames(sub_beats)</span>
<span class="sd">    &gt;&gt;&gt; C_med_sub = librosa.util.sync(C, sub_beats, aggregate=np.median)</span>

<span class="sd">    Plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; beat_t = librosa.frames_to_time(beats, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; subbeat_t = librosa.frames_to_time(sub_beats, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(nrows=3, sharex=True, sharey=True)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(C,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;, ax=ax[0])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set(title=&#39;CQT power, shape={}&#39;.format(C.shape))</span>
<span class="sd">    &gt;&gt;&gt; ax[0].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(C_med,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_coords=beat_t, x_axis=&#39;time&#39;, ax=ax[1])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set(title=&#39;Beat synchronous CQT power, &#39;</span>
<span class="sd">    ...                 &#39;shape={}&#39;.format(C_med.shape))</span>
<span class="sd">    &gt;&gt;&gt; ax[1].label_outer()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(C_med_sub,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_coords=subbeat_t, x_axis=&#39;time&#39;, ax=ax[2])</span>
<span class="sd">    &gt;&gt;&gt; ax[2].set(title=&#39;Sub-beat synchronous CQT power, &#39;</span>
<span class="sd">    ...                 &#39;shape={}&#39;.format(C_med_sub.shape))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]):</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]):</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">index_to_slice</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">idx_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_max</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Invalid index set: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="n">agg_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">agg_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>

    <span class="n">data_agg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">agg_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>

    <span class="n">idx_in</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">idx_agg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data_agg</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="n">idx_in</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment</span>
        <span class="n">idx_agg</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">data_agg</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_agg</span><span class="p">)]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_in</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_agg</span></div>


<div class="viewcode-block" id="softmask"><a class="viewcode-back" href="../../../generated/librosa.util.softmask.html#librosa.util.softmask">[docs]</a><span class="k">def</span> <span class="nf">softmask</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_ref</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">split_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Robustly compute a soft-mask operation.</span>

<span class="sd">        ``M = X**power / (X**power + X_ref**power)``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        The (non-negative) input array corresponding to the positive mask elements</span>

<span class="sd">    X_ref : np.ndarray</span>
<span class="sd">        The (non-negative) array of reference or background elements.</span>
<span class="sd">        Must have the same shape as ``X``.</span>

<span class="sd">    power : number &gt; 0 or np.inf</span>
<span class="sd">        If finite, returns the soft mask computed in a numerically stable way</span>

<span class="sd">        If infinite, returns a hard (binary) mask equivalent to ``X &gt; X_ref``.</span>
<span class="sd">        Note: for hard masks, ties are always broken in favor of ``X_ref`` (``mask=0``).</span>

<span class="sd">    split_zeros : bool</span>
<span class="sd">        If `True`, entries where ``X`` and ``X_ref`` are both small (close to 0)</span>
<span class="sd">        will receive mask values of 0.5.</span>

<span class="sd">        Otherwise, the mask is set to 0 for these entries.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray, shape=X.shape</span>
<span class="sd">        The output mask array</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If ``X`` and ``X_ref`` have different shapes.</span>

<span class="sd">        If ``X`` or ``X_ref`` are negative anywhere</span>

<span class="sd">        If ``power &lt;= 0``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; X = 2 * np.ones((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; X_ref = np.vander(np.arange(3.0))</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]])</span>
<span class="sd">    &gt;&gt;&gt; X_ref</span>
<span class="sd">    array([[ 0.,  0.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.],</span>
<span class="sd">           [ 4.,  2.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=1)</span>
<span class="sd">    array([[ 1.   ,  1.   ,  0.667],</span>
<span class="sd">           [ 0.667,  0.667,  0.667],</span>
<span class="sd">           [ 0.333,  0.5  ,  0.667]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X_ref, X, power=1)</span>
<span class="sd">    array([[ 0.   ,  0.   ,  0.333],</span>
<span class="sd">           [ 0.333,  0.333,  0.333],</span>
<span class="sd">           [ 0.667,  0.5  ,  0.333]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=2)</span>
<span class="sd">    array([[ 1. ,  1. ,  0.8],</span>
<span class="sd">           [ 0.8,  0.8,  0.8],</span>
<span class="sd">           [ 0.2,  0.5,  0.8]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=4)</span>
<span class="sd">    array([[ 1.   ,  1.   ,  0.941],</span>
<span class="sd">           [ 0.941,  0.941,  0.941],</span>
<span class="sd">           [ 0.059,  0.5  ,  0.941]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=100)</span>
<span class="sd">    array([[  1.000e+00,   1.000e+00,   1.000e+00],</span>
<span class="sd">           [  1.000e+00,   1.000e+00,   1.000e+00],</span>
<span class="sd">           [  7.889e-31,   5.000e-01,   1.000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=np.inf)</span>
<span class="sd">    array([[ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False, False,  True]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">X_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Shape mismatch: </span><span class="si">{}</span><span class="s2">!=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">X_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X_ref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;X and X_ref must be non-negative&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;power must be strictly positive&quot;</span><span class="p">)</span>

    <span class="c1"># We&#39;re working with ints, cast to float.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

    <span class="c1"># Re-scale the input arrays relative to the larger value</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_ref</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># For finite power, compute the softmask</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span> <span class="o">**</span> <span class="n">power</span>
        <span class="n">ref_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_ref</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span> <span class="o">**</span> <span class="n">power</span>
        <span class="n">good_idx</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_idx</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span>
        <span class="c1"># Wherever energy is below energy in both inputs, split the mask</span>
        <span class="k">if</span> <span class="n">split_zeros</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute the hard mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">X</span> <span class="o">&gt;</span> <span class="n">X_ref</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="tiny"><a class="viewcode-back" href="../../../generated/librosa.util.tiny.html#librosa.util.tiny">[docs]</a><span class="k">def</span> <span class="nf">tiny</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the tiny-value corresponding to an input&#39;s data type.</span>

<span class="sd">    This is the smallest &quot;usable&quot; number representable in ``x.dtype``</span>
<span class="sd">    (e.g., float32).</span>

<span class="sd">    This is primarily useful for determining a threshold for</span>
<span class="sd">    numerical underflow in division or multiplication operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : number or np.ndarray</span>
<span class="sd">        The array to compute the tiny-value for.</span>
<span class="sd">        All that matters here is ``x.dtype``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tiny_value : float</span>
<span class="sd">        The smallest positive usable number for the type of ``x``.</span>
<span class="sd">        If ``x`` is integer-typed, then the tiny value for ``np.float32``</span>
<span class="sd">        is returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.finfo</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For a standard double-precision floating point number:</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(1.0)</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Or explicitly as double-precision</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(np.asarray(1e-5, dtype=np.float64))</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Or complex numbers</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(1j)</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Single-precision floating point:</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(np.asarray(1e-5, dtype=np.float32))</span>
<span class="sd">    1.1754944e-38</span>

<span class="sd">    Integer</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(5)</span>
<span class="sd">    1.1754944e-38</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure we have an array view</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Only floating types generate a tiny</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
        <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span>
    <span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span></div>


<span class="k">def</span> <span class="nf">fill_off_diagonal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets all cells of a matrix to a given ``value``</span>
<span class="sd">    if they lie outside a constraint region.</span>

<span class="sd">    In this case, the constraint region is the</span>
<span class="sd">    Sakoe-Chiba band which runs with a fixed ``radius``</span>
<span class="sd">    along the main diagonal.</span>

<span class="sd">    When ``x.shape[0] != x.shape[1]``, the radius will be</span>
<span class="sd">    expanded so that ``x[-1, -1] = 1`` always.</span>

<span class="sd">    ``x`` will be modified in place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Input matrix, will be modified in place.</span>
<span class="sd">    radius : float</span>
<span class="sd">        The band radius (1/2 of the width) will be</span>
<span class="sd">        ``int(radius*min(x.shape))``</span>
<span class="sd">    value : int</span>
<span class="sd">        ``x[n, m] = value`` when ``(n, m)`` lies outside the band.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ones((8, 8))</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fill_off_diagonal(x, radius=0.25)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[1, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 1, 1, 1],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; x = np.ones((8, 12))</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fill_off_diagonal(x, radius=0.25)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Calculate the radius in indices, rather than proportion</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">:</span>
        <span class="n">idx_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">radius</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">idx_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">idx_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="n">radius</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>

    <span class="c1"># modify input matrix</span>
    <span class="n">x</span><span class="p">[</span><span class="n">idx_u</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">x</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<div class="viewcode-block" id="cyclic_gradient"><a class="viewcode-back" href="../../../generated/librosa.util.cyclic_gradient.html#librosa.util.cyclic_gradient">[docs]</a><span class="k">def</span> <span class="nf">cyclic_gradient</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the gradient of a function over a uniformly sampled,</span>
<span class="sd">    periodic domain.</span>

<span class="sd">    This is essentially the same as `np.gradient`, except that edge effects</span>
<span class="sd">    are handled by wrapping the observations (i.e. assuming periodicity)</span>
<span class="sd">    rather than extrapolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        The function values observed at uniformly spaced positions on</span>
<span class="sd">        a periodic domain</span>
<span class="sd">    edge_order : {1, 2}</span>
<span class="sd">        The order of the difference approximation used for estimating</span>
<span class="sd">        the gradient</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which gradients are calculated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grad : np.ndarray like ``data``</span>
<span class="sd">        The gradient of ``data`` taken along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.gradient</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This example estimates the gradient of cosine (-sine) from 64</span>
<span class="sd">    samples using direct (aperiodic) and periodic gradient</span>
<span class="sd">    calculation.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = 2 * np.pi * np.linspace(0, 1, num=64, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = np.cos(x)</span>
<span class="sd">    &gt;&gt;&gt; grad = np.gradient(y)</span>
<span class="sd">    &gt;&gt;&gt; cyclic_grad = librosa.util.cyclic_gradient(y)</span>
<span class="sd">    &gt;&gt;&gt; true_grad = -np.sin(x) * 2 * np.pi / len(x)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, true_grad, label=&#39;True gradient&#39;, linewidth=5,</span>
<span class="sd">    ...          alpha=0.35)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, cyclic_grad, label=&#39;cyclic_gradient&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, grad, label=&#39;np.gradient&#39;, linestyle=&#39;:&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend()</span>
<span class="sd">    &gt;&gt;&gt; # Zoom into the first part of the sequence</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlim=[0, np.pi/16], ylim=[-0.025, 0.025])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Wrap-pad the data along the target axis by `edge_order` on each side</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">padding</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_order</span><span class="p">,</span> <span class="n">edge_order</span><span class="p">)</span>
    <span class="n">data_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the gradient</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data_pad</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Remove the padding</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">edge_order</span><span class="p">,</span> <span class="o">-</span><span class="n">edge_order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span></div>


<span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__shear_dense</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">factor</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Numba-accelerated shear for dense (ndarray) arrays&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>

    <span class="n">X_shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">X_shear</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">X_shear</span> <span class="o">=</span> <span class="n">X_shear</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">X_shear</span>


<span class="k">def</span> <span class="nf">__shear_sparse</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">factor</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fast shearing for sparse matrices</span>

<span class="sd">    Shearing is performed using CSC array indices,</span>
<span class="sd">    and the result is converted back to whatever sparse format</span>
<span class="sd">    the data was originally provided in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">format</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Now we&#39;re definitely rolling on the correct axis</span>
    <span class="n">X_shear</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># The idea here is to repeat the shear amount (factor * range)</span>
    <span class="c1"># by the number of non-zeros for each column.</span>
    <span class="c1"># The number of non-zeros is computed by diffing the index pointer array</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">X_shear</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X_shear</span><span class="o">.</span><span class="n">indptr</span><span class="p">))</span>

    <span class="c1"># In-place roll</span>
    <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">X_shear</span><span class="o">.</span><span class="n">indices</span> <span class="o">+</span> <span class="n">roll</span><span class="p">,</span> <span class="n">X_shear</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">X_shear</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">X_shear</span> <span class="o">=</span> <span class="n">X_shear</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># And convert back to the input format</span>
    <span class="k">return</span> <span class="n">X_shear</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>


<div class="viewcode-block" id="shear"><a class="viewcode-back" href="../../../generated/librosa.util.shear.html#librosa.util.shear">[docs]</a><span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shear a matrix by a given factor.</span>

<span class="sd">    The column ``X[:, n]`` will be displaced (rolled)</span>
<span class="sd">    by ``factor * n``</span>

<span class="sd">    This is primarily useful for converting between lag and recurrence</span>
<span class="sd">    representations: shearing with ``factor=-1`` converts the main diagonal</span>
<span class="sd">    to a horizontal.  Shearing with ``factor=1`` converts a horizontal to</span>
<span class="sd">    a diagonal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray [ndim=2] or scipy.sparse matrix</span>
<span class="sd">        The array to be sheared</span>
<span class="sd">    factor : integer</span>
<span class="sd">        The shear factor: ``X[:, n] -&gt; np.roll(X[:, n], factor * n)``</span>
<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to shear</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_shear : same type as ``X``</span>
<span class="sd">        The sheared matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; E = np.eye(3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.shear(E, factor=-1, axis=-1)</span>
<span class="sd">    array([[1., 1., 1.],</span>
<span class="sd">           [0., 0., 0.],</span>
<span class="sd">           [0., 0., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.shear(E, factor=-1, axis=0)</span>
<span class="sd">    array([[1., 0., 0.],</span>
<span class="sd">           [1., 0., 0.],</span>
<span class="sd">           [1., 0., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.shear(E, factor=1, axis=-1)</span>
<span class="sd">    array([[1., 0., 0.],</span>
<span class="sd">           [0., 0., 1.],</span>
<span class="sd">           [0., 1., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;factor=</span><span class="si">{}</span><span class="s2"> must be integer-valued&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">factor</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">__shear_sparse</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">__shear_dense</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../generated/librosa.util.stack.html#librosa.util.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stack one or more arrays along a target axis.</span>

<span class="sd">    This function is similar to `np.stack`, except that memory contiguity is</span>
<span class="sd">    retained when stacking along the first dimension.</span>

<span class="sd">    This is useful when combining multiple monophonic audio signals into a</span>
<span class="sd">    multi-channel signal, or when stacking multiple feature representations</span>
<span class="sd">    to form a multi-dimensional array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : list</span>
<span class="sd">        one or more `np.ndarray`</span>
<span class="sd">    axis : integer</span>
<span class="sd">        The target axis along which to stack.  ``axis=0`` creates a new first axis,</span>
<span class="sd">        and ``axis=-1`` creates a new last axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr_stack : np.ndarray [shape=(len(arrays), array_shape) or shape=(array_shape, len(arrays))]</span>
<span class="sd">        The input arrays, stacked along the target dimension.</span>

<span class="sd">        If ``axis=0``, then ``arr_stack`` will be F-contiguous.</span>
<span class="sd">        Otherwise, ``arr_stack`` will be C-contiguous by default, as computed by</span>
<span class="sd">        `np.stack`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        - If ``arrays`` do not all have the same shape</span>
<span class="sd">        - If no ``arrays`` are given</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.stack</span>
<span class="sd">    numpy.ndarray.flags</span>
<span class="sd">    frame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Combine two buffers into a contiguous arrays</span>

<span class="sd">    &gt;&gt;&gt; y_left = np.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; y_right = -np.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; y_stereo = librosa.util.stack([y_left, y_right], axis=0)</span>
<span class="sd">    &gt;&gt;&gt; y_stereo</span>
<span class="sd">    array([[ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [-1., -1., -1., -1., -1.]])</span>
<span class="sd">    &gt;&gt;&gt; y_stereo.flags</span>
<span class="sd">      C_CONTIGUOUS : False</span>
<span class="sd">      F_CONTIGUOUS : True</span>
<span class="sd">      OWNDATA : True</span>
<span class="sd">      WRITEABLE : True</span>
<span class="sd">      ALIGNED : True</span>
<span class="sd">      WRITEBACKIFCOPY : False</span>
<span class="sd">      UPDATEIFCOPY : False</span>

<span class="sd">    Or along the trailing axis</span>

<span class="sd">    &gt;&gt;&gt; y_stereo = librosa.util.stack([y_left, y_right], axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; y_stereo</span>
<span class="sd">    array([[ 1., -1.],</span>
<span class="sd">           [ 1., -1.],</span>
<span class="sd">           [ 1., -1.],</span>
<span class="sd">           [ 1., -1.],</span>
<span class="sd">           [ 1., -1.]])</span>
<span class="sd">    &gt;&gt;&gt; y_stereo.flags</span>
<span class="sd">      C_CONTIGUOUS : True</span>
<span class="sd">      F_CONTIGUOUS : False</span>
<span class="sd">      OWNDATA : True</span>
<span class="sd">      WRITEABLE : True</span>
<span class="sd">      ALIGNED : True</span>
<span class="sd">      WRITEBACKIFCOPY : False</span>
<span class="sd">      UPDATEIFCOPY : False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shapes</span> <span class="o">=</span> <span class="p">{</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;all input arrays must have the same shape&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;at least one input array must be provided for stack&quot;</span><span class="p">)</span>

    <span class="n">shape_in</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If axis is 0, enforce F-ordering</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_in</span><span class="p">))</span>

        <span class="c1"># Find the common dtype for all inputs</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="p">[])</span>

        <span class="c1"># Allocate an empty array of the right shape and type</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="c1"># Stack into the preallocated buffer</span>
        <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="dtype_r2c"><a class="viewcode-back" href="../../../generated/librosa.util.dtype_r2c.html#librosa.util.dtype_r2c">[docs]</a><span class="k">def</span> <span class="nf">dtype_r2c</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the complex numpy dtype corresponding to a real dtype.</span>

<span class="sd">    This is used to maintain numerical precision and memory footprint</span>
<span class="sd">    when constructing complex arrays from real-valued data</span>
<span class="sd">    (e.g. in a Fourier transform).</span>

<span class="sd">    A `float32` (single-precision) type maps to `complex64`,</span>
<span class="sd">    while a `float64` (double-precision) maps to `complex128`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : np.dtype</span>
<span class="sd">        The real-valued dtype to convert to complex.</span>
<span class="sd">        If ``d`` is a complex type already, it will be returned.</span>
<span class="sd">    default : np.dtype, optional</span>
<span class="sd">        The default complex target type, if ``d`` does not match a</span>
<span class="sd">        known dtype</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d_c : np.dtype</span>
<span class="sd">        The complex dtype</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtype_c2r</span>
<span class="sd">    numpy.dtype</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.float32)</span>
<span class="sd">    dtype(&#39;complex64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.int16)</span>
<span class="sd">    dtype(&#39;complex64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.complex128)</span>
<span class="sd">    dtype(&#39;complex128&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># If we&#39;re given a complex type already, return it</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dt</span>

    <span class="c1"># Otherwise, try to map the dtype.</span>
    <span class="c1"># If no match is found, return the default.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span></div>


<div class="viewcode-block" id="dtype_c2r"><a class="viewcode-back" href="../../../generated/librosa.util.dtype_c2r.html#librosa.util.dtype_c2r">[docs]</a><span class="k">def</span> <span class="nf">dtype_c2r</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the real numpy dtype corresponding to a complex dtype.</span>

<span class="sd">    This is used to maintain numerical precision and memory footprint</span>
<span class="sd">    when constructing real arrays from complex-valued data</span>
<span class="sd">    (e.g. in an inverse Fourier transform).</span>

<span class="sd">    A `complex64` (single-precision) type maps to `float32`,</span>
<span class="sd">    while a `complex128` (double-precision) maps to `float64`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : np.dtype</span>
<span class="sd">        The complex-valued dtype to convert to real.</span>
<span class="sd">        If ``d`` is a real (float) type already, it will be returned.</span>
<span class="sd">    default : np.dtype, optional</span>
<span class="sd">        The default real target type, if ``d`` does not match a</span>
<span class="sd">        known dtype</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d_r : np.dtype</span>
<span class="sd">        The real dtype</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtype_r2c</span>
<span class="sd">    numpy.dtype</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.complex64)</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.float32)</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.int16)</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.dtype_r2c(np.complex128)</span>
<span class="sd">    dtype(&#39;float64&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">complex</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># If we&#39;re given a real type already, return it</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dt</span>

    <span class="c1"># Otherwise, try to map the dtype.</span>
    <span class="c1"># If no match is found, return the default.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">default</span><span class="p">))</span></div>


<span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__count_unique</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Counts the number of unique values in an array.</span>

<span class="sd">    This function is a helper for `count_unique` and is not</span>
<span class="sd">    to be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniques</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="count_unique"><a class="viewcode-back" href="../../../generated/librosa.util.count_unique.html#librosa.util.count_unique">[docs]</a><span class="k">def</span> <span class="nf">count_unique</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Count the number of unique values in a multi-dimensional array</span>
<span class="sd">    along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        The input array</span>
<span class="sd">    axis : int</span>
<span class="sd">        The target axis to count</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n_uniques</span>
<span class="sd">        The number of unique values.</span>
<span class="sd">        This array will have one fewer dimension than the input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    is_unique</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.vander(np.arange(5))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[  0,   0,   0,   0,   1],</span>
<span class="sd">       [  1,   1,   1,   1,   1],</span>
<span class="sd">       [ 16,   8,   4,   2,   1],</span>
<span class="sd">       [ 81,  27,   9,   3,   1],</span>
<span class="sd">       [256,  64,  16,   4,   1]])</span>
<span class="sd">    &gt;&gt;&gt; # Count unique values along rows (within columns)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.count_unique(x, axis=0)</span>
<span class="sd">    array([5, 5, 5, 5, 1])</span>
<span class="sd">    &gt;&gt;&gt; # Count unique values along columns (within rows)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.count_unique(x, axis=-1)</span>
<span class="sd">    array([2, 1, 5, 5, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">__count_unique</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__is_unique</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines if the input array has all unique values.</span>

<span class="sd">    This function is a helper for `is_unique` and is not</span>
<span class="sd">    to be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">uniques</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniques</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>


<div class="viewcode-block" id="is_unique"><a class="viewcode-back" href="../../../generated/librosa.util.is_unique.html#librosa.util.is_unique">[docs]</a><span class="k">def</span> <span class="nf">is_unique</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine if the input array consists of all unique values</span>
<span class="sd">    along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        The input array</span>
<span class="sd">    axis : int</span>
<span class="sd">        The target axis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_unique</span>
<span class="sd">        Array of booleans indicating whether the data is unique along the chosen</span>
<span class="sd">        axis.</span>
<span class="sd">        This array will have one fewer dimension than the input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    count_unique</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.vander(np.arange(5))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[  0,   0,   0,   0,   1],</span>
<span class="sd">       [  1,   1,   1,   1,   1],</span>
<span class="sd">       [ 16,   8,   4,   2,   1],</span>
<span class="sd">       [ 81,  27,   9,   3,   1],</span>
<span class="sd">       [256,  64,  16,   4,   1]])</span>
<span class="sd">    &gt;&gt;&gt; # Check uniqueness along rows</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.is_unique(x, axis=0)</span>
<span class="sd">    array([ True,  True,  True,  True, False])</span>
<span class="sd">    &gt;&gt;&gt; # Check uniqueness along columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.is_unique(x, axis=-1)</span>
<span class="sd">    array([False, False,  True,  True,  True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">__is_unique</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2013--2022, librosa development team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 0.9.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="utils.html">0.9.0</a></dd>
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-171031946-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>